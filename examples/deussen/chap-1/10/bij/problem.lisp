;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(PREP-PROBLEM.SPECIFICATION (QUOTE ((SORT ELEMENT,MENGE,VERKN,ABB : ANY) (ALL A,B : MENGE A = B IMPL GLEICHMAECHTIG (A B)) (ALL CHI : ABB ALL A,B : MENGE INJEKTIV (CHI A B) AND GLEICHMAECHTIG (A B) AND ENDLICH (A) AND ENDLICH (B) IMPL BIJEKTIV (CHI A B)))) (QUOTE ((+ 0 NIL NIL) (ALL 4 (ALL 3 (IMPL (+ 2 (3 4) NIL) (+ 5 (3 4) NIL)))) (ALL 6 (ALL 8 (ALL 7 (IMPL (AND (+ 9 (6 7 8) NIL) (AND (+ 5 (7 8) NIL) (AND (+ 10 (7) NIL) (+ 10 (8) NIL)))) (+ 11 (6 7 8) NIL))))))) (QUOTE ((ALL CHI : ABB ALL U : MENGE INJEKTIV (CHI U U) AND ENDLICH (U) IMPL BIJEKTIV (CHI U U)))) (QUOTE ((ALL 12 (ALL 13 (IMPL (AND (+ 9 (12 13 13) NIL) (+ 10 (13) NIL)) (+ 11 (12 13 13) NIL)))))) (QUOTE ("Edit:     Axioms and Theorems edited: 24-OCT,1991 18:58 ")) (PROGN(PROGN (DT-RESET))

(PROG ((ADDRLIST '(9864 9869 9884 9899 9914 9919 9924 9929 9944 9949 9954 9969 9984 9999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "=" NIL NIL (ANY ANY)
          (DEFINED SYMMETRIC REFLEXIVE) NIL ((- 2 (POSITIVE . SYMMETRIC)))
          ((+ 2 (NEGATIVE . SYMMETRIC))) ((+ 2 (NIL . SYMMETRIC))) ((- 2 (NIL . SYMMETRIC)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 5 MENGE NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 MENGE NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "GLEICHMAECHTIG"
          NIL NIL (ANY ANY) NIL NIL ((- 5 (POSITIVE))) ((+ 5 (NEGATIVE))) ((+ 5 (NIL)))
          ((- 5 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ABB NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 MENGE NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 MENGE NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "INJEKTIV" NIL NIL (ANY ANY ANY) NIL
          NIL ((- 9 (POSITIVE))) ((+ 9 (NEGATIVE))) ((+ 9 (NIL))) ((- 9 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 15 "ENDLICH" NIL NIL (ANY) NIL NIL ((- 10 (POSITIVE)))
          ((+ 10 (NEGATIVE))) ((+ 10 (NIL))) ((- 10 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE
          15 "BIJEKTIV" NIL NIL (ANY ANY ANY) NIL NIL ((- 11 (POSITIVE))) ((+ 11 (NEGATIVE)))
          ((+ 11 (NIL))) ((- 11 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ABB NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 MENGE NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE))
       (INCREMENT (- MEM*SIZE 10000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 10000)
             (SETQ COUNTER1 14)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (DECF COUNTER1))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((EQL 'END RADDR) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            (T (UNLESS (= MEM*SIZE 10000)
                 (MEM-INITIALIZE 10000))
               (SETQ COUNTER1 14)
               (MAPC #'(LAMBDA (RADDR) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            )
      (SETQ MEM*NEXT.RADR (IF (> MEM*SIZE 10000) (+ 9859 INCREMENT) 9859))
      (SETQ MEM*NEXT.VADR 14
            MEM*REST (- MEM*NEXT.RADR MEM*NEXT.VADR -1)
            MEM*FIRST.REUSABLE.VADR NIL
            MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL (QUOTE (ABB VERKN MENGE ELEMENT ANY))) (SETQ DT*SORT.NR (QUOTE 6)) (SETQ DT*SORT.PROPERTIES (QUOTE (DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))) (SETQ DT*SORT.COMMON.COMPUTE.FLAG (QUOTE NIL)) (SETQ DT*ELEMENT.PREDICATE (QUOTE NIL)) (SETQ DT*OMEGA.CONSTANT (QUOTE NIL)) (SETQ DT*VARIABLE.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.ALL (QUOTE NIL)) (SETQ DT*ABBREVIATIONS (QUOTE NIL)) (SETQ DT*FUNCTION.COUNTER (QUOTE 0)) (SETQ DT*FUNCTION.ALL (QUOTE NIL)) (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES (QUOTE (ASSOCIATIVE))) (SETQ DT*FUNCTION.ACTUAL.THEORIES (QUOTE NIL)) (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES (QUOTE NIL)) (SETQ DT*FUNCTION.COMPONENTS (QUOTE (PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))) (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES (QUOTE (SYMMETRIC DEFINED REFLEXIVE))) (SETQ DT*PREDICATE.COUNTER (QUOTE 0)) (SETQ DT*EQUALITY.SYMBOLS (QUOTE ("=" ":=" "=:" ":=:"))) (SETQ DT*EQUALITY.PREDICATES (QUOTE (2))) (SETQ DT*NONEQUALITY.PREDICATES (QUOTE (11 10 9 5 1 0))) (SETQ DT*PREDICATE.ALL (QUOTE (11 10 9 5 2 1 0))) (SETQ DT*PREDICATE.WITH.ATTRIBUTES (QUOTE NIL)) (SETQ DT*PREDICATE.COMPONENTS (QUOTE (PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES -TOTHERSIDES))) (SETQ DT*TRUE.PREDICATE (QUOTE 0)) (SETQ DT*FALSE.PREDICATE (QUOTE 1)) (SETQ DT*UNI.CREATES.VARIABLES (QUOTE NIL)) (SETQ DT*SIGN.MINUS.SYMBOLS (QUOTE (- --))) (SETQ DT*SIGN.PLUS.SYMBOLS (QUOTE (+ ++))) (SETQ DT*SYMBOL.KINDS (QUOTE (CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL)))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET (QUOTE ABB) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ABB) (QUOTE DT*SORT.NUMBER)) (QUOTE 5)) (SETF (GET (QUOTE ABB) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ABB))) (SETF (GET (QUOTE ABB) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ABB ABB) (VERKN) (MENGE) (ELEMENT) (ANY ABB)))) (SETF (GET (QUOTE ABB) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (ABB))) (SETF (GET (QUOTE ABB) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE ABB) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY ABB)))) (PROGN (SETF (GET (QUOTE VERKN) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE VERKN) (QUOTE DT*SORT.NUMBER)) (QUOTE 4)) (SETF (GET (QUOTE VERKN) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (VERKN))) (SETF (GET (QUOTE VERKN) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ABB) (VERKN VERKN) (MENGE) (ELEMENT) (ANY VERKN)))) (SETF (GET (QUOTE VERKN) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (VERKN))) (SETF (GET (QUOTE VERKN) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE VERKN) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY VERKN)))) (PROGN (SETF (GET (QUOTE MENGE) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE MENGE) (QUOTE DT*SORT.NUMBER)) (QUOTE 3)) (SETF (GET (QUOTE MENGE) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (MENGE))) (SETF (GET (QUOTE MENGE) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ABB) (VERKN) (MENGE MENGE) (ELEMENT) (ANY MENGE)))) (SETF (GET (QUOTE MENGE) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (MENGE))) (SETF (GET (QUOTE MENGE) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE MENGE) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY MENGE)))) (PROGN (SETF (GET (QUOTE ELEMENT) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*SORT.NUMBER)) (QUOTE 2)) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ELEMENT))) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ABB) (VERKN) (MENGE) (ELEMENT ELEMENT) (ANY ELEMENT)))) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (ELEMENT))) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE ELEMENT) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY ELEMENT)))) (PROGN (SETF (GET (QUOTE ANY) (QUOTE DT*SORT.NUMBER)) (QUOTE 1)) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE (ABB VERKN MENGE ELEMENT))) (SETF (GET (QUOTE ANY) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ANY ABB VERKN MENGE ELEMENT))) (SETF (GET (QUOTE ANY) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ABB ABB) (VERKN VERKN) (MENGE MENGE) (ELEMENT ELEMENT) (ANY ANY)))) (SETF (GET (QUOTE ANY) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (VERKN MENGE ELEMENT))) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY))))) ))