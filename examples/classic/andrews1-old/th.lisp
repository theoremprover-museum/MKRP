;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(COND ((FMT-LOAD "23-NOV-1987 17:52"
  NIL
  (((((EX X (ALL Y P (X) EQV P (Y))) EQV ((EX X Q (X)) EQV (ALL Y P (Y)))) EQV
   ((EX X (ALL Y Q (X) EQV Q (Y))) EQV ((EX X P (X)) EQV (ALL Y Q (Y)))))
  (EQV
   (EQV
    (EX 11
     (ALL 10
      (EQV (+ 9 (11) (KIND (EQV T 20 EQV T 22 EQV T 26)))
       (+ 9 (10) (KIND (EQV NIL 20 EQV T 22 EQV T 26))))))
    (EQV (EX 8 (+ 7 (8) (KIND (EQV T 21 EQV NIL 22 EQV T 26))))
     (ALL 5 (+ 9 (5) (KIND (EQV NIL 21 EQV NIL 22 EQV T 26))))))
   (EQV
    (EX 3
     (ALL 2
      (EQV (+ 7 (3) (KIND (EQV T 23 EQV T 25 EQV NIL 26)))
       (+ 7 (2) (KIND (EQV NIL 23 EQV T 25 EQV NIL 26))))))
    (EQV (EX 12 (+ 9 (12) (KIND (EQV T 24 EQV NIL 25 EQV NIL 26))))
     (ALL 13 (+ 7 (13) (KIND (EQV NIL 24 EQV NIL 25 EQV NIL 26)))))))
  QUANTIFICATION)))(COND (ST*LOAD.FLAG (PROGN (DT-RESET))

(PROG ((ADDRLIST
        '(139904 139909 139969 139964 139959 139944 139939 ATP.MEMORY.NIL 139924
          ATP.MEMORY.NIL 139919 139914 139984 139999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "P" NIL NIL (ANY)
          NIL NIL ((- 9 (POSITIVE))) ((+ 9 (NEGATIVE))) ((+ 9 (NIL))) ((- 9 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15
          "Q" NIL NIL (ANY) NIL NIL ((- 7 (POSITIVE))) ((+ 7 (NEGATIVE))) ((+ 7 (NIL)))
          ((- 7 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE))
       (INCREMENT (- MEM*SIZE 140000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 140000)
             (SETQ COUNTER1 14)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (DECF COUNTER1))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            (T (UNLESS (= MEM*SIZE 140000)
                 (MEM-INITIALIZE 140000))
               (SETQ COUNTER1 14)
               (MAPC #'(LAMBDA (RADDR) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            )
      (COND ((> MEM*SIZE 140000) (SETQ MEM*NEXT.RADR (+ 139899 INCREMENT)))
            (T (SETQ MEM*NEXT.RADR 139899)))
      (SETQ MEM*NEXT.VADR 14)
      (SETQ MEM*REST (1+ (- MEM*NEXT.RADR MEM*NEXT.VADR)))
      (SETQ MEM*FIRST.REUSABLE.VADR NIL)
      (SETQ MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL '(ANY))
       (SETQ DT*SORT.NR '2)
       (SETQ DT*SORT.PROPERTIES
              '(DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE
                DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS
                DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))
       (SETQ DT*SORT.COMMON.COMPUTE.FLAG 'NIL)
       (SETQ DT*VARIABLE.COUNTER '0)
       (SETQ DT*CONSTANT.COUNTER '0)
       (SETQ DT*CONSTANT.ALL 'NIL)
       (SETQ DT*ABBREVIATIONS 'NIL)
       (SETQ DT*FUNCTION.COUNTER '0)
       (SETQ DT*FUNCTION.ALL 'NIL)
       (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES '(ASSOCIATIVE))
       (SETQ DT*FUNCTION.ACTUAL.THEORIES 'NIL)
       (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES 'NIL)
       (SETQ DT*FUNCTION.COMPONENTS
              '(PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST
                SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))
       (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES '(SYMMETRIC DEFINED REFLEXIVE))
       (SETQ DT*PREDICATE.COUNTER '0)
       (SETQ DT*EQUALITY.SYMBOLS '("=" ":=" "=:" ":=:"))
       (SETQ DT*EQUALITY.PREDICATES 'NIL)
       (SETQ DT*NONEQUALITY.PREDICATES '(7 9 1 0))
       (SETQ DT*PREDICATE.ALL '(7 9 1 0))
       (SETQ DT*PREDICATE.WITH.ATTRIBUTES 'NIL)
       (SETQ DT*PREDICATE.COMPONENTS
              '(PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES
                REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES
                -TOTHERSIDES))
       (SETQ DT*TRUE.PREDICATE '0)
       (SETQ DT*FALSE.PREDICATE '1)
       (SETQ DT*UNI.CREATES.VARIABLES 'NIL)
       (SETQ DT*SIGN.MINUS.SYMBOLS '(- --))
       (SETQ DT*SIGN.PLUS.SYMBOLS '(+ ++))
       (SETQ DT*SYMBOL.KINDS '(CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET 'ANY 'DT*SORT.NUMBER) '1)
              (SETF (GET 'ANY 'DT*DIRECT.SUBSORTS) 'NIL)
              (SETF (GET 'ANY 'DT*TRANSITIVE.CLOSURE) '(ANY))
              (SETF (GET 'ANY 'DT*MAX.SUBSORTS) '((ANY ANY)))
              (SETF (GET 'ANY 'DT*MINIMAL.SUBSORTS) '(ANY))
              (SETF (GET 'ANY 'DT*DIRECT.SUPERSORTS) 'NIL)
              (SETF (GET 'ANY 'DT*INVERSE.TRANSITIVE.CLOSURE) '(ANY)))) (PROGN (SETQ ST*STACK1 ST*STACK1)
       (SETQ ST*SYMBOL.ADDRESSES
              '(NIL (ANY . T) (TRUE . 0) (FALSE . 1) (X_11 . 11) (X_10 . 10) (P . 9) (X_8 . 8)
                (Q . 7) (X_5 . 5) (X_3 . 3) (X_2 . 2) (X_12 . 12) (X_13 . 13))))))))