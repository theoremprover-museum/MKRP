(COND ((FMT-LOAD " 6-NOV-84 18:24:02"
NIL(((* SMULLYAN, KAPITEL 6, INSPEKTOR CRAIG) COMMENT COMMENT) ((* ALS GUTER KRIMINALIST ZOG INSPEKTOR CRAIG ERST EINMAL SEINE SCHLUESSE AUS DEN ERMITTELTEN FAKTEN.) COMMENT COMMENT) ((* NACH UEBERSETZUNG DER OBIGEN TATBESTAENDE IN PRAEDIKATENLOGIK
KANN DIESE AUFGABE) COMMENT COMMENT) ((* AUCH VON EINEM AUTOMATISCHEN BEWEISER UEBERNOMMEN WERDEN.) COMMENT COMMENT) ((* DAZU WERDEN DIE EINZELNEN AUSSAGEN ZUNAECHST ETWAS WEITER AUFGESCHLUESSELT:) COMMENT COMMENT) ((*) COMMENT COMMENT) ((* 1:
JEDER IST MIT SICH SELBST IDENTISCH.) COMMENT COMMENT) ((* 2: A IST NICHT IDENTISCH MIT B.) COMMENT COMMENT) ((* 3: A IST NICHT IDENTISCH MIT C.) COMMENT COMMENT) ((* 4: B IST NICHT IDENTISCH MIT C.) COMMENT COMMENT) ((* 5: WENN C SCHULDIG IST,
DANN IST AUCH B SCHULDIG.) COMMENT COMMENT) ((* 6: WENN B SCHULDIG IST, DANN IST AUCH C SCHULDIG.) COMMENT COMMENT) ((* 7: MINDESTENS EINER DER DREI MAENNER A, B, C IST SCHULDIG.) COMMENT COMMENT) ((* 8: WENN A SCHULDIG IST, DANN IST EINER DER
MAENNER B, C EBENFALLS SCHULDIG.) COMMENT COMMENT) ((* 9: WENN A SCHULDIG IST, DANN IST EINER DER MAENNER B, C UNSCHULDIG.) COMMENT COMMENT) ((* 10: WENN ZWEI VERSCHIEDENE MAENNER SCHULDIG SIND UND DER DRITTE IST UNSCHULDIG, DANN IST A SCHULDIG.)
COMMENT COMMENT) ((*) COMMENT COMMENT) ((*) COMMENT COMMENT) ((* DER BEWEISER ZOG DARAUS FOLGENDE SCHLUESSE:) COMMENT COMMENT) ((*) COMMENT COMMENT) ((* WENN A UNSCHULDIG UND C EBENFALLS UNSCHULDIG IST, SO IST B SCHULDIG WEGEN 7) COMMENT COMMENT)
((* WENN A UNSCHULDIG, C ABER SCHULDIG IST, SO IST B SCHULDIG WEGEN 5) COMMENT COMMENT) ((* UNABHAENGIG DAVON, OB NUN C SCHULDIG IST ODER NICHT, GILT IN JEDEM FALL) COMMENT COMMENT) ((* D2: WENN A UNSCHULDIG IST, DANN IST B SCHULDIG.) COMMENT
COMMENT) ((* WENN A SCHULDIG IST, DANN SIND WEGEN 8 ENTWEDER B ODER C ODER BEIDE SCHULDIG.) COMMENT COMMENT) ((* FALLS ES C IST, MUSS B WEGEN 5 EBENFALLS SCHULDIG SEIN. ALSO GILT) COMMENT COMMENT) ((* D4: WENN A SCHULDIG IST, DANN IST B SCHULDIG.)
COMMENT COMMENT) ((* GLEICHGUELTIG, OB A SCHULDIG IST ODER NICHT, AUS D2 UND D4 FOLGT) COMMENT COMMENT) ((* D6: B IST SCHULDIG.) COMMENT COMMENT) ((* WEGEN 6 ERGIBT SICH DARAUS SOFORT) COMMENT COMMENT) ((* R7: C IST SCHULDIG.) COMMENT COMMENT)
((* DEMNACH SIND ALSO SOWOHL B ALS AUCH C SCHULDIG. WAERE A EBENFALLS SCHULDIG, MUESSTE EINER DER BEIDEN) COMMENT COMMENT) ((* ABER WEGEN 9 UNSCHULDIG SEIN. DA DIES NICHT DER FALL IST , GILT) COMMENT COMMENT) ((* R9: A IST UNSCHULDIG.) COMMENT
COMMENT) ((* SOMIT KANN DIE VORAUSSETZUNG VON 10 NICHT ERFUELLT SEIN, DENN DIES HAETTE JA DIE SCHULD VON A ZUR FOLGE.) COMMENT COMMENT) ((* ES GILT ALSO) COMMENT COMMENT) ((* R10: ES IST NICHT DER FALL, DASS ZWEI VERSCHIEDENE MAENNER SCHULDIG
UND EIN DRITTER UNSCHULDIG SIND.) COMMENT COMMENT) ((* NUN SIND ABER B UND C NACH 4 ZWEI VERSCHIEDENE MAENNER, DIE WEGEN D6 UND R7 SCHULDIG SIND.) COMMENT COMMENT) ((* AUSSERDEM IST A WEGEN 2 UND 3 EIN DRITTER, DER WEGEN R9 UNSCHULDIG IST.) COMMENT
COMMENT) ((* DIES WIRD ABER VON R10 GERADE AUSGESCHLOSSEN, DIE ERMITTELTEN TATSACHEN ENTHALTEN ALSO EINEN WIDERSPRUCH.) COMMENT COMMENT) ((*) COMMENT COMMENT) ((* DIE SACHE KANN SICH ALSO NICHT SO ABGESPIELT HABEN, WIE MCGREGOR BEHAUPTET.) COMMENT
COMMENT) ((* OB INSPEKTOR CRAIG NUN EINEN AUTOMATISCHEN BEWEISER BENUTZTE ODER DEN WIDERSPRUCH SELBST ENTDECKTE,) COMMENT COMMENT) ((* ES BLIEB IHM NICHTS ANDERES UEBRIG, ALS MCGREGOR DER VORTAEUSCHUNG EINES RAUBUEBERFALLS) COMMENT COMMENT) ((*
ZU BESCHULDIGEN.) COMMENT COMMENT) ((*) COMMENT COMMENT)))(COND (ST*LOAD.FLAG (PROGN (DT-RESET))
(PROG ((ADDRLIST (QUOTE (19915 19920 19925 19940 19945 19950 19955 19970 19985 20000))) (DATALIST (QUOTE (15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE
15 "FALSE" NIL NIL NIL (DEFINED) NIL ((- 2 (POSITIVE))) ((+ 2 (NEGATIVE))) ((+ 2 (NIL))) ((- 2 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "=" NIL NIL (ANY ANY) (DEFINED SYMMETRIC REFLEXIVE SYMMETRIC REFLEXIVE) NIL ((- 3 (POSITIVE . SYMMETRIC)))
((+ 3 (NEGATIVE . SYMMETRIC))) ((+ 3 (NIL . SYMMETRIC))) ((- 3 (NIL . SYMMETRIC))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 "B" ANY (DT*ST-KIND NIL) CONSTANT 5 "A" ANY (DT*ST-KIND NIL) CONSTANT 5 "C" ANY (DT*ST-KIND NIL) CONSTANT 15 "SCHULDIG" NIL
NIL (ANY) NIL NIL ((- 7 (POSITIVE))) ((+ 7 (NEGATIVE))) ((+ 7 (NIL))) ((- 7 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL
DT*ST-KIND SYS-VAR) VARIABLE))) (INCREMENT (IDIFFERENCE MEM*SIZE 20000)) COUNTER1) (MEM-RESET) (COND ((IGREATERP MEM*SIZE 20000) (SETQ COUNTER1 11) (MAPC ADDRLIST (FUNCTION (LAMBDA (RADDR) (SETA MEM*MEMORY (SETQ COUNTER1 (SUB1 COUNTER1)) (COND
((EQ RADDR (QUOTE ATP.MEMORY.NIL)) RADDR) ((OR (EQ RADDR 0) (MINUSP RADDR)) RADDR) (T (IPLUS RADDR INCREMENT))))))) (SETQ COUNTER1 (ADD1 MEM*SIZE)) (MAPC DATALIST (FUNCTION (LAMBDA (DATA) (SETA MEM*MEMORY (SETQ COUNTER1 (SUB1 COUNTER1)) DATA)))))
(T (COND ((NEQ MEM*SIZE 20000) (MEM-INITIALIZE 20000))) (SETQ COUNTER1 11) (MAPC ADDRLIST (FUNCTION (LAMBDA (RADDR) (SETA MEM*MEMORY (SETQ COUNTER1 (SUB1 COUNTER1)) RADDR)))) (SETQ COUNTER1 (ADD1 MEM*SIZE)) (MAPC DATALIST (FUNCTION (LAMBDA (DATA)
(SETA MEM*MEMORY (SETQ COUNTER1 (SUB1 COUNTER1)) DATA)))))) (COND ((IGREATERP MEM*SIZE 20000) (RPAQ MEM*NEXT.RADR (IPLUS 19910 INCREMENT))) (T (RPAQ MEM*NEXT.RADR 19910))) (RPAQ MEM*NEXT.VADR 11) (RPAQ MEM*REST (ADD1 (IDIFFERENCE MEM*NEXT.RADR
MEM*NEXT.VADR))) (RPAQ MEM*FIRST.REUSABLE.VADR NIL) (RPAQ MEM*LAST.REUSABLE.VADR NIL))
(PROGN (RPAQQ DT*SORT.ALL (ANY)) (RPAQQ DT*SORT.NR 2) (RPAQQ DT*SORT.PROPERTIES (DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS
DT*COMPLETION.SORT)) (RPAQQ DT*SORT.COMMON.COMPUTE.FLAG NIL) (RPAQQ DT*VARIABLE.COUNTER 0) (RPAQQ DT*CONSTANT.COUNTER 0) (RPAQQ DT*CONSTANT.ALL (6 5 4)) (RPAQQ DT*ABBREVIATIONS NIL) (RPAQQ DT*FUNCTION.COUNTER 0) (RPAQQ DT*FUNCTION.ALL NIL) (RPAQQ
DT*FUNCTION.ADMISSIBLE.THEORIES (ASSOCIATIVE)) (RPAQQ DT*FUNCTION.ACTUAL.THEORIES NIL) (RPAQQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES NIL) (RPAQQ DT*FUNCTION.COMPONENTS (PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST 
SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES)) (RPAQQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES (SYMMETRIC DEFINED REFLEXIVE)) (RPAQQ DT*PREDICATE.COUNTER 0) (RPAQQ DT*EQUALITY.SYMBOLS ("=" ":=" "=:" ":=:")) (RPAQQ 
DT*EQUALITY.PREDICATES (3)) (RPAQQ DT*NONEQUALITY.PREDICATES (7 2 1)) (RPAQQ DT*PREDICATE.ALL (7 3 2 1)) (RPAQQ DT*PREDICATE.WITH.ATTRIBUTES NIL) (RPAQQ DT*PREDICATE.COMPONENTS (PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES
REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES -TOTHERSIDES)) (RPAQQ DT*TRUE.PREDICATE 1) (RPAQQ DT*FALSE.PREDICATE 2) (RPAQQ DT*UNI.CREATES.VARIABLES NIL) (RPAQQ DT*SIGN.MINUS.SYMBOLS (- --)) (RPAQQ DT*SIGN.PLUS.SYMBOLS
(+ ++)))
(PROGN)
(PROGN (SETPROPLIST (QUOTE DT*PREDICATE.WITH.ATTRIBUTES) (QUOTE (REFLEXIVE (3 3) SYMMETRIC (3 3) DEFINED (3 2 1)))))
(PROGN (SETPROPLIST (QUOTE ANY) (QUOTE (DT*INVERSE.TRANSITIVE.CLOSURE (ANY) DT*DIRECT.SUPERSORTS NIL DT*MINIMAL.SUBSORTS (ANY) DT*MAX.SUBSORTS ((ANY ANY)) DT*TRANSITIVE.CLOSURE (ANY) DT*DIRECT.SUBSORTS NIL DT*SORT.NUMBER 1))))
(PROGN (RPAQQ ST*STACK1 (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)) (RPAQQ ST*SYMBOL.ADDRESSES
(NIL (ANY . T) (TRUE . 1) (FALSE . 2) (= . 3) (B . 4) (A . 5) (C . 6) (SCHULDIG . 7) (X_8 . 8) (X_9 . 9) (X_10 . 10))))))))STOP
 
