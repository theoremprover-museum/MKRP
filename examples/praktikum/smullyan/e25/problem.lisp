;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(PREP-PROBLEM.SPECIFICATION (QUOTE ((* SMULLYAN : KAPITEL 3, RITTER UND SCHURKEN) (*) (* A. DIE INSEL DER RITTER UND SCHURKEN.) (*) (* ES GEHT UM EINE INSEL, AUF DER BESTIMMTE EINWOHNER ALS RITTER BEZEICHNET WERDEN, DIE IMMER) (* DIE WAHRHEIT SAGEN, WAEHREND DIE SOGENANNTEN SCHURKEN IMMER LUEGEN.) (* VORAUSGESETZT WIRD, DASS JEDER BEWOHNER DER INSEL ENTWEDER EIN RITTER ODER EIN SCHURKE IST.) (*) (* AUFGABE 25) (* DIESER ALTBEKANNTEN AUFGABE ZUFOLGE STANDEN EINMAL DREI DER INSELBEWOHNER) (* - A, B UND C - ZUSAMMEN IN EINEM GARTEN.) (* EIN FREMDER GING VORBEI IND FRAGTE A : BIST DU EIN RITTER ODER IN SCHURKE?) (* A ANTWORTETE, ABER SEHR UNDEUTLICH, SO DASS DER FREMDE NICHT VERSTEHEN KONNTE, WAS ER GESAGT HATTE.) (* DANN FRAGE DER FREMDE B : WAS HAT A GESAGT? B ENTGEGNETE : A HAT GESAGT, DASS ER EIN SCHURKE IST.) (* IN DEM AUGENBLICK SAGTE C, DER DRITTE MANN : DEM B DARFST DU NICHT GLAUBEN, ER LUEGT!) (*) (* DIE FRAGE IST : WAS SIND B UND C?) (*) (ALL X SCHURKE (X) EQV NOT RITTER (X)) (*) (* DAS PRAEDIKAT R2 SOLL BEDEUTEN : R2 (X Y) IS WAHR, WENN X SAGT, DASS Y EIN RITTER IST,) (* DAS PRAEDIKAT S2 SOLL BEDEUTEN : S2 (X Y) IS WAHR, WENN X SAGT, DASS Y EIN SCHURKE IST.) (*) (ALL X,Y S2 (X Y) EQV NOT R2 (X Y)) (*) (ALL X,Y RITTER (X) AND R2 (X Y) IMPL RITTER (Y)) (ALL X,Y RITTER (X) AND S2 (X Y) IMPL SCHURKE (Y)) (ALL X,Y SCHURKE (X) AND R2 (X Y) IMPL SCHURKE (Y)) (ALL X,Y SCHURKE (X) AND S2 (X Y) IMPL RITTER (Y)) (*) (* DAS PRAEDIKAT R3 SOLL BEDEUTEN : R3 (X Y Z) IS WAHR, WENN X SAGT, DASS Y SAGT, DASS Z EIN RITTER IST.) (* DAS PRAEDIKAT S3 SOLL BEDEUTEN : S3 (X Y Z) IS WAHR, WENN X SAGT, DASS Y SAGT, DASS Z EIN SCHURKE IST.) (*) (ALL X,Y,Z S3 (X Y Z) EQV NOT R3 (X Y Z)) (*) (ALL X,Y,Z RITTER (X) AND R3 (X Y Z) IMPL R2 (Y Z)) (ALL X,Y,Z RITTER (X) AND S3 (X Y Z) IMPL S2 (Y Z)) (ALL X,Y,Z SCHURKE (X) AND R3 (X Y Z) IMPL S2 (Y Z)) (ALL X,Y,Z SCHURKE (X) AND S3 (X Y Z) IMPL R2 (Y Z)) (*) (S3 (B A A)) (S2 (C B)))) (QUOTE (COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT (ALL 2 (EQV (+ 3 (2) (KIND (EQV T 200))) (NOT (+ 4 (2) (KIND (EQV NIL 200)))))) COMMENT COMMENT COMMENT COMMENT (ALL 6 (ALL 5 (EQV (+ 7 (5 6) (KIND (EQV T 250))) (NOT (+ 8 (5 6) (KIND (EQV NIL 250))))))) COMMENT (ALL 10 (ALL 9 (IMPL (AND (+ 4 (9) NIL) (+ 8 (9 10) NIL)) (+ 4 (10) NIL)))) (ALL 12 (ALL 11 (IMPL (AND (+ 4 (11) NIL) (+ 7 (11 12) NIL)) (+ 3 (12) NIL)))) (ALL 14 (ALL 13 (IMPL (AND (+ 3 (13) NIL) (+ 8 (13 14) NIL)) (+ 3 (14) NIL)))) (ALL 16 (ALL 15 (IMPL (AND (+ 3 (15) NIL) (+ 7 (15 16) NIL)) (+ 4 (16) NIL)))) COMMENT COMMENT COMMENT COMMENT (ALL 19 (ALL 18 (ALL 17 (EQV (+ 20 (17 18 19) (KIND (EQV T 350))) (NOT (+ 21 (17 18 19) (KIND (EQV NIL 350)))))))) COMMENT (ALL 24 (ALL 23 (ALL 22 (IMPL (AND (+ 4 (22) NIL) (+ 21 (22 23 24) NIL)) (+ 8 (23 24) NIL))))) (ALL 27 (ALL 26 (ALL 25 (IMPL (AND (+ 4 (25) NIL) (+ 20 (25 26 27) NIL)) (+ 7 (26 27) NIL))))) (ALL 30 (ALL 29 (ALL 28 (IMPL (AND (+ 3 (28) NIL) (+ 21 (28 29 30) NIL)) (+ 7 (29 30) NIL))))) (ALL 33 (ALL 32 (ALL 31 (IMPL (AND (+ 3 (31) NIL) (+ 20 (31 32 33) NIL)) (+ 8 (32 33) NIL))))) COMMENT (+ 20 (34 35 35) NIL) (+ 7 (36 34) NIL))) (QUOTE ((SCHURKE (B) AND RITTER (C)))) (QUOTE ((AND (+ 3 (34) NIL) (+ 4 (36) NIL)))) (QUOTE ("Edit:     Axioms and Theorems edited: 14-DEC,1989 14:02 ")) (PROGN(PROGN (DT-RESET))

(PROG ((ADDRLIST
        '(89739 89744 89749 89754 89759 89764 89769 89774 89779 89784 89789 89794 89799 89804
          89809 89824 89839 89844 89849 89854 89859 89864 89869 89874 89879 89884 89889 89894
          89909 89924 89929 89934 89949 89964 89969 89984 89999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 15 "SCHURKE" NIL NIL (ANY) NIL NIL ((- 3 (POSITIVE))) ((+ 3 (NEGATIVE)))
          ((+ 3 (NIL))) ((- 3 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "RITTER" NIL NIL
          (ANY) NIL NIL ((- 4 (POSITIVE))) ((+ 4 (NEGATIVE))) ((+ 4 (NIL))) ((- 4 (NIL))) NIL
          NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5
          ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "S2" NIL NIL (ANY ANY) NIL NIL
          ((- 7 (POSITIVE))) ((+ 7 (NEGATIVE))) ((+ 7 (NIL))) ((- 7 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 15 "R2" NIL NIL (ANY ANY) NIL NIL ((- 8 (POSITIVE)))
          ((+ 8 (NEGATIVE))) ((+ 8 (NIL))) ((- 8 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5
          ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "S3" NIL NIL (ANY ANY ANY) NIL NIL
          ((- 20 (POSITIVE))) ((+ 20 (NEGATIVE))) ((+ 20 (NIL))) ((- 20 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 15 "R3" NIL NIL (ANY ANY ANY) NIL NIL ((- 21 (POSITIVE)))
          ((+ 21 (NEGATIVE))) ((+ 21 (NIL))) ((- 21 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE
          5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY "B" (DT*ST-KIND NIL) CONSTANT 5 ANY "A" (DT*ST-KIND NIL) CONSTANT 5
          ANY "C" (DT*ST-KIND NIL) CONSTANT))
       (INCREMENT (- MEM*SIZE 90000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 90000)
             (SETQ COUNTER1 37)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (DECF COUNTER1))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((EQL 'END RADDR) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            (T (UNLESS (= MEM*SIZE 90000)
                 (MEM-INITIALIZE 90000))
               (SETQ COUNTER1 37)
               (MAPC #'(LAMBDA (RADDR) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            )
      (SETQ MEM*NEXT.RADR (IF (> MEM*SIZE 90000) (+ 89734 INCREMENT) 89734))
      (SETQ MEM*NEXT.VADR 37
            MEM*REST (- MEM*NEXT.RADR MEM*NEXT.VADR -1)
            MEM*FIRST.REUSABLE.VADR NIL
            MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL (QUOTE (ANY))) (SETQ DT*SORT.NR (QUOTE 2)) (SETQ DT*SORT.PROPERTIES (QUOTE (DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))) (SETQ DT*SORT.COMMON.COMPUTE.FLAG (QUOTE NIL)) (SETQ DT*VARIABLE.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.ALL (QUOTE (36 35 34))) (SETQ DT*ABBREVIATIONS (QUOTE NIL)) (SETQ DT*FUNCTION.COUNTER (QUOTE 0)) (SETQ DT*FUNCTION.ALL (QUOTE NIL)) (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES (QUOTE (ASSOCIATIVE))) (SETQ DT*FUNCTION.ACTUAL.THEORIES (QUOTE NIL)) (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES (QUOTE NIL)) (SETQ DT*FUNCTION.COMPONENTS (QUOTE (PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))) (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES (QUOTE (SYMMETRIC DEFINED REFLEXIVE))) (SETQ DT*PREDICATE.COUNTER (QUOTE 0)) (SETQ DT*EQUALITY.SYMBOLS (QUOTE ("=" ":=" "=:" ":=:"))) (SETQ DT*EQUALITY.PREDICATES (QUOTE NIL)) (SETQ DT*NONEQUALITY.PREDICATES (QUOTE (21 20 8 7 4 3 1 0))) (SETQ DT*PREDICATE.ALL (QUOTE (21 20 8 7 4 3 1 0))) (SETQ DT*PREDICATE.WITH.ATTRIBUTES (QUOTE NIL)) (SETQ DT*PREDICATE.COMPONENTS (QUOTE (PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES -TOTHERSIDES))) (SETQ DT*TRUE.PREDICATE (QUOTE 0)) (SETQ DT*FALSE.PREDICATE (QUOTE 1)) (SETQ DT*UNI.CREATES.VARIABLES (QUOTE NIL)) (SETQ DT*SIGN.MINUS.SYMBOLS (QUOTE (- --))) (SETQ DT*SIGN.PLUS.SYMBOLS (QUOTE (+ ++))) (SETQ DT*SYMBOL.KINDS (QUOTE (CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL)))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET (QUOTE ANY) (QUOTE DT*SORT.NUMBER)) (QUOTE 1)) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ANY))) (SETF (GET (QUOTE ANY) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ANY ANY)))) (SETF (GET (QUOTE ANY) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY))))) ))