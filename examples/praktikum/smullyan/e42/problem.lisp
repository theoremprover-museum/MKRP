;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(PREP-PROBLEM.SPECIFICATION (QUOTE ((* AXIOMS FOR PROBLEM 42 %.) (* GIVEN TWO PEOPLE A AND B.) (* EACH OF THEM IS KNIGHT, KNAVE OR NORMAL.) (* A SAYS : I AM OF LOWER RANK THAN B.) (* B SAYS : THAT IS NOT TRUE.) (*) (* CAN THE RANKS OF A OR B BE DETERMINED ?) (* CAN IT BE DETERMINED, IF ONE OF THESE STATEMENTS IS TRUE OR FALSE.) (*) (* LRANK2 (X Y) MEANS : X IS OF A LOWER RANK THAN Y.) (* LRANK3 (X Y Z) MEANS : X SAYS : Y IS OF A LOWER RANK THAN Z.) (* NLRANK3 (X Y Z) MEANS : X SAYS : Y IS NOT OF A LOWER RANK THAN Z.) (*) (ALL X KNIGHT (X) EQV NOT KNAVE (X) AND NOT NORMAL (X)) (ALL X KNAVE (X) EQV NOT KNIGHT (X) AND NOT NORMAL (X)) (ALL X NORMAL (X) EQV NOT KNIGHT (X) AND NOT KNAVE (X)) (ALL X,Y LRANK (X Y) EQV KNAVE (X) AND (NORMAL (Y) OR KNIGHT (Y)) OR NORMAL (X) AND KNIGHT (Y)) (ALL X,Y,Z LRANK3 (X Y Z) AND KNAVE (X) IMPL NOT LRANK (Y Z)) (ALL X,Y,Z LRANK3 (X Y Z) AND KNIGHT (X) IMPL LRANK (Y Z)) (ALL X,Y,Z NLRANK3 (X Y Z) AND KNAVE (X) IMPL LRANK (Y Z)) (ALL X,Y,Z NLRANK3 (X Y Z) AND KNIGHT (X) IMPL NOT LRANK (Y Z)) (LRANK3 (A A B)) (NLRANK3 (B A B)))) (QUOTE (COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT (ALL 2 (EQV (+ 3 (2) (KIND (EQV T 150))) (AND (NOT (+ 4 (2) (KIND (EQV NIL 150)))) (NOT (+ 5 (2) (KIND (EQV NIL 150))))))) (ALL 6 (EQV (+ 4 (6) (KIND (EQV T 160))) (AND (NOT (+ 3 (6) (KIND (EQV NIL 160)))) (NOT (+ 5 (6) (KIND (EQV NIL 160))))))) (ALL 7 (EQV (+ 5 (7) (KIND (EQV T 170))) (AND (NOT (+ 3 (7) (KIND (EQV NIL 170)))) (NOT (+ 4 (7) (KIND (EQV NIL 170))))))) (ALL 9 (ALL 8 (EQV (+ 10 (8 9) (KIND (EQV T 180))) (OR (AND (+ 4 (8) (KIND (EQV NIL 180))) (OR (+ 5 (9) (KIND (EQV NIL 180))) (+ 3 (9) (KIND (EQV NIL 180))))) (AND (+ 5 (8) (KIND (EQV NIL 180))) (+ 3 (9) (KIND (EQV NIL 180)))))))) (ALL 13 (ALL 12 (ALL 11 (IMPL (AND (+ 14 (11 12 13) NIL) (+ 4 (11) NIL)) (NOT (+ 10 (12 13) NIL)))))) (ALL 17 (ALL 16 (ALL 15 (IMPL (AND (+ 14 (15 16 17) NIL) (+ 3 (15) NIL)) (+ 10 (16 17) NIL))))) (ALL 20 (ALL 19 (ALL 18 (IMPL (AND (+ 21 (18 19 20) NIL) (+ 4 (18) NIL)) (+ 10 (19 20) NIL))))) (ALL 24 (ALL 23 (ALL 22 (IMPL (AND (+ 21 (22 23 24) NIL) (+ 3 (22) NIL)) (NOT (+ 10 (23 24) NIL)))))) (+ 14 (25 25 26) NIL) (+ 21 (26 25 26) NIL))) (QUOTE ((NOT LRANK (A B)))) (QUOTE ((NOT (+ 10 (25 26) NIL)))) (QUOTE ("Edit:     Axioms and Theorems edited: 15-DEC,1989 14:35 ")) (PROGN(PROGN (DT-RESET))

(PROG ((ADDRLIST
        '(9789 9794 9799 9804 9809 9824 9829 9834 9839 9844 9849 9854 9869 9874 9879 9884 9899
          9904 9909 9914 9919 9934 9949 9964 9969 9984 9999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 15 "KNIGHT" NIL NIL (ANY) NIL NIL ((- 3 (POSITIVE))) ((+ 3 (NEGATIVE)))
          ((+ 3 (NIL))) ((- 3 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "KNAVE" NIL NIL
          (ANY) NIL NIL ((- 4 (POSITIVE))) ((+ 4 (NEGATIVE))) ((+ 4 (NIL))) ((- 4 (NIL))) NIL
          NIL (DT*ST-KIND NIL) PREDICATE 15 "NORMAL" NIL NIL (ANY) NIL NIL ((- 5 (POSITIVE)))
          ((+ 5 (NEGATIVE))) ((+ 5 (NIL))) ((- 5 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5
          ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "LRANK" NIL NIL
          (ANY ANY) NIL NIL ((- 10 (POSITIVE))) ((+ 10 (NEGATIVE))) ((+ 10 (NIL)))
          ((- 10 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "LRANK3" NIL NIL
          (ANY ANY ANY) NIL NIL ((- 14 (POSITIVE))) ((+ 14 (NEGATIVE))) ((+ 14 (NIL)))
          ((- 14 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "NLRANK3" NIL NIL
          (ANY ANY ANY) NIL NIL ((- 21 (POSITIVE))) ((+ 21 (NEGATIVE))) ((+ 21 (NIL)))
          ((- 21 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5 ANY NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 ANY NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ANY "A"
          (DT*ST-KIND NIL) CONSTANT 5 ANY "B" (DT*ST-KIND NIL) CONSTANT))
       (INCREMENT (- MEM*SIZE 10000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 10000)
             (SETQ COUNTER1 27)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (DECF COUNTER1))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((EQL 'END RADDR) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            (T (UNLESS (= MEM*SIZE 10000)
                 (MEM-INITIALIZE 10000))
               (SETQ COUNTER1 27)
               (MAPC #'(LAMBDA (RADDR) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            )
      (SETQ MEM*NEXT.RADR (IF (> MEM*SIZE 10000) (+ 9784 INCREMENT) 9784))
      (SETQ MEM*NEXT.VADR 27
            MEM*REST (- MEM*NEXT.RADR MEM*NEXT.VADR -1)
            MEM*FIRST.REUSABLE.VADR NIL
            MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL (QUOTE (ANY))) (SETQ DT*SORT.NR (QUOTE 2)) (SETQ DT*SORT.PROPERTIES (QUOTE (DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))) (SETQ DT*SORT.COMMON.COMPUTE.FLAG (QUOTE NIL)) (SETQ DT*VARIABLE.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.ALL (QUOTE (26 25))) (SETQ DT*ABBREVIATIONS (QUOTE NIL)) (SETQ DT*FUNCTION.COUNTER (QUOTE 0)) (SETQ DT*FUNCTION.ALL (QUOTE NIL)) (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES (QUOTE (ASSOCIATIVE))) (SETQ DT*FUNCTION.ACTUAL.THEORIES (QUOTE NIL)) (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES (QUOTE NIL)) (SETQ DT*FUNCTION.COMPONENTS (QUOTE (PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))) (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES (QUOTE (SYMMETRIC DEFINED REFLEXIVE))) (SETQ DT*PREDICATE.COUNTER (QUOTE 0)) (SETQ DT*EQUALITY.SYMBOLS (QUOTE ("=" ":=" "=:" ":=:"))) (SETQ DT*EQUALITY.PREDICATES (QUOTE NIL)) (SETQ DT*NONEQUALITY.PREDICATES (QUOTE (21 14 10 5 4 3 1 0))) (SETQ DT*PREDICATE.ALL (QUOTE (21 14 10 5 4 3 1 0))) (SETQ DT*PREDICATE.WITH.ATTRIBUTES (QUOTE NIL)) (SETQ DT*PREDICATE.COMPONENTS (QUOTE (PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES -TOTHERSIDES))) (SETQ DT*TRUE.PREDICATE (QUOTE 0)) (SETQ DT*FALSE.PREDICATE (QUOTE 1)) (SETQ DT*UNI.CREATES.VARIABLES (QUOTE NIL)) (SETQ DT*SIGN.MINUS.SYMBOLS (QUOTE (- --))) (SETQ DT*SIGN.PLUS.SYMBOLS (QUOTE (+ ++))) (SETQ DT*SYMBOL.KINDS (QUOTE (CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL)))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET (QUOTE ANY) (QUOTE DT*SORT.NUMBER)) (QUOTE 1)) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ANY))) (SETF (GET (QUOTE ANY) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((ANY ANY)))) (SETF (GET (QUOTE ANY) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY))))) ))