;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(PREP-PROBLEM.SPECIFICATION (QUOTE ((* 68B. SECOND TEST.) (* IF THE SUITOR PASSED THE FIRST TEST, HE WAS TAKEN INTO ANOTHER) (* ROOM IN WHICH THERE WERE THREE MORE CASKETS. AGAIN EACH CASKET) (* HAD TWO SENTENCES INSCRIBED ON THE LID. PORTIA EXPLAINED THAT) (* ON ONE OF THE LIDS, BOTH STATEMENTS WERE TRUE COMMENT COMMENT) (* (2) IT IS IN THE SILVER CASKET) (* SILVER : (1) THE PORTRAIT IS NOT IN THE GOLD CASKET) (* (2) IT IS IN THE LEAD CASKET) (* LEAD : (1) THE PORTRAIT IS NOT IN THIS CASKET) (* (2) IT IS IN THE GOLD CASKET) (*) (*) (* WE DEFINE THE FOLLOWING FUNCTIONS :) (* FIRST (X) SECOND (X) , WHICH MAP AN ELEMENT OF THE SORT CASKET) (* TO AN ELEMENT OF THE SORT INSCRIPT.) (*) (*) (* WE DEFINE THE FOLLOWING PREDICATES :) (*) (* THE PREDICATES PORTRAIT, TRUTH, NEGATIVE.INSCRIPTION AND) (* INSCRIPTION MEAN THE SAME AS IN 66, 67 AND 68A.) (* BOTH.TRUE (X Y) - BOTH INSCRIPTIONS, X AND Y, ARE TRUE) (* BOTH.FALSE (X Y) - BOTH INSCRIPTIONS, X AND Y, ARE FALSE) (* TRUE.FALSE (X Y) - ONE OF THE INSCRIPTIONS, X AND Y, IS TRUE) (* AND ONE OF THEM IS FALSE) (*) (*) (* DECLARATIONS :) (*) (TYPE GOLD,SILVER,LEAD : CASKET) (TYPE FIRST (CASKET) : INSCRIPT) (TYPE SECOND (CASKET) : INSCRIPT) (*) (*) (* FORMULAS :) (*) (* THE PORTRAIT IS IN EXACTLY ONE CASKET) (PORTRAIT (GOLD) OR PORTRAIT (SILVER) OR PORTRAIT (LEAD)) (NOT (PORTRAIT (GOLD) AND PORTRAIT (SILVER) OR PORTRAIT (SILVER) AND PORTRAIT (LEAD) OR PORTRAIT (LEAD) AND PORTRAIT (GOLD))) (*) (* IMPLICATIONS TO BE DRAWN FROM INSCRIPTIONS :) (ALL X : INSCRIPT ALL Y : CASKET INSCRIPTION (X Y) AND TRUTH (X) IMPL PORTRAIT (Y)) (ALL X : INSCRIPT ALL Y : CASKET INSCRIPTION (X Y) AND NOT TRUTH (X) IMPL NOT PORTRAIT (Y)) (ALL X : INSCRIPT ALL Y : CASKET NEGATIVE.INSCRIPTION (X Y) AND TRUTH (X) IMPL NOT PORTRAIT (Y)) (ALL X : INSCRIPT ALL Y : CASKET NEGATIVE.INSCRIPTION (X Y) AND NOT TRUTH (X) IMPL PORTRAIT (Y)) (*) (* INFORMATION ABOUT TRUTH OF INSCRIPTIONS :) (BOTH.TRUE (FIRST (GOLD) SECOND (GOLD)) OR BOTH.TRUE (FIRST (SILVER) SECOND (SILVER)) OR BOTH.TRUE (FIRST (LEAD) SECOND (LEAD))) (BOTH.FALSE (FIRST (GOLD) SECOND (GOLD)) OR BOTH.FALSE (FIRST (SILVER) SECOND (SILVER)) OR BOTH.FALSE (FIRST (LEAD) SECOND (LEAD))) (TRUE.FALSE (FIRST (GOLD) SECOND (GOLD)) OR TRUE.FALSE (FIRST (SILVER) SECOND (SILVER)) OR TRUE.FALSE (FIRST (LEAD) SECOND (LEAD))) (ALL X,Y : INSCRIPT BOTH.TRUE (X Y) EQV TRUTH (X) AND TRUTH (Y)) (ALL X,Y : INSCRIPT BOTH.FALSE (X Y) EQV NOT TRUTH (X) AND NOT TRUTH (Y)) (ALL X,Y : INSCRIPT TRUE.FALSE (X Y) EQV NOT BOTH.TRUE (X Y) AND NOT BOTH.FALSE (X Y)) (*) (* ACTUAL INSCRIPTIONS :) (NEGATIVE.INSCRIPTION (FIRST (GOLD) GOLD)) (INSCRIPTION (SECOND (GOLD) SILVER)) (NEGATIVE.INSCRIPTION (FIRST (SILVER) GOLD)) (INSCRIPTION (SECOND (SILVER) LEAD)) (NEGATIVE.INSCRIPTION (FIRST (LEAD) LEAD)) (INSCRIPTION (SECOND (LEAD) GOLD)))) (QUOTE (COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT COMMENT (+ 0 NIL) (+ 0 NIL) (+ 0 NIL) COMMENT COMMENT COMMENT COMMENT COMMENT (OR (+ 15 (21) NIL) (OR (+ 15 (20) NIL) (+ 15 (18) NIL))) (NOT (OR (AND (+ 15 (21) NIL) (+ 15 (20) NIL)) (OR (AND (+ 15 (20) NIL) (+ 15 (18) NIL)) (AND (+ 15 (18) NIL) (+ 15 (21) NIL))))) COMMENT COMMENT (ALL 12 (ALL 11 (IMPL (AND (+ 23 (12 11) NIL) (+ 24 (12) NIL)) (+ 15 (11) NIL)))) (ALL 25 (ALL 26 (IMPL (AND (+ 23 (25 26) NIL) (NOT (+ 24 (25) NIL))) (NOT (+ 15 (26) NIL))))) (ALL 27 (ALL 28 (IMPL (AND (+ 29 (27 28) NIL) (+ 24 (27) NIL)) (NOT (+ 15 (28) NIL))))) (ALL 30 (ALL 31 (IMPL (AND (+ 29 (30 31) NIL) (NOT (+ 24 (30) NIL))) (+ 15 (31) NIL)))) COMMENT COMMENT (OR (+ 32 ((17 21) (16 21)) NIL) (OR (+ 32 ((17 20) (16 20)) NIL) (+ 32 ((17 18) (16 18)) NIL))) (OR (+ 33 ((17 21) (16 21)) NIL) (OR (+ 33 ((17 20) (16 20)) NIL) (+ 33 ((17 18) (16 18)) NIL))) (OR (+ 34 ((17 21) (16 21)) NIL) (OR (+ 34 ((17 20) (16 20)) NIL) (+ 34 ((17 18) (16 18)) NIL))) (ALL 36 (ALL 35 (EQV (+ 32 (35 36) (KIND (EQV T 520))) (AND (+ 24 (35) (KIND (EQV NIL 520))) (+ 24 (36) (KIND (EQV NIL 520))))))) (ALL 38 (ALL 37 (EQV (+ 33 (37 38) (KIND (EQV T 530))) (AND (NOT (+ 24 (37) (KIND (EQV NIL 530)))) (NOT (+ 24 (38) (KIND (EQV NIL 530)))))))) (ALL 40 (ALL 39 (EQV (+ 34 (39 40) (KIND (EQV T 540))) (AND (NOT (+ 32 (39 40) (KIND (EQV NIL 540)))) (NOT (+ 33 (39 40) (KIND (EQV NIL 540)))))))) COMMENT COMMENT (+ 29 ((17 21) 21) NIL) (+ 23 ((16 21) 20) NIL) (+ 29 ((17 20) 21) NIL) (+ 23 ((16 20) 18) NIL) (+ 29 ((17 18) 18) NIL) (+ 23 ((16 18) 21) NIL))) (QUOTE ((PORTRAIT (LEAD)))) (QUOTE ((+ 15 (18) NIL))) (QUOTE ("Edit:     Axioms and Theorems edited: 15-DEC,1989 15:18 ")) (PROGN(PROGN (DT-RESET))

(PROG ((ADDRLIST
        '(9756 9761 9766 9771 9776 9781 9796 9811 9826 9831 9836 9851 9856 9861 9866 9871 9886
          9901 ATP.MEMORY.NIL 9969 9964 ATP.MEMORY.NIL 9959 9954 9940 9926 ATP.MEMORY.NIL
          ATP.MEMORY.NIL 9911 9906 ATP.MEMORY.NIL ATP.MEMORY.NIL ATP.MEMORY.NIL ATP.MEMORY.NIL
          ATP.MEMORY.NIL ATP.MEMORY.NIL ATP.MEMORY.NIL ATP.MEMORY.NIL ATP.MEMORY.NIL 9984
          9999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 5 CASKET "GOLD" (DT*ST-KIND NIL) CONSTANT 5
          CASKET "SILVER" (DT*ST-KIND NIL) CONSTANT 5 CASKET "LEAD" (DT*ST-KIND NIL) CONSTANT
          14 "FIRST" NIL INSCRIPT (CASKET) NIL NIL NIL NIL NIL 1 INSCRIPT (DT*ST-KIND NIL)
          FUNCTION 14 "SECOND" NIL INSCRIPT (CASKET) NIL NIL NIL NIL NIL 1 INSCRIPT
          (DT*ST-KIND NIL) FUNCTION 15 "PORTRAIT" NIL NIL (ANY) NIL NIL ((- 15 (POSITIVE)))
          ((+ 15 (NEGATIVE))) ((+ 15 (NIL))) ((- 15 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE
          5 INSCRIPT NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 CASKET NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "INSCRIPTION" NIL NIL (ANY ANY) NIL NIL
          ((- 23 (POSITIVE))) ((+ 23 (NEGATIVE))) ((+ 23 (NIL))) ((- 23 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 15 "TRUTH" NIL NIL (ANY) NIL NIL ((- 24 (POSITIVE)))
          ((+ 24 (NEGATIVE))) ((+ 24 (NIL))) ((- 24 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE
          5 INSCRIPT NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 CASKET NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 INSCRIPT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 CASKET NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "NEGATIVE.INSCRIPTION" NIL NIL (ANY ANY)
          NIL NIL ((- 29 (POSITIVE))) ((+ 29 (NEGATIVE))) ((+ 29 (NIL))) ((- 29 (NIL))) NIL
          NIL (DT*ST-KIND NIL) PREDICATE 5 INSCRIPT NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 CASKET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 15 "BOTH.TRUE" NIL
          NIL (ANY ANY) NIL NIL ((- 32 (POSITIVE))) ((+ 32 (NEGATIVE))) ((+ 32 (NIL)))
          ((- 32 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "BOTH.FALSE" NIL NIL (ANY ANY)
          NIL NIL ((- 33 (POSITIVE))) ((+ 33 (NEGATIVE))) ((+ 33 (NIL))) ((- 33 (NIL))) NIL
          NIL (DT*ST-KIND NIL) PREDICATE 15 "TRUE.FALSE" NIL NIL (ANY ANY) NIL NIL
          ((- 34 (POSITIVE))) ((+ 34 (NEGATIVE))) ((+ 34 (NIL))) ((- 34 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 5 INSCRIPT NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE
          5 INSCRIPT NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 INSCRIPT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 INSCRIPT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 INSCRIPT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 INSCRIPT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE))
       (INCREMENT (- MEM*SIZE 10000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 10000)
             (SETQ COUNTER1 41)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (DECF COUNTER1))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((EQL 'END RADDR) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            (T (UNLESS (= MEM*SIZE 10000)
                 (MEM-INITIALIZE 10000))
               (SETQ COUNTER1 41)
               (MAPC #'(LAMBDA (RADDR) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA) (SETF (AREF MEM*MEMORY (DECF COUNTER1)) DATA)) DATALIST))
            )
      (SETQ MEM*NEXT.RADR (IF (> MEM*SIZE 10000) (+ 9751 INCREMENT) 9751))
      (SETQ MEM*NEXT.VADR 41
            MEM*REST (- MEM*NEXT.RADR MEM*NEXT.VADR -1)
            MEM*FIRST.REUSABLE.VADR NIL
            MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL (QUOTE (INSCRIPT CASKET ANY))) (SETQ DT*SORT.NR (QUOTE 6)) (SETQ DT*SORT.PROPERTIES (QUOTE (DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))) (SETQ DT*SORT.COMMON.COMPUTE.FLAG (QUOTE NIL)) (SETQ DT*VARIABLE.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.COUNTER (QUOTE 0)) (SETQ DT*CONSTANT.ALL (QUOTE (18 20 21))) (SETQ DT*ABBREVIATIONS (QUOTE NIL)) (SETQ DT*FUNCTION.COUNTER (QUOTE 0)) (SETQ DT*FUNCTION.ALL (QUOTE (16 17))) (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES (QUOTE (ASSOCIATIVE))) (SETQ DT*FUNCTION.ACTUAL.THEORIES (QUOTE NIL)) (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES (QUOTE NIL)) (SETQ DT*FUNCTION.COMPONENTS (QUOTE (PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))) (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES (QUOTE (SYMMETRIC DEFINED REFLEXIVE))) (SETQ DT*PREDICATE.COUNTER (QUOTE 0)) (SETQ DT*EQUALITY.SYMBOLS (QUOTE ("=" ":=" "=:" ":=:"))) (SETQ DT*EQUALITY.PREDICATES (QUOTE NIL)) (SETQ DT*NONEQUALITY.PREDICATES (QUOTE (34 33 32 29 24 23 15 1 0))) (SETQ DT*PREDICATE.ALL (QUOTE (34 33 32 29 24 23 15 1 0))) (SETQ DT*PREDICATE.WITH.ATTRIBUTES (QUOTE NIL)) (SETQ DT*PREDICATE.COMPONENTS (QUOTE (PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES -TOTHERSIDES))) (SETQ DT*TRUE.PREDICATE (QUOTE 0)) (SETQ DT*FALSE.PREDICATE (QUOTE 1)) (SETQ DT*UNI.CREATES.VARIABLES (QUOTE NIL)) (SETQ DT*SIGN.MINUS.SYMBOLS (QUOTE (- --))) (SETQ DT*SIGN.PLUS.SYMBOLS (QUOTE (+ ++))) (SETQ DT*SYMBOL.KINDS (QUOTE (CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL)))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*SORT.NUMBER)) (QUOTE 5)) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (INSCRIPT))) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((INSCRIPT INSCRIPT) (CASKET) (ANY INSCRIPT)))) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (INSCRIPT))) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE INSCRIPT) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY INSCRIPT)))) (PROGN (SETF (GET (QUOTE CASKET) (QUOTE DT*SORT.NUMBER)) (QUOTE 4)) (SETF (GET (QUOTE CASKET) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE CASKET) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (CASKET))) (SETF (GET (QUOTE CASKET) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((INSCRIPT) (CASKET CASKET) (ANY CASKET)))) (SETF (GET (QUOTE CASKET) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (CASKET))) (SETF (GET (QUOTE CASKET) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE (ANY))) (SETF (GET (QUOTE CASKET) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY CASKET)))) (PROGN (SETF (GET (QUOTE ANY) (QUOTE DT*SORT.NUMBER)) (QUOTE 1)) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUBSORTS)) (QUOTE (INSCRIPT CASKET))) (SETF (GET (QUOTE ANY) (QUOTE DT*TRANSITIVE.CLOSURE)) (QUOTE (ANY INSCRIPT CASKET))) (SETF (GET (QUOTE ANY) (QUOTE DT*MAX.SUBSORTS)) (QUOTE ((INSCRIPT INSCRIPT) (CASKET CASKET) (ANY ANY)))) (SETF (GET (QUOTE ANY) (QUOTE DT*MINIMAL.SUBSORTS)) (QUOTE (CASKET))) (SETF (GET (QUOTE ANY) (QUOTE DT*DIRECT.SUPERSORTS)) (QUOTE NIL)) (SETF (GET (QUOTE ANY) (QUOTE DT*INVERSE.TRANSITIVE.CLOSURE)) (QUOTE (ANY))) (SETF (GET (QUOTE ANY) (QUOTE DT*LEAST.SUPERSORTS)) (QUOTE ((ANY ANY)))))) ))