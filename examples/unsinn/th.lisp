;;; -*- Package: MKRP; Base: 10; Mode: LISP; Syntax: Common-lisp -*-
(COND ((FMT-LOAD "13-NOV-1987 21:44"
  NIL
  (((ALL A,B:SET SETEQUAL (INTERSECTION (A B) INTERSECTION (B A)))
  (ALL 11 (ALL 12 (+ 4 ((2 12 11) (2 11 12)) NIL))) QUANTIFICATION)))(COND (ST*LOAD.FLAG (PROGN (DT-RESET))

(PROG ((ADDRLIST
        '(19895 19890 19900 19905 19910 19915 19920 19925 19940 19955 19969 19984 19999))
       (DATALIST
        '(15 "TRUE" NIL NIL NIL (DEFINED) NIL ((- 0 (POSITIVE))) ((+ 0 (NEGATIVE)))
          ((+ 0 (NIL))) ((- 0 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 15 "FALSE" NIL NIL
          NIL (DEFINED) NIL ((- 1 (POSITIVE))) ((+ 1 (NEGATIVE))) ((+ 1 (NIL))) ((- 1 (NIL)))
          NIL NIL (DT*ST-KIND NIL) PREDICATE 14 "INTERSECTION" NIL SET (SET SET) NIL NIL NIL
          NIL NIL 2 SET (DT*ST-KIND NIL) FUNCTION 15 "MEMBER" NIL NIL (ELEMENT SET) NIL NIL
          ((- 3 (POSITIVE))) ((+ 3 (NEGATIVE))) ((+ 3 (NIL))) ((- 3 (NIL))) NIL NIL
          (DT*ST-KIND NIL) PREDICATE 15 "SETEQUAL" NIL NIL (SET SET) NIL NIL ((- 4 (POSITIVE)))
          ((+ 4 (NEGATIVE))) ((+ 4 (NIL))) ((- 4 (NIL))) NIL NIL (DT*ST-KIND NIL) PREDICATE 5
          SET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 SET NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ELEMENT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 SET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 SET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 ELEMENT NIL
          (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE 5 SET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR)
          VARIABLE 5 SET NIL (ST*DATA NIL DT*ST-KIND SYS-VAR) VARIABLE))
       (INCREMENT (- MEM*SIZE 20000))
       COUNTER1)
      (MEM-RESET)
      (COND ((> MEM*SIZE 20000)
             (SETQ COUNTER1 13)
             (MAPC #'(LAMBDA (RADDR)
                       (SETF (AREF MEM*MEMORY (SETQ COUNTER1 (1- COUNTER1)))
                              (COND ((EQL RADDR 'ATP.MEMORY.NIL) RADDR)
                                    ((OR (EQL RADDR 0)
                                         (MINUSP RADDR))
                                     RADDR)
                                    (T (+ RADDR INCREMENT)))))
                   ADDRLIST)
             (SETQ COUNTER1 MEM*SIZE)
             (MAPC #'(LAMBDA (DATA)
                       (SETF (AREF MEM*MEMORY (SETQ COUNTER1 (1- COUNTER1))) DATA))
                   DATALIST))
            (T (UNLESS (= MEM*SIZE 20000)
                 (MEM-INITIALIZE 20000))
               (SETQ COUNTER1 13)
               (MAPC #'(LAMBDA (RADDR)
                         (SETF (AREF MEM*MEMORY (SETQ COUNTER1 (1- COUNTER1))) RADDR))
                     ADDRLIST)
               (SETQ COUNTER1 MEM*SIZE)
               (MAPC #'(LAMBDA (DATA)
                         (SETF (AREF MEM*MEMORY (SETQ COUNTER1 (1- COUNTER1))) DATA))
                     DATALIST)))
      (COND ((> MEM*SIZE 20000) (SETQ MEM*NEXT.RADR (+ 19885 INCREMENT)))
            (T (SETQ MEM*NEXT.RADR 19885)))
      (SETQ MEM*NEXT.VADR 13)
      (SETQ MEM*REST (1+ (- MEM*NEXT.RADR MEM*NEXT.VADR)))
      (SETQ MEM*FIRST.REUSABLE.VADR NIL)
      (SETQ MEM*LAST.REUSABLE.VADR NIL))

(PROGN (SETQ DT*SORT.ALL '(ELEMENT SET ANY))
       (SETQ DT*SORT.NR '4)
       (SETQ DT*SORT.PROPERTIES
              '(DT*MAX.SUBSORTS DT*LEAST.SUPERSORTS DT*TRANSITIVE.CLOSURE
                DT*INVERSE.TRANSITIVE.CLOSURE DT*MINIMAL.SUBSORTS DT*DIRECT.SUBSORTS
                DT*DIRECT.SUPERSORTS DT*DISJOINT.SORTS DT*COMPLETION.SORT))
       (SETQ DT*SORT.COMMON.COMPUTE.FLAG 'NIL)
       (SETQ DT*VARIABLE.COUNTER '0)
       (SETQ DT*CONSTANT.COUNTER '0)
       (SETQ DT*CONSTANT.ALL 'NIL)
       (SETQ DT*ABBREVIATIONS 'NIL)
       (SETQ DT*FUNCTION.COUNTER '0)
       (SETQ DT*FUNCTION.ALL '(2))
       (SETQ DT*FUNCTION.ADMISSIBLE.THEORIES '(ASSOCIATIVE))
       (SETQ DT*FUNCTION.ACTUAL.THEORIES 'NIL)
       (SETQ DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES 'NIL)
       (SETQ DT*FUNCTION.COMPONENTS
              '(PNAME ATTRIBUTES MAX.RANGE.SORT MAX.DOMAIN.SORTS MIN.RANGE.SORTS SORT.LIST
                SORT.LIST.INVERSE SORT.TREE.CALC ARGUMENT.SYMMETRIES ARITY G.L.B.OF.RANGES))
       (SETQ DT*PREDICATE.ADMISSABLE.ATTRIBUTES '(SYMMETRIC DEFINED REFLEXIVE))
       (SETQ DT*PREDICATE.COUNTER '0)
       (SETQ DT*EQUALITY.SYMBOLS '("=" ":=" "=:" ":=:"))
       (SETQ DT*EQUALITY.PREDICATES 'NIL)
       (SETQ DT*NONEQUALITY.PREDICATES '(4 3 1 0))
       (SETQ DT*PREDICATE.ALL '(4 3 1 0))
       (SETQ DT*PREDICATE.WITH.ATTRIBUTES 'NIL)
       (SETQ DT*PREDICATE.COMPONENTS
              '(PNAME POSITIVE.OCCURRENCES NEGATIVE.OCCURRENCES DOMAINSORTS ATTRIBUTES
                REFL.CLAUSE +ROTHERSIDES -ROTHERSIDES +SOTHERSIDES -SOTHERSIDES +TOTHERSIDES
                -TOTHERSIDES))
       (SETQ DT*TRUE.PREDICATE '0)
       (SETQ DT*FALSE.PREDICATE '1)
       (SETQ DT*UNI.CREATES.VARIABLES 'NIL)
       (SETQ DT*SIGN.MINUS.SYMBOLS '(- --))
       (SETQ DT*SIGN.PLUS.SYMBOLS '(+ ++))
       (SETQ DT*SYMBOL.KINDS '(CONSTANT.ALL FUNCTION.ALL PREDICATE.ALL))) 
(PROGN) 
(PROGN (PROGN)) 
(PROGN (PROGN (SETF (GET 'ELEMENT 'DT*SORT.NUMBER) '3)
              (SETF (GET 'ELEMENT 'DT*DIRECT.SUBSORTS) 'NIL)
              (SETF (GET 'ELEMENT 'DT*TRANSITIVE.CLOSURE) '(ELEMENT))
              (SETF (GET 'ELEMENT 'DT*MAX.SUBSORTS) '((ELEMENT ELEMENT) (SET) (ANY ELEMENT)))
              (SETF (GET 'ELEMENT 'DT*MINIMAL.SUBSORTS) '(ELEMENT))
              (SETF (GET 'ELEMENT 'DT*DIRECT.SUPERSORTS) '(ANY))
              (SETF (GET 'ELEMENT 'DT*INVERSE.TRANSITIVE.CLOSURE) '(ANY ELEMENT)))
       (PROGN (SETF (GET 'SET 'DT*SORT.NUMBER) '2)
              (SETF (GET 'SET 'DT*DIRECT.SUBSORTS) 'NIL)
              (SETF (GET 'SET 'DT*TRANSITIVE.CLOSURE) '(SET))
              (SETF (GET 'SET 'DT*MAX.SUBSORTS) '((ELEMENT) (SET SET) (ANY SET)))
              (SETF (GET 'SET 'DT*MINIMAL.SUBSORTS) '(SET))
              (SETF (GET 'SET 'DT*DIRECT.SUPERSORTS) '(ANY))
              (SETF (GET 'SET 'DT*INVERSE.TRANSITIVE.CLOSURE) '(ANY SET)))
       (PROGN (SETF (GET 'ANY 'DT*SORT.NUMBER) '1)
              (SETF (GET 'ANY 'DT*DIRECT.SUBSORTS) '(ELEMENT SET))
              (SETF (GET 'ANY 'DT*TRANSITIVE.CLOSURE) '(ANY ELEMENT SET))
              (SETF (GET 'ANY 'DT*MAX.SUBSORTS) '((ELEMENT ELEMENT) (SET SET) (ANY ANY)))
              (SETF (GET 'ANY 'DT*MINIMAL.SUBSORTS) '(SET))
              (SETF (GET 'ANY 'DT*DIRECT.SUPERSORTS) 'NIL)
              (SETF (GET 'ANY 'DT*INVERSE.TRANSITIVE.CLOSURE) '(ANY)))) (PROGN (SETQ ST*STACK1 ST*STACK1)
       (SETQ ST*SYMBOL.ADDRESSES
              '(NIL (ANY . T) (TRUE . 0) (FALSE . 1) (SET . T) (ELEMENT . T) (INTERSECTION . 2)
                (MEMBER . 3) (SETEQUAL . 4) (X_5 . 5) (X_6 . 6) (X_7 . 7) (X_8 . 8) (X_9 . 9)
                (X_10 . 10) (X_12 . 12) (X_11 . 11))))))))