;;; Dribble file "compilerlisting.text" started
1 Enter MKRP=MAKE.PATH.OUT.COMP #P"prog/serv/service"
1 Exit MKRP=MAKE.PATH.OUT.COMP #P"service.sbin"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
;;; You are using the compiler in development mode (compilation-speed = 3)
;;; If you want faster code at the expense of longer compile time,
;;; you should use the production mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 0)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Generation of inline code is disabled (speed = 0)
;;; Reading source file "prog/serv/service.lisp"
;;; Writing binary file "prog/serv/service.sbin"
1 Enter MKRP=MAKE.PATH.OUT.COMP #P"prog/serv/service"
1 Exit MKRP=MAKE.PATH.OUT.COMP #P"service.sbin"
>>Error: Cannot find source or binary file matching "service.sbin"

LOAD:
   Required arg 0 (FILENAME-OR-STREAM): #P"service.sbin"
   Keyword arg 1 (VERBOSE): T
   Keyword arg 2 (PRINT): NIL
   Keyword arg 3 (IF-SOURCE-NEWER): :QUERY
   Keyword arg 4 (IF-SOURCE-ONLY): :LOAD-SOURCE
   Keyword arg 5 (IGNORE-BINARY-DEPENDENCIES): NIL
   Keyword arg 6 (IF-DOES-NOT-EXIST): :ERROR
:C  0: Try a new filename
    1: Try loading #P"service.sbin" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> (/ 6240 38.5)
162.07792207792207
-> (* 40  (/ 6240 38.5))
6483.1168831168825
-> (* 32 (/ 6240 38.5))
5186.493506493506
-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :directory (cons :relative (pathname-directory f)) :defaults f)
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
;;; Warning: Redefining MKRP=MAKE.PATH.OUT.COMP, keeping advice TRACE
MKRP=MAKE.PATH.OUT.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level
;;; Warning: Redefining MKRP=MAKE.PATH.OUT.COMP, keeping advice TRACE
;;; You are using the compiler in production mode (compilation-speed = 0)
;;; If you want shorter compile time at the expense of reduced optimization,
;;; you should use the development mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 3)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Optimization of tail calls is enabled (speed = 3)



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): y
;;; Dribble file "compilerlisting.text" started
1 Enter MKRP=MAKE.PATH.OUT.COMP #P"prog/serv/service"
1 Exit MKRP=MAKE.PATH.OUT.COMP #P
>>Error: The value of STR, :RELATIVE, should be a SIMPLE-STRING

DIRECTORY-NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>
:C  0: Use a new value
    1: Try loading "sys/boot" again
:A  2: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :type "sbin" :defaults
					 (make-pathname :directory '(:relative) :defaults f))
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
;;; Warning: Redefining MKRP=MAKE.PATH.OUT.COMP, keeping advice TRACE
MKRP=MAKE.PATH.OUT.COMP
-> 1
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level
;;; Warning: Redefining MKRP=MAKE.PATH.OUT.COMP, keeping advice TRACE



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): y
;;; Dribble file "compilerlisting.text" started
1 Enter MKRP=MAKE.PATH.OUT.COMP #P"prog/serv/service"
1 Exit MKRP=MAKE.PATH.OUT.COMP #P
>>Error: The value of STR, :RELATIVE, should be a SIMPLE-STRING

DIRECTORY-NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>
:C  0: Use a new value
    1: Try loading "sys/boot" again
:A  2: Abort to Lisp Top Level

-> :b
DIRECTORY-NAMESTRING <- NAMESTRING <- PRIN1 <- FORMAT <- (:ADVICE MKRP=MAKE.PATH.OUT.COMP :TRACE) <- MKRP=BOOT=LOAD-AND-COMPILE <- LAMBDA <- MAPC <- MKRP=BOOT=COMPILE-ALL-NEW <- MKRP=BOOT=RUN-BOOT <- MKRP-BOOT <- EVAL <- (:INTERNAL LOAD LUCID::LOAD-FROM-STREAM) <- (:INTERNAL LOAD LUCID::LOAD-SOURCE-FILE) <- LOAD <- EVAL <- SYSTEM:ENTER-TOP-LEVEL
-> :n
NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>

-> :n
PRIN1:
   Required arg 0 (OBJECT): #P
#<FORMAT ERROR>
   Optional arg 1 (STREAM): #<Stream SYNONYM-STREAM 29C015E>
-> :n
FORMAT:
   Required arg 0 (DESTINATION): #<Stream SYNONYM-STREAM 29C015E>
   Required arg 1 (CONTROL-STRING): "~D ~A ~S~{ ~S~}"
   Rest arg 2 (ARGUMENTS): (1 "Exit" MKRP=MAKE.PATH.OUT.COMP (#P
#<FORMAT ERROR>

-> :n
(:ADVICE MKRP=MAKE.PATH.OUT.COMP :TRACE):
   Rest arg 0 (G301696): (#P"prog/serv/service")
-> :n
MKRP=BOOT=LOAD-AND-COMPILE:
Original code: (LUCID-COMMON-LISP:NAMED-LAMBDA MKRP=BOOT=LOAD-AND-COMPILE (F) (BLOCK MKRP=BOOT=LOAD-AND-COMPILE (LET # # #)))
   Required arg 0 (F): #P"prog/serv/service"
-> (untrace)
(MKRP=MAKE.PATH.OUT.COMP)
-> 1
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
>>Error: The value of STR, :RELATIVE, should be a SIMPLE-STRING

DIRECTORY-NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>
:C  0: Use a new value
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> :n
NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>

-> :n
LUCID:%FILE-EXISTS-P:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>

-> :n
COMPILE-FILE:
   Required arg 0 (INPUT-PATHNAME): #P"prog/serv/service.lisp"
   Rest arg 1 (KEYS): (:OUTPUT-FILE #P
#<FORMAT ERROR>
   Keyword arg 2 (OUTPUT-FILE): #P
#<FORMAT ERROR>
   Keyword arg 3 (TARGET): NIL
   Keyword arg 4 (BLOCK-COMPILE-PRESCAN): NIL
   Keyword arg 5 (COMPILE-BLOCK): NIL
   Keyword arg 6 (FASLSTATE): NIL
-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :directory (cons :relative (pathname-directory f)) :defaults f)
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
MKRP=MAKE.PATH.OUT.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
>>Error: The value of STR, :RELATIVE, should be a SIMPLE-STRING

DIRECTORY-NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>
:C  0: Use a new value
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> (trace make-pathname)
(MAKE-PATHNAME)
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE :RELATIVE "prog" "serv") :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P
>>Error: The value of STR, :RELATIVE, should be a SIMPLE-STRING

DIRECTORY-NAMESTRING:
   Required arg 0 (PATHNAME): #P
#<FORMAT ERROR>
:C  0: Use a new value
    1: Try loading "sys/boot" again
:A  2: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 f
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
MKRP=MAKE.PATH.OUT.COMP
-> 2
Abort to Lisp Top Level
;;; Abnormal exit of load "sys/boot.lisp"
Back to Lisp Top Level

USER: (load "sys/boot")
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
>>Error: Cannot open file "prog/serv/prog/serv/service.sbin" - No such file or directory

OPEN:
   Required arg 0 (PATHNAME): #P"/home1/mkrp/prog/serv/prog/serv/service.sbin"
   Keyword arg 1 (DIRECTION): :OUTPUT
   Keyword arg 2 (ELEMENT-TYPE): (UNSIGNED-BYTE 8)
   Keyword arg 3 (IF-EXISTS): :SUPERSEDE
   Keyword arg 4 (IF-DOES-NOT-EXIST): :CREATE
   Keyword arg 5 (ATTRIBUTES): NIL
:C  0: Use a new pathname
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :directory (pathname-directory f) :defaults f)
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
MKRP=MAKE.PATH.OUT.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
>>Error: Cannot open file "prog/serv/prog/serv/service.sbin" - No such file or directory

OPEN:
   Required arg 0 (PATHNAME): #P"/home1/mkrp/prog/serv/prog/serv/service.sbin"
   Keyword arg 1 (DIRECTION): :OUTPUT
   Keyword arg 2 (ELEMENT-TYPE): (UNSIGNED-BYTE 8)
   Keyword arg 3 (IF-EXISTS): :SUPERSEDE
   Keyword arg 4 (IF-DOES-NOT-EXIST): :CREATE
   Keyword arg 5 (ATTRIBUTES): NIL
:C  0: Use a new pathname
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :directory '(:relative) :defaults f)
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
MKRP=MAKE.PATH.OUT.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): 4
Please type Y or N
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
>>Error: Cannot open file "prog/serv/prog/serv/service.sbin" - No such file or directory

OPEN:
   Required arg 0 (PATHNAME): #P"/home1/mkrp/prog/serv/prog/serv/service.sbin"
   Keyword arg 1 (DIRECTION): :OUTPUT
   Keyword arg 2 (ELEMENT-TYPE): (UNSIGNED-BYTE 8)
   Keyword arg 3 (IF-EXISTS): :SUPERSEDE
   Keyword arg 4 (IF-DOES-NOT-EXIST): :CREATE
   Keyword arg 5 (ATTRIBUTES): NIL
:C  0: Use a new pathname
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.out.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults
		 #+lcl4.0 (make-pathname :directory '(:relative) :defaults f)
		 #-lcl4.0 f))
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined in "sys/boot.lisp"
MKRP=MAKE.PATH.OUT.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.OUT.COMP which used to be defined at top level



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
>>Error: Cannot open file "prog/serv/prog/serv/service.sbin" - No such file or directory

OPEN:
   Required arg 0 (PATHNAME): #P"/home1/mkrp/prog/serv/prog/serv/service.sbin"
   Keyword arg 1 (DIRECTION): :OUTPUT
   Keyword arg 2 (ELEMENT-TYPE): (UNSIGNED-BYTE 8)
   Keyword arg 3 (IF-EXISTS): :SUPERSEDE
   Keyword arg 4 (IF-DOES-NOT-EXIST): :CREATE
   Keyword arg 5 (ATTRIBUTES): NIL
:C  0: Use a new pathname
    1: Try compiling #P"prog/serv/service.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> :b
OPEN <- COMPILE-FILE <- MKRP=BOOT=LOAD-AND-COMPILE <- LAMBDA <- MAPC <- MKRP=BOOT=COMPILE-ALL-NEW <- MKRP=BOOT=RUN-BOOT <- MKRP-BOOT <- EVAL <- (:INTERNAL LOAD LUCID::LOAD-FROM-STREAM) <- (:INTERNAL LOAD LUCID::LOAD-SOURCE-FILE) <- LOAD <- EVAL <- SYSTEM:ENTER-TOP-LEVEL
-> :n
COMPILE-FILE:
   Required arg 0 (INPUT-PATHNAME): #P"prog/serv/service.lisp"
   Rest arg 1 (KEYS): (:OUTPUT-FILE #P"prog/serv/service.sbin")
   Keyword arg 2 (OUTPUT-FILE): #P"prog/serv/service.sbin"
   Keyword arg 3 (TARGET): NIL
   Keyword arg 4 (BLOCK-COMPILE-PRESCAN): NIL
   Keyword arg 5 (COMPILE-BLOCK): NIL
   Keyword arg 6 (FASLSTATE): NIL
-> :n
MKRP=BOOT=LOAD-AND-COMPILE:
Original code: (LUCID-COMMON-LISP:NAMED-LAMBDA MKRP=BOOT=LOAD-AND-COMPILE (F) (BLOCK MKRP=BOOT=LOAD-AND-COMPILE (LET # # #)))
   Required arg 0 (F): #P"prog/serv/service"
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
n
Do you want to make a protocol?  (Y or N): 
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"service"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"service"
1 Exit MAKE-PATHNAME #P"service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.sbin" :NAME "0service"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/0service.sbin"
;;; You are using the compiler in development mode (compilation-speed = 3)
;;; If you want faster code at the expense of longer compile time,
;;; you should use the production mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 0)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Generation of inline code is disabled (speed = 0)
;;; Reading source file "prog/serv/service.lisp"
;;; Writing binary file "prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"service"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"service"
1 Exit MAKE-PATHNAME #P"service.sbin"
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.sbin"
>>Error: Cannot find source or binary file matching "service.sbin"

LOAD:
   Required arg 0 (FILENAME-OR-STREAM): #P"service.sbin"
   Keyword arg 1 (VERBOSE): T
   Keyword arg 2 (PRINT): NIL
   Keyword arg 3 (IF-SOURCE-NEWER): :QUERY
   Keyword arg 4 (IF-SOURCE-ONLY): :LOAD-SOURCE
   Keyword arg 5 (IGNORE-BINARY-DEPENDENCIES): NIL
   Keyword arg 6 (IF-DOES-NOT-EXIST): :ERROR
:C  0: Try a new filename
    1: Try loading #P"service.sbin" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> 
(defun mkrp=make.path.load.comp (f)
  (make-pathname :type mkrp*compile-type
		 :defaults f))
MKRP=MAKE.PATH.LOAD.COMP
-> 2
Try loading "sys/boot" again
;;; Abnormal exit of load "sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"/home1/mkrp/sys/boot"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/sys/boot.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "service"
1 Exit MAKE-PATHNAME #P"prog/serv/service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "serv") :NAME "atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "opt") :NAME "options"
1 Exit MAKE-PATHNAME #P"prog/opt/options"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "memory"
1 Exit MAKE-PATHNAME #P"prog/ds/memory"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dataterm"
1 Exit MAKE-PATHNAME #P"prog/ds/dataterm"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "dt-term"
1 Exit MAKE-PATHNAME #P"prog/ds/dt-term"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "ord-poly"
1 Exit MAKE-PATHNAME #P"prog/ord/ord-poly"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ord") :NAME "orderings"
1 Exit MAKE-PATHNAME #P"prog/ord/orderings"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "denz"
1 Exit MAKE-PATHNAME #P"prog/hd/denz"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "hd") :NAME "hades"
1 Exit MAKE-PATHNAME #P"prog/hd/hades"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "pp") :NAME "pprint-latex"
1 Exit MAKE-PATHNAME #P"prog/pp/pprint-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "symboltable"
1 Exit MAKE-PATHNAME #P"prog/edt/symboltable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "formulatable"
1 Exit MAKE-PATHNAME #P"prog/edt/formulatable"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "editorwindow"
1 Exit MAKE-PATHNAME #P"prog/edt/editorwindow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "compile"
1 Exit MAKE-PATHNAME #P"prog/edt/compile"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "edt") :NAME "edit"
1 Exit MAKE-PATHNAME #P"prog/edt/edit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "init") :NAME "init"
1 Exit MAKE-PATHNAME #P"prog/init/init"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ds") :NAME "datastructure"
1 Exit MAKE-PATHNAME #P"prog/ds/datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-commutative"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-commutative"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "ac-match"
1 Exit MAKE-PATHNAME #P"prog/uni/ac-match"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "uni-thu"
1 Exit MAKE-PATHNAME #P"prog/uni/uni-thu"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "uni") :NAME "unification"
1 Exit MAKE-PATHNAME #P"prog/uni/unification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "normalization"
1 Exit MAKE-PATHNAME #P"prog/norm/normalization"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "norm") :NAME "presimplification"
1 Exit MAKE-PATHNAME #P"prog/norm/presimplification"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "cg") :NAME "connectiongraph"
1 Exit MAKE-PATHNAME #P"prog/cg/connectiongraph"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-datastructure"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-print"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-print"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-latex"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-latex"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-prepare"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-prepare"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "prot-execute"
1 Exit MAKE-PATHNAME #P"prog/prot/prot-execute"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "post"
1 Exit MAKE-PATHNAME #P"prog/prot/post"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "interface"
1 Exit MAKE-PATHNAME #P"prog/prot/interface"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "prot") :NAME "protocol"
1 Exit MAKE-PATHNAME #P"prog/prot/protocol"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-service"
1 Exit MAKE-PATHNAME #P"prog/op/op-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-inherit"
1 Exit MAKE-PATHNAME #P"prog/op/op-inherit"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "op-create"
1 Exit MAKE-PATHNAME #P"prog/op/op-create"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "operation"
1 Exit MAKE-PATHNAME #P"prog/op/operation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "two"
1 Exit MAKE-PATHNAME #P"prog/red/two"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-service"
1 Exit MAKE-PATHNAME #P"prog/red/red-service"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-datastructure"
1 Exit MAKE-PATHNAME #P"prog/red/red-datastructure"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-rw"
1 Exit MAKE-PATHNAME #P"prog/red/red-rw"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-crr"
1 Exit MAKE-PATHNAME #P"prog/red/red-crr"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "narrow"
1 Exit MAKE-PATHNAME #P"prog/red/narrow"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "red-linkcondition"
1 Exit MAKE-PATHNAME #P"prog/red/red-linkcondition"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "red") :NAME "reduction"
1 Exit MAKE-PATHNAME #P"prog/red/reduction"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "op") :NAME "construct"
1 Exit MAKE-PATHNAME #P"prog/op/construct"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/ctl/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "c") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/c/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "e") :NAME "preparation"
1 Exit MAKE-PATHNAME #P"prog/e/preparation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "mergeinst"
1 Exit MAKE-PATHNAME #P"prog/term/mergeinst"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "term") :NAME "terminator"
1 Exit MAKE-PATHNAME #P"prog/term/terminator"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "selection"
1 Exit MAKE-PATHNAME #P"prog/sel/selection"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-mark"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-mark"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "sel") :NAME "sel-manual"
1 Exit MAKE-PATHNAME #P"prog/sel/sel-manual"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "ctl") :NAME "control"
1 Exit MAKE-PATHNAME #P"prog/ctl/control"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "os-explanation"
1 Exit MAKE-PATHNAME #P"prog/os/os-explanation"
1 Enter MAKE-PATHNAME :DIRECTORY (:RELATIVE "prog" "os") :NAME "operatingsystem"
1 Exit MAKE-PATHNAME #P"prog/os/operatingsystem"
1 Enter MAKE-PATHNAME :NAME "compilerlisting" :TYPE "text"
1 Exit MAKE-PATHNAME #P"compilerlisting.text"
;;; Warning: Redefining FUNCTION MKRP=MAKE.PATH.LOAD.COMP which used to be defined at top level
;;; You are using the compiler in production mode (compilation-speed = 0)
;;; If you want shorter compile time at the expense of reduced optimization,
;;; you should use the development mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 3)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Optimization of tail calls is enabled (speed = 3)



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"service"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"service"
1 Exit MAKE-PATHNAME #P"service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.lisp"
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "service.sbin" :DEFAULTS #P"/home1/mkrp/service.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/service.sbin.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/service.sbin" :NAME "0service"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/0service.sbin"
;;; You are using the compiler in development mode (compilation-speed = 3)
;;; If you want faster code at the expense of longer compile time,
;;; you should use the production mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 0)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Generation of inline code is disabled (speed = 0)
;;; Reading source file "prog/serv/service.lisp"
;;; Writing binary file "prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/service"
1 Exit MAKE-PATHNAME #P"prog/serv/service.sbin"
;;; Loading binary file "prog/serv/service.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/serviceqlists"
1 Exit MAKE-PATHNAME #P"serviceqlists"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"serviceqlists"
1 Exit MAKE-PATHNAME #P"serviceqlists.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/serviceqlists.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/serviceqlists.lisp"
;;; Loading source file "prog/serv/serviceqlists.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
QCONC1 
QCONC 
QCONS 
QDELETE 
QINSERT-NTH 
QDELETE-NTH 
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/serviceqlists.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/serviceqlists.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "serviceqlists.sbin" :DEFAULTS #P"/home1/mkrp/serviceqlists.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/serviceqlists.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "serviceqlists.sbin" :DEFAULTS #P"/home1/mkrp/serviceqlists.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/serviceqlists.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "serviceqlists.sbin" :DEFAULTS #P"/home1/mkrp/serviceqlists.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/serviceqlists.sbin.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/serviceqlists.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/serviceqlists.sbin"
;;; Reading source file "prog/serv/serviceqlists.lisp"
;;; Writing binary file "prog/serv/serviceqlists.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/serviceqlists"
1 Exit MAKE-PATHNAME #P"prog/serv/serviceqlists.sbin"
;;; Loading binary file "prog/serv/serviceqlists.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/servicefiles"
1 Exit MAKE-PATHNAME #P"servicefiles"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"servicefiles"
1 Exit MAKE-PATHNAME #P"servicefiles.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/servicefiles.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/servicefiles.lisp"
;;; Loading source file "prog/serv/servicefiles.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MKRP-MAKE.PATHNAME 
MKRP-WITH.PATHNAME 
MKRP-LINELENGTH 
MKRP*DEFAULT.DIRECTORY 
MKRP=GET.DEFAULT.DIRECTORY 
MKRP*DEFAULT.NAME 
MKRP=GET.DEFAULT.NAME 
MKRP-SET.DEFAULT.DIRECTORY 
MKRP-SET.DEFAULT.NAME 
MKRP-OPENOUT 
MKRP-OPENIN 
MKRP-LOAD.FILE 
MKRP*ALL.SYSTEM.STREAMS 
MKRP-ADD.STREAM 
MKRP-REMOVE.STREAM 
MKRP-CLOSE.ALL.STREAMS 
CLOSEFILE 
CLOSE-STREAM 
BREAKMACROS 
MKRP-OUTSTREAMP 
MKRP-INSTREAMP 
*STANDARD-READTABLE* 
T 
T 
T 
READFILE 
MKRP-FILE.FUNCTIONS 
FILE.EXISTS 
FILENAME.CHECK 
MKRP-VIEW.FILE 
MKRP-CONVERSE.FILENAME 
MKRP-DEFAULT.PROBLEM 
MKRP-DEFAULT.LISP 
MKRP-DEFAULT.GRAPH 
MKRP-DEFAULT.CODE 
MKRP-DEFAULT.LIST 
MKRP-DEFAULT.TEXT 
MKRP-DEFAULT.OPTIONS 
MKRP-DEFAULT.AX 
MKRP-DEFAULT.TH 
MKRP-DEFAULT.FORMULAE 
MKRP-DEFAULT.TEMPPREPAXIOMS 
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/servicefiles.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/servicefiles.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "servicefiles.sbin" :DEFAULTS #P"/home1/mkrp/servicefiles.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/servicefiles.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "servicefiles.sbin" :DEFAULTS #P"/home1/mkrp/servicefiles.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/servicefiles.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "servicefiles.sbin" :DEFAULTS #P"/home1/mkrp/servicefiles.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/servicefiles.sbin.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/servicefiles.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/servicefiles.sbin"
;;; Reading source file "prog/serv/servicefiles.lisp"
;;; Writing binary file "prog/serv/servicefiles.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"prog/serv/servicefiles"
1 Exit MAKE-PATHNAME #P"prog/serv/servicefiles.sbin"
;;; Loading binary file "prog/serv/servicefiles.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :DEFAULTS #P"prog/serv/atpservice"
1 Exit MAKE-PATHNAME #P"prog/serv/atpservice.lisp"
1 Enter MAKE-PATHNAME :DIRECTORY NIL :DEFAULTS #P"prog/serv/atpservice"
1 Exit MAKE-PATHNAME #P"atpservice"
1 Enter MAKE-PATHNAME :TYPE "sbin" :DEFAULTS #P"atpservice"
1 Exit MAKE-PATHNAME #P"atpservice.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/atpservice.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/atpservice.lisp"
;;; Loading source file "prog/serv/atpservice.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SUPERSET 
SET= 
SET*= 
MEMBER* 
ANTIVALENT 
COPY-GRAPH 
COPY-GRAPH.DUPLICATE 
DUPL 
EQUIVALENT 
FLATTEN 
MAXIMA 
IMPLIES 
IN 
MAPPRINT 
INS 
INSASSOC 
INSERT 
INSIDE 
ISEMPTYSTACK 
LISTPOS 
LISTPOSITIONS 
MAKEEMPTYSTACK 
MAXELT 
*RIGHT.MARGIN* 
TAB 
LINELENGTH 
MKRP*STANDARD.RIGHT.MARGIN 
KKL*COUNT.PRINT.BUFFER 
PRINT-LENGTH 
TAB-PRINC 
TAB-PRIN1 
SPACES 
PRINTTAB 
CASSOC 
REMASSOC 
REMPROPS 
REMVALUESASSOC 
DISJOINTP 
DREMAP 
SATISFIABLE 
ZIP 
BUFFER.CREATE 
BUFFER.MULTIPLE.CONS 
BUFFER.CONS 
BUFFER.INS 
BUFFER.INSERT 
BUFFER.CONTENTS 
BUFFER.RESET 
BUFFER.CLEAR 
BUFFER.MAPCAR 
BUFFER.SUBSET 
BUFFER=EXTEND 
PUSH.BUFFER.STACK 
POP.BUFFER.STACK 
CARTESIAN.LOOP 
SAVE-PROPLIST 
PP 
REMAINING-MEMORY 
MKRP-GC.START 
1 Enter MAKE-PATHNAME :VERSION NIL :DEFAULTS #P"/home1/mkrp/atpservice.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/atpservice.sbin"
1 Enter MAKE-PATHNAME :TYPE "lisp" :NAME "atpservice.sbin" :DEFAULTS #P"/home1/mkrp/atpservice.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/atpservice.sbin.lisp"
1 Enter MAKE-PATHNAME :TYPE NIL :NAME "atpservice.sbin" :DEFAULTS #P"/home1/mkrp/atpservice.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/atpservice.sbin"
1 Enter MAKE-PATHNAME :TYPE "sbin" :NAME "atpservice.sbin" :DEFAULTS #P"/home1/mkrp/atpservice.sbin"
1 Exit MAKE-PATHNAME #P"/home1/mkrp/atpservice.sbin.sbin"
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/atpservice.lisp" :TYPE "sbin" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/atpservice.sbin"
;;; Reading source file "prog/serv/atpservice.lisp"
>>Break: Keyboard interrupt

LUCID-COMMON-LISP:INTERRUPT-PROCESS:
   Required arg 0 (PROCESS): #<Process Initial DC2926>
   Required arg 1 (FUNCTION): #<Compiled-Function LUCID::DO-KEYBOARD-INTERRUPTION 8E8066>
   Rest arg 2 (ARGS): NIL
:C  0: Return from Break
    1: Try compiling #P"prog/serv/atpservice.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> (load "prog/serv/atpservice.lisp")
1 Enter MAKE-PATHNAME :DEFAULTS #P"/home1/mkrp/prog/serv/atpservice.lisp" :VERSION :NEWEST
1 Exit MAKE-PATHNAME #P"/home1/mkrp/prog/serv/atpservice.lisp"
;;; Loading source file "prog/serv/atpservice.lisp"
#P"/home1/mkrp/prog/serv/atpservice.lisp"
-> (untrace)
(MAKE-PATHNAME)
-> 2
Try loading "sys/boot" again
;;; Compilation of file "prog/serv/atpservice.lisp" aborted,
;;; object file not written
;;; Abnormal exit of load "sys/boot.lisp"
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
;;; You are using the compiler in production mode (compilation-speed = 0)
;;; If you want shorter compile time at the expense of reduced optimization,
;;; you should use the development mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 3)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Optimization of tail calls is enabled (speed = 3)



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): y
;;; Dribble file "compilerlisting.text" started
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
;;; You are using the compiler in development mode (compilation-speed = 3)
;;; If you want faster code at the expense of longer compile time,
;;; you should use the production mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 0)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Generation of inline code is disabled (speed = 0)
;;; Reading source file "prog/serv/service.lisp"
;;; Writing binary file "prog/serv/service.sbin"
;;; Loading binary file "prog/serv/service.sbin"
;;; Loading source file "prog/serv/serviceqlists.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
QCONC1 
QCONC 
QCONS 
QDELETE 
QINSERT-NTH 
QDELETE-NTH 
;;; Reading source file "prog/serv/serviceqlists.lisp"
;;; Writing binary file "prog/serv/serviceqlists.sbin"
;;; Loading binary file "prog/serv/serviceqlists.sbin"
;;; Loading source file "prog/serv/servicefiles.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MKRP-MAKE.PATHNAME 
MKRP-WITH.PATHNAME 
MKRP-LINELENGTH 
MKRP*DEFAULT.DIRECTORY 
MKRP=GET.DEFAULT.DIRECTORY 
MKRP*DEFAULT.NAME 
MKRP=GET.DEFAULT.NAME 
MKRP-SET.DEFAULT.DIRECTORY 
MKRP-SET.DEFAULT.NAME 
MKRP-OPENOUT 
MKRP-OPENIN 
MKRP-LOAD.FILE 
MKRP*ALL.SYSTEM.STREAMS 
MKRP-ADD.STREAM 
MKRP-REMOVE.STREAM 
MKRP-CLOSE.ALL.STREAMS 
CLOSEFILE 
CLOSE-STREAM 
BREAKMACROS 
MKRP-OUTSTREAMP 
MKRP-INSTREAMP 
*STANDARD-READTABLE* 
T 
T 
T 
READFILE 
MKRP-FILE.FUNCTIONS 
FILE.EXISTS 
FILENAME.CHECK 
MKRP-VIEW.FILE 
MKRP-CONVERSE.FILENAME 
MKRP-DEFAULT.PROBLEM 
MKRP-DEFAULT.LISP 
MKRP-DEFAULT.GRAPH 
MKRP-DEFAULT.CODE 
MKRP-DEFAULT.LIST 
MKRP-DEFAULT.TEXT 
MKRP-DEFAULT.OPTIONS 
MKRP-DEFAULT.AX 
MKRP-DEFAULT.TH 
MKRP-DEFAULT.FORMULAE 
MKRP-DEFAULT.TEMPPREPAXIOMS 
;;; Reading source file "prog/serv/servicefiles.lisp"
;;; Writing binary file "prog/serv/servicefiles.sbin"
;;; Loading binary file "prog/serv/servicefiles.sbin"
;;; Loading source file "prog/serv/atpservice.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SUPERSET 
SET= 
SET*= 
MEMBER* 
ANTIVALENT 
COPY-GRAPH 
COPY-GRAPH.DUPLICATE 
DUPL 
EQUIVALENT 
FLATTEN 
MAXIMA 
IMPLIES 
IN 
MAPPRINT 
INS 
INSASSOC 
INSERT 
INSIDE 
ISEMPTYSTACK 
LISTPOS 
LISTPOSITIONS 
MAKEEMPTYSTACK 
MAXELT 
*RIGHT.MARGIN* 
TAB 
LINELENGTH 
MKRP*STANDARD.RIGHT.MARGIN 
KKL*COUNT.PRINT.BUFFER 
PRINT-LENGTH 
TAB-PRINC 
TAB-PRIN1 
SPACES 
PRINTTAB 
CASSOC 
REMASSOC 
REMPROPS 
REMVALUESASSOC 
DISJOINTP 
DREMAP 
SATISFIABLE 
ZIP 
BUFFER.CREATE 
BUFFER.MULTIPLE.CONS 
BUFFER.CONS 
BUFFER.INS 
BUFFER.INSERT 
BUFFER.CONTENTS 
BUFFER.RESET 
BUFFER.CLEAR 
BUFFER.MAPCAR 
BUFFER.SUBSET 
BUFFER=EXTEND 
PUSH.BUFFER.STACK 
POP.BUFFER.STACK 
CARTESIAN.LOOP 
SAVE-PROPLIST 
PP 
REMAINING-MEMORY 
MKRP-GC.START 
;;; Reading source file "prog/serv/atpservice.lisp"
;;; Writing binary file "prog/serv/atpservice.sbin"
;;; Loading binary file "prog/serv/atpservice.sbin"
;;; Loading source file "prog/opt/options.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OPT=IGNORE 
OPT=GET.OPTION.NAME 
OPT=GET.DEFAULT.VALUE 
OPT=GET.ARGUMENT.RANGE 
OPT=GET.OPTION.EXPLANATIONS 
OPT=GET.OPTION.DEMON 
OPT=GET.AREA.NAME 
OPT=GET.AREA.HEADER 
OPT=GET.AREA.OPTIONS 
OPT=GET.AREA.EXPLANATIONS 
OPT*ALL.AREAS 
OPT*ALL.OPTIONS 
OPT-GET.OPTION 
OPT=GET 
OPT=PUT 
OPT-PUT.OPTION 
OPT-SET.STANDARD 
OPT-GET.LIST.OPTIONS 
OPT-GET.LIST.AREA.OPTIONS 
OPT-PUT.LIST.OPTIONS 
OPT-ALL.OPTIONS 
OPT-SAVE 
OPT-GET.DEFAULT.VALUE 
OPT-GET.OPTION.TEXT 
OPT-ALL.AREAS 
OPT-GET.AREA.OPTIONS 
OPT-GET.AREA.HEADLINE 
OPT-GET.AREA.EXPLANATION 
OPT=CHECK 
OPT=CHECK.IS.LIST 
OPT=CHECK.AND.STANDARDIZE 
OPT=CHECK.IS.ELEMENT.OF.SET 
OPT=CHECK.IS.IN.RANGE 
OPT=CHECK.IS.OF.STRUCTURE 
OPT=CHECK.IS.EITHER.RANGE 
OPT-INIT 
OPT*ALL.RANGE.TYPES 
OPT-IS.COMPLETION 
OPT-IS.HEURISTIC.COMPLETION 
OPT-IS.KZ.COMPLETION 
OPT-IS.WITH.RESIDUES 
OPT*PR_LITERALS 
NIL 
OPT-WND_MAINWINDOW-EXPOSE 
STRINGS-EQUALIZE-LENGTH 
;;; Warning: FUNCTION SEL=STRAT_R.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Warning: FUNCTION SEL=STRAT_P.SELECTION defined more than once in "prog/opt/options.lisp"

NIL 
;;; Reading source file "prog/opt/options.lisp"
;;; Writing binary file "prog/opt/options.sbin"
;;; Loading binary file "prog/opt/options.sbin"
;;; Warning: FUNCTION SEL=STRAT_R.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Warning: FUNCTION SEL=STRAT_P.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Loading source file "prog/ds/memory.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MEM*MEMORY 
MEM*LAST.REUSABLE.VADR 
MEM*FIRST.REUSABLE.VADR 
MEM*COLLECTABLE 
MEM*NEXT.VADR 
MEM*NEXT.RADR 
MEM*RESERVE 
MEM*SIZE 
MEM*REST 
MEM*INCREMENT 
MEM-NEW 
MEM-GET 
MEM-PUT 
MEM-SHORTEN 
MEM-SIZE 
MEM=CLEAN.UP 
MEM-ERASE 
MEM-TYPE 
MEM-GET.TYPE 
MEM-ADDRESS 
MEM-ALL.ADR 
MEM-INITIALIZE 
MEM-RESET 
MEM-SAVE 
MEM-SAVE.SYMBOL 
MEM-MEMORY 
MEM=ALLOC 
MEM=ENLARGE.SIZE 
MEM=GBC 
MEM=NOT.ENOUGH.MEMORY 
MEM=GETSIZE 
MEM=REAL.ADDR 
MEM-PUTPROP 
MEM-GETPROP 
MEM-REMPROP 
MEM-REMPROPS 
MEM-GETPROPLIST 
MEM-SETPROPLIST 
MEM-ADDPROP 
MEM=PROPLIST.RADR 
;;; Reading source file "prog/ds/memory.lisp"
;;; Writing binary file "prog/ds/memory.sbin"
;;; Loading binary file "prog/ds/memory.sbin"
;;; Loading source file "prog/ds/dataterm.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DT-SORT.TRANSITIVE.CLOSURE 
DT-SORT.DIRECT.SUBSORTS 
DT-SORT.DIRECT.SUPERSORTS 
DT*COMMONS.TO.SAVE 
DT*SORT.ALL 
DT*SORT.NR 
DT*SORT.PROPERTIES 
DT*SORT.COMMON.COMPUTE.FLAG 
DT-SORT.IS.SUBSORT 
DT-SORT.INSERT 
DT-SORT.ALL 
DT-SORT.MINIMAL.SUBSORTS 
DT-SORT.NUMBER 
DT-SORT.ST.PUT.DIRECT.SUPERSORTS 
DT-SORT.INVERSE.TRANSITIVE.CLOSURE 
DT-SORT.COMMON.COMPUTE.FLAG 
DT-SORT.DISJOINT.SORTS 
DT-SORT.IS.DISJOINT.WITH 
DT-SORT.GREATEST.COMMON.SUBSORT 
DT-SORT.LEAST.COMMON.SUPERSORT 
DT-SORT.PUT.DISJOINTS 
DT-SORT.PUT.INV.TRANS.CLOSURE 
DT-SORT.PUT.TRANS.CLOSURE 
DT-SORT.UPDATE.ALL 
DT-SORT.UPDATE.DIRECT.SUBSORTS 
DT-SORT.CREATE 
DT-SORT.GREATEST.COMMON.SUBSORTS 
DT-SORT.GREATEST.COMMON.SUBSORT.OF.LIST 
DT-SORT.PUT.COMMON.COMPUTE.FLAG 
DT-SORT.UPDATE.MINIMAL.SUBSORTS 
DT-SORT.ST.REMOVE 
DT-SORT.LATTICE.COMPLETION 
DT-SORT.DELETE.ALL 
DT-SORT.LEAST.COMMON.SUPERSORTS 
DT-SORT.ADD.TO.INV.TRANS.CLOSURE 
DT-SORT.ADD.TO.TRANS.CLOSURE 
DT-SORT.CLEAR.SORTS 
DT-SORT.NEW.SYMBOL 
DT-SORT.UPDATE.MAX.SUBSORTS 
DT=SORT.CREATE.ALL.INTERSECTIONS 
DT=SORT.DIRECT.SUPERSORTS 
DT=SORT.INSERT 
DT=SORT.UPDATE.LEAST.SUPERSORTS 
DT=SORT.UPDATE.INVERSE.TRANS.CLOSURE 
DT=SORT.INVERSE.TRANSITIVE.CLOSURE 
DT=SORT.LEAST.SUPERSORTS 
DT=SORT.ST.UPDATE.SORTS 
DT=SORT.MINIMAL.SUBSORTS 
DT=SORT.UPDATE.TRANS.CLOSURE 
DT=SORT.UPDATE.MINIMAL.SUBSORTS 
DT=SORT.UPDATE.DIRECT.SUBSORTS.OUT.OF.TRANS.CLOSURE 
DT=SORT.DELETE.ALL 
DT-PUT.UNI.CREATES.VARIABLES 
DT=SORT.UPDATE.MAX.SUBSORTS 
DT=SORT.MAX.SUBSORTS 
DT=SORT.TRANSITIVE.CLOSURE 
DT=SORT.NEW.SYMBOL 
DT*VARIABLE.COUNTER 
DT*VARIABLE.BUFFER 
DT-VARIABLE.CREATE 
DT-VARIABLE.PNAME 
DT-VARIABLE.SORT 
DT-VARIABLE.PUTSORT 
DT-VARIABLE.GET.BINDING 
DT-VARIABLE.PUT.BINDING 
DT-VARIABLE.DELETE.BINDING 
DT-VARIABLE.RENAMING.SUBSTITUTION 
DT-VARIABLE.IS 
DT-VARIABLE.IN 
DT-VARIABLE.DELETE 
DT=VARIABLE.STORAGE 
DT=VARIABLE.GETPNAME 
DT=VARIABLE.GETSORT 
DT=VARIABLE.PUTSORT 
DT=VARIABLE.GETBINDING 
DT=VARIABLE.PUTBINDING 
DT=VARIABLE.IS 
DT*CONSTANT.COUNTER 
DT*CONSTANT.ALL 
DT*OMEGA.CONSTANT 
DT-CONSTANT.OMEGA 
DT-CONSTANT.CREATE 
DT-CONSTANT.SORT 
DT-CONSTANT.PUTSORT 
DT-CONSTANT.PUTPNAME 
DT-CONSTANT.PNAME 
DT-CONSTANT.IS 
DT-CONSTANT.ALL 
DT-CONSTANT.DELETE 
DT-CONSTANT.IS.SKOLEM 
DT=CONSTANT.STORAGE 
DT=CONSTANT.CREATE.PNAME 
DT=CONSTANT.GETPNAME 
DT=CONSTANT.GETSORT 
DT=CONSTANT.PUTPNAME 
DT=CONSTANT.PUTSORT 
DT=CONSTANT.IS 
DT*ABBREVIATIONS 
DT-ABBREVIATION.PUSH 
DT-ABBREVIATION.POP 
DT-ABBREVIATION.COMPRESS.TERM 
DT-ABBREVIATION.COMPRESS.TERMLIST 
DT-ABBREVIATION.EXPAND.TERM 
DT-ABBREVIATION.EXPAND.TERMLIST 
DT-ABBREVIATION.SCHEMES 
DT-ABBREVIATION.ALL 
DT-ABBREVIATION.TERM 
DT-ABBREVIATION.SORT 
DT-ABBREVIATION.IS 
DT=ABBREVIATION.EXPAND.ASS 
DT=FUNCTION.TUPLE.FIT 
DT=FUNCTION.TUPLE.MINIMIZE 
DT-ABBREVIATION.EXPAND.ASS 
DT-ABBREVIATION.PUTSORT 
DT=ABBREVIATION.STORAGE 
DT=ABBREVIATION.CREATE 
DT=ABBREVIATION.PUTTERM 
DT=ABBREVIATION.GETTERM 
DT=ABBREVIATION.PUTDEPTH 
DT=ABBREVIATION.GETDEPTH 
DT=ABBREVIATION.IS 
DT=ABBREVIATION.GENERATE 
DT=ABBREVIATION.INSERT 
DT=ABBREVIATION.CREATE.TREE 
DT=ABBREVIATION.EXPAND 
DT=ABBREVIATION.PUTSORT 
DT=ABBREVIATION.GETSORT 
DT=ABBREVIATION.NORMALFORM 
DT=ABBREVIATION.NORMALFORM.XX.TO.X 
DT=ABBREVIATION.NORMALFORM.XYZ.TO.XZ 
DT=ABBREVIATION.CONTAINS.VARIABLE 
DT=ABBREVIATION.NORMALFORM.INSERT.BRACKETS 
DT=ABBREVIATION.NORMALFORM.FOR.COMPRESS 
DT=ABBREVIATION.EXPAND.FOR.COMPRESS 
DT=ABBREVIATION.SEARCH.OLD.SCHEMES 
DT=ABBREVIATION.TERM.LESS 
DT=ABBREVIATION.ARGUMENT.NORMALFORM 
DT=ABBREVIATION.TERM.EQUAL 
DT*FUNCTION.COUNTER 
DT*FUNCTION.ALL 
DT*FUNCTION.ADMISSIBLE.THEORIES 
DT*FUNCTION.ACTUAL.THEORIES 
DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES 
DT*FUNCTION.COMPONENTS 
DT-FUNCTION.CREATE 
DT-FUNCTION.C.TREE 
DT-FUNCTION.C.C.TREE 
DT-FUNCTION.PUT.C.TREE 
DT-FUNCTION.PUT.C.C.TREE 
DT-FUNCTION.SORT 
DT-FUNCTION.PUTPNAME 
DT-FUNCTION.PNAME 
DT-FUNCTION.ATTRIBUTES 
DT-FUNCTION.ADD.ATTRIBUTES 
DT-FUNCTION.DOMAINSORTS 
DT-FUNCTION.ARITY 
DT-FUNCTION.THEORIES 
DT-FUNCTION.IS.MARKED 
DT-FUNCTION.IS 
DT-FUNCTION.ALL 
DT-FUNCTION.DELETE 
DT-FUNCTION.PUT.ATTRIBUTES 
DT-FUNCTION.CHANGE 
DT-FUNCTION.CHANGE.ONE.ENTRY 
DT-FUNCTION.IS.SKOLEM 
DT-FUNCTION.SORTLIST 
DT-FUNCTION.ARGUMENT.SYMMETRIES 
DT-FUNCTION.BUILD.TREE.CALC 
DT-FUNCTION.GLB.OF.RANGES 
DT-FUNCTION.IS.POLYMORPHIC 
DT-FUNCTION.UPDATE.POLYMORPHIC 
DT-FUNCTION.MAX.DOMAINS.OF.RANGE 
DT-FUNCTION.MAX.RANGE.SORT 
DT-FUNCTION.MIN.RANGES 
DT-FUNCTION.SORT.LIST.INVERSE 
DT-FUNCTION.TUPLE.COMPLETION 
DT-FUNCTION.TUPLE.LESS 
DT=FUNCTION.BUILD.TREE.CALC.R 
DT=FUNCTION.GLB.OF.RANGES 
DT=FUNCTION.MINIMAL.SORTS 
DT=FUNCTION.TUPLE.FIND.INV.TUPLES 
DT=FUNCTION.TUPLE.FIND.INV.TUPLES.R 
DT=FUNCTION.TUPLE.MIN.RANGES 
DT=FUNCTION.TUPLE.RETURN.ADMISSIBLE 
DT=FUNCTION.UPDATE.POLYMORPHIC 
DT=FUNCTION.STORAGE 
DT=FUNCTION.CREATE.PNAME 
DT=FUNCTION.IS 
DT=FUNCTION.GET 
DT==FUNCTION.GET 
DT=FUNCTION.PUT 
DT==FUNCTION.PUT 
DT*PREDICATE.ADMISSABLE.ATTRIBUTES 
DT*PREDICATE.COUNTER 
DT*EQUALITY.SYMBOLS 
DT*EQUALITY.PREDICATES 
DT*NONEQUALITY.PREDICATES 
DT*PREDICATE.ALL 
DT*PREDICATE.WITH.ATTRIBUTES 
DT*PREDICATE.COMPONENTS 
DT*TRUE.PREDICATE 
DT*FALSE.PREDICATE 
DT-PREDICATE.CREATE 
DT-PREDICATE.PUTPNAME 
DT-PREDICATE.PNAME 
DT-PREDICATE.IS.SYMMETRIC 
DT-PREDICATE.IS.EQUALITY 
DT-PREDICATE.ARE.SAME 
DT-PREDICATE.IS 
DT-PREDICATE.MARKED.ALL 
DT-PREDICATE.ALL 
DT-PREDICATE.EQUALITIES 
DT*ELEMENT.PREDICATE 
DT-PREDICATE.ELEMENT 
DT-PREDICATE.NONEQUALITIES 
DT-PREDICATE.PUT.POSITIVE.OCCURRENCES 
DT-PREDICATE.DELETE.POSITIVE.OCCURRENCES 
DT-PREDICATE.DELETE.POSITIVE.OCCURRENCE 
DT-PREDICATE.POSITIVE.OCCURRENCES 
DT-PREDICATE.PUT.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DELETE.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DELETE.NEGATIVE.OCCURRENCE 
DT-PREDICATE.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DOMAINSORTS 
DT-PREDICATE.PUTSORT 
DT-PREDICATE.ATTRIBUTES 
DT-PREDICATE.PUT.ATTRIBUTES 
DT-PREDICATE.ADD.ATTRIBUTES 
DT-PREDICATE.IS.MARKED 
DT-PREDICATE.REFL.CLAUSE 
DT-PREDICATE.DELETE 
DT-PREDICATE.CONVERTSET 
DT-PREDICATE.GET 
DT=PREDICATE.GET 
DT-PREDICATE.PUT 
DT=PREDICATE.PUT 
DT-PREDICATE.IS.TRUE 
DT-PREDICATE.IS.FALSE 
DT-PREDICATE.TRUE 
DT-PREDICATE.FALSE 
DT=PREDICATE.STORAGE 
DT=PREDICATE.CREATE.PNAME 
DT=PREDICATE.IS 
DT=PREDICATE.INSERT.OTHERSIDES 
DT=PREDICATE.OTHERSIDES.ADD.SYMMETRY 
DT=PREDICATE.OTHERSIDES.ADD.ASYMMETRY 
DT-TAF.CREATE 
DT=TAF.CREATE.LIST 
DT-TAF.CREATE.FIRST 
DT-TAF.CREATE.SECOND 
DT-TAF.CREATE.NEXT 
DT-TAF.CREATE.LEFT 
DT-TAF.CREATE.RIGHT 
DT-TAF.IS.LEFT 
DT-TAF.IS.RIGHT 
DT-TAF.TOPLEVEL 
DT-TAF.TOPLEVEL.EQUALITY 
DT-TAF.DIFFERENT.SIDES 
DT-TAF.ARE.EQUAL 
DT-TAF.DEEPER.OR.EQUAL 
DT-TAF.COMPOSE.TWO.TAFS 
DT-TAF.OTHERSIDE 
DT-TAF.ARGUMENT.POSITIONS 
DT-TAF.DEEPEST.ARGUMENT.NUMBER 
DT*UNI.CREATES.VARIABLES 
DT*SIGN.MINUS.SYMBOLS 
DT*SIGN.PLUS.SYMBOLS 
DT-GETPROP 
DT-PUTPROP 
DT-GETPROPLIST 
DT-SETPROPLIST 
DT-REMPROP 
DT-REMPROPS 
DT-ADDPROP 
DT-RESET 
DT-ACCESS 
DT-TYPE 
DT-PNAME 
DT-REPLACE.TERM.IN.TERMLIST 
DT-UPDATE.STRANGE.COMMONS 
DT-APPLY.TO.ALL.ADDR 
DT-UNI.CREATES.VARIABLES 
DT-SAVE 
DT-SAVE.SYMBOLS 
DT-PRINT.SYMBOLS 
DT*SYMBOL.KINDS 
DT-GROUND.TERM.SORT 
DT-SET.DIFFERENCE 
DT-ARITY 
;;; Reading source file "prog/ds/dataterm.lisp"
;;; Writing binary file "prog/ds/dataterm.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          DT-TERM_ARGUMENTS was referenced by DT-VARIABLE.IN,
;;;             DT=TAF.CREATE.LIST
;;;          DT-TERM.SORT was referenced by DT=ABBREVIATION.CREATE
;;;          RED=RW_COMPILE.PROC was referenced by
;;;             DT-FUNCTION.PUT.C.C.TREE
;;;          DT-TERM_C.TERM.IS was referenced by DT=TAF.CREATE.LIST
;;; Loading binary file "prog/ds/dataterm.sbin"
;;; Loading source file "prog/ds/dt-term.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DT-TERM_TOPSYMBOL 
DT-TERM_EQUAL 
DT-TERM_CREATE 
DT-TERM_ARGUMENTS 
DT-TERM_C.TERM.IS 
DT-TERM_IN 
DT-TERM.IS.WEAKENABLE 
DT=TERM.IS.WEAKENABLE 
DT-TERM.RENAMED 
DT-TERM.SORT 
DT-TERM.MINIMAL.SORTS 
DT-TERMLIST.MAXDEPTH 
DT-TERMLIST.VARIABLES 
DT-TERMLIST.CF 
DT-TERM.VARIABLES 
DT-TERM.CF 
DT-FIND.VARIABLES 
DT=FIND.VARIABLES 
DT=TERM.FUNCTIONSYMBOL 
DT=TERM.VAR.OCCUR 
DT-TERM.IS.CONSTANT 
DT-TERM.IS.VARIABLE 
DT-TERM.IS.ABBREVIATION 
;;; Reading source file "prog/ds/dt-term.lisp"
;;; Writing binary file "prog/ds/dt-term.sbin"
;;; Loading binary file "prog/ds/dt-term.sbin"
;;; Loading source file "prog/ord/ord-poly.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ORD*POL_LIMIT 
ORD-POL_SET.LIMIT 
ORD*POL_DEFAULT 
ORD=POL_DEFAULT 
ORD=POL_GREATER 
MONOMIAL 
COPY-MONOMIAL 
MONOM-LEX-ORDER 
EXPONENT-NAT-ORDER 
POLYNOMIAL 
MAKE-CONSTANT 
COPY-POLYNOMIAL 
MAX-DEGREE 
MIN-VAR-POLYNOMIAL 
APP-ELEM 
POLYNOMIAL-TO-STRING 
PRINT-POLYNOMIAL 
VC-PRINT-POLYNOMIAL 
ADD-POLYNOMIALS 
JOIN-MONOMIALS 
SUBTRACT-POLYNOMIALS 
MULT-POLYNOMIALS 
R-MULT-POLYNOMIALS 
REC-MULT-POL 
PARSE-EXPONENT 
PARSE-MONOMIAL 
READ-POLYNOMIAL 
CREATE-VAR-COEFFS 
EVAL-STRUCT 
DECOMP-POLYNOMIAL 
NO-OF-MULT 
OPT-EVAL-SEQ 
EVAL-POLYNOMIAL 
INTERPRETATION-ENTRY 
ORD=POL_ASSIGN 
ORD=POL_GET.FCT.ENTRY 
INTERPRETE 
AC-OPER-INTERPRETATION-P 
VC-MONOMIAL 
VC-POLYNOMIAL 
NORMALIZE-TO-VC-POLYNOMIAL 
POSITIVE 
*PRINT-POLY* 
*PRINT-POLY-LENGTH* 
T 
TR=POL 
;;; Reading source file "prog/ord/ord-poly.lisp"
;;; Writing binary file "prog/ord/ord-poly.sbin"
;;; Loading binary file "prog/ord/ord-poly.sbin"
;;; Loading source file "prog/ord/orderings.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ORD=LEX.GREATER 
ORD=SYMBOL.GREATER 
ORD=SORT 
ORD=SYMBOL.SEARCH.SORT 
ORD*LIST 
ORD=SYMBOL.SET.FOREIGN 
ORD=SYMBOL.WEIGHT 
ORD=KB_VAR.COUNT 
ORD=KB_VAR.SUBSET 
ORD=KB_VAR.PLUS 
ORD=KB_VAR.CONDITION 
ORD=KB_PUT 
ORD=KB_SET.FOREIGN 
ORD*KB_MINIMUM 
ORD=KB_VARIABLE.WEIGHT 
ORD=KB_SYMBOL.WEIGHT 
ORD=KB_TERM.WEIGHT 
ORD=KB_GREATER 
ORD=RPO_MS.GREATER 
ORD=RPO_SYMBOL.EQUAL 
ORD=RPO_GREATER 
ORD=UNCOMPARABLE.P 
ORD*ARRAY 
ORD*NR 
ORD=CONS.TERM 
ORD=RESET.ARRAY 
ORD=LPO_GREATER 
ORD=TERM_IN 
ORD=TERM_EQUAL 
ORD=COMPARE.EQ 
ORD=GREATER 
ORD-GREATER 
ORD-RESET 
ORD-SHOW 
;;; Reading source file "prog/ord/orderings.lisp"
;;; Writing binary file "prog/ord/orderings.sbin"
;;; Loading binary file "prog/ord/orderings.sbin"
;;; Loading source file "prog/hd/denz.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
>>Error: A symbol named AC-MATCH is already present in the MARKGRAF-KARL package,
              but it's not the one you are trying to IMPORT.

IMPORT:
   Required arg 0 (SYMBOLS): (TH-AC-MKRP::AC-MATCH TH-AC-MKRP::E-COMPL*AC-FUNCTIONS)
   Optional arg 1 (PACKAGE): #<Package "MARKGRAF-KARL" 160370E>
:C  0: UNINTERN the symbol, or forget this importation.
    1: Try loading #P"prog/hd/denz.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> (find-all-symbols "AC-MATCH")
(TH-AC-MKRP::AC-MATCH AC-MATCH)
-> (describe 'ac-match)
AC-MATCH is a symbol.  Its home package is MARKGRAF-KARL.
-> (inspect 'ac-match)
#<Symbol 1603AE7>

[0: NAME] "AC-MATCH"
[1: VALUE] Unbound
[2: FUNCTION] Undefined
[3: PLIST] NIL
[4: PACKAGE] #<Package "MARKGRAF-KARL" 160370E>
>> 0
"AC-MATCH"

>> q
>>Error: The symbol Q has no global value

SYMBOL-VALUE:
   Required arg 0 (S): Q
:C  0: Try evaluating Q again
:A  1: Abort to Inspector Top Level
    2: Abort to Debugger Level 1
    3: UNINTERN the symbol, or forget this importation.
    4: Try loading #P"prog/hd/denz.lisp" again
    5: Try loading "sys/boot" again
    6: Abort to Lisp Top Level

->-> 1
Abort to Inspector Top Level
Back to Inspector Top Level

>> help
>>Error: The symbol HELP has no global value

SYMBOL-VALUE:
   Required arg 0 (S): HELP
:C  0: Try evaluating HELP again
:A  1: Abort to Inspector Top Level
    2: Abort to Debugger Level 1
    3: UNINTERN the symbol, or forget this importation.
    4: Try loading #P"prog/hd/denz.lisp" again
    5: Try loading "sys/boot" again
    6: Abort to Lisp Top Level

->-> 2
Abort to Debugger Level 1
>>Error: A symbol named AC-MATCH is already present in the MARKGRAF-KARL package,
              but it's not the one you are trying to IMPORT.

IMPORT:
   Required arg 0 (SYMBOLS): (TH-AC-MKRP::AC-MATCH TH-AC-MKRP::E-COMPL*AC-FUNCTIONS)
   Optional arg 1 (PACKAGE): #<Package "MARKGRAF-KARL" 160370E>
:C  0: UNINTERN the symbol, or forget this importation.
    1: Try loading #P"prog/hd/denz.lisp" again
    2: Try loading "sys/boot" again
:A  3: Abort to Lisp Top Level

-> 0
UNINTERN the symbol, or forget this importation.
UNINTERN AC-MATCH from the MARKGRAF-KARL package?  (Y or N): y

T 
DENZ-INIT 
DENZ=TRANS.FROM.JOERG 
DENZ=TRANS.SUBST.FROM.JOERG 
DENZ=TRANS.TO.JOERG 
UNI*TH.TERM.TOP 
DENZ=TERM.CREATE 
DENZ=TRANS.REMOVE.L 
DENZ-MATCH 
DENZ-MATCH.LIST 
;;; Reading source file "prog/hd/denz.lisp"
;;; While compiling DENZ-INIT
;;; Warning: Free variable E-COMPL*AC-FUNCTIONS assumed to be special
;;; Writing binary file "prog/hd/denz.sbin"
;;; Warning: The following function is not known to be defined:
;;;          AC-MATCH was referenced by DENZ-MATCH, DENZ-MATCH.LIST
;;; Loading binary file "prog/hd/denz.sbin"
;;; Loading source file "prog/hd/hades.lisp"

#<Package "HADES" 105C166> 
#<Package "MARKGRAF-KARL" 160370E> 
T 
T 
NIL 
HD-RESET 
HD=INSTANTIATE 
HD=TRANSLATE.ASSOCIATIVE.TO 
HD=TRANSLATE.AC.TO 
HD=TRANSLATE.AC1.TO 
HD=TRANSLATE.AG.TO 
HD=TRANSLATE.OBJECTS.TO 
HD=TRANSLATE.OBJECTS.FROM 
HD-UNIFY.TERMS 
HD-UNIFY.TERMLISTS 
HD=UNIFY 
;;; Reading source file "prog/hd/hades.lisp"
;;; Writing binary file "prog/hd/hades.sbin"
;;; Loading binary file "prog/hd/hades.sbin"
;;; Loading source file "prog/pp/pprint.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PP*LEFT.MARGIN 
PP*RIGHT.MARGIN 
PP*NEGATIVE.SIGN 
PP*POSITIVE.SIGN 
PP*POSITIVE.SIGNS 
PP*EMPTY.CLAUSE.SIGN 
PP*DISJUNCTION.SIGN 
PP-PRINT.INFIX.FORMULA 
PP=PRINT.INFIX.FORMULA 
PP=EXTRACT.&.PRINT.INFIX.QUANTIFIERS 
PP*INFIX.SEPARATORS 
PP=FORMULA.SEPARATOR 
PP=SPLIT.INFIX.FORMULA 
PP=SPLIT 
PP=PRINT.INFIX.FORMULA.ONE.LINE 
PP=INFIX.FORMULA.LENGTH.ONE.LINE 
PP-PRINT.LITERALS 
PP=PRINT.LITERALS 
PP-PRINT.LITERAL 
PP=PRINT.LITERAL 
PP=PRINT.LITERAL.ONE.LINE 
PP=LITERAL.LENGTH.ONE.LINE 
PP-PRINT.TERM 
PP=PRINT.TERM 
PP-PRINT.TERM.ONE.LINE 
PP=PRINT.TERM.ONE.LINE 
PP-TERM.LENGTH.ONE.LINE 
PP=TERM.LENGTH.ONE.LINE 
PP-SUM 
;;; Reading source file "prog/pp/pprint.lisp"
;;; Writing binary file "prog/pp/pprint.sbin"
;;; Loading binary file "prog/pp/pprint.sbin"
;;; Loading source file "prog/pp/pprint-latex.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PP*L_LEFT.MARGIN 
PP*L_RIGHT.MARGIN 
PP*L_NEGATIVE.SIGN 
PP*L_POSITIVE.SIGN 
PP*L_POSITIVE.SIGNS 
PP*L_EMPTY.CLAUSE.SIGN 
PP*L_DISJUNCTION.SIGN 
PP-L_PRINT.INFIX.FORMULA 
PP=L_PRINT.INFIX.FORMULA 
PP=L_EXTRACT.&.PRINT.INFIX.QUANTIFIERS 
PP*L_INFIX.SEPARATORS 
PP=L_FORMULA.SEPARATOR 
PP=L_SPLIT.INFIX.FORMULA 
PP=L_SPLIT 
PP=L_PRINT.INFIX.FORMULA.ONE.LINE 
PP=L_INFIX.FORMULA.LENGTH.ONE.LINE 
PP-L_PRINT.LITERALS 
PP=L_PRINT.LITERALS 
PP-L_PRINT.LITERAL 
PP=L_PRINT.LITERAL 
PP=L_PRINT.LITERAL.ONE.LINE 
PP=L_LITERAL.LENGTH.ONE.LINE 
PP-L_PRINT.TERM 
PP=L_PRINT.TERM 
PP-L_PRINT.TERM.ONE.LINE 
PP=L_PRINT.TERM.ONE.LINE 
PP-L_TERM.LENGTH.ONE.LINE 
PP=L_TERM.LENGTH.ONE.LINE 
PP-L_SUM 
;;; Reading source file "prog/pp/pprint-latex.lisp"
;;; While compiling PP=L_PRINT.LITERALS
;;; Warning: Variable RIGHT.POS is bound but not referenced
;;; Warning: Variable LEFT.POS is bound but not referenced
;;; Writing binary file "prog/pp/pprint-latex.sbin"
;;; Loading binary file "prog/pp/pprint-latex.sbin"
;;; Loading source file "prog/edt/symboltable.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ST-RESET 
ST-FIX 
ST-POP.SYMBOLTABLE 
ST-PUSH.SYMBOLTABLE 
ST-CLEAR.STACK 
ST-STACK.EMPTY 
ST-STACK.LENGTH 
ST-ENTER.SYMBOLENTRY 
ST-CHANGE.SYMBOLENTRY 
ST-ENTER.SYMBOL.CLASSIFICATION 
ST-GET.SYMBOL.CLASSIFICATION 
ST-GET.TRANSITIVE.CLOSURE 
ST-GET.INVERSE.TRANSITIVE.CLOSURE 
ST-ALL.SYMBOLNAMES 
ST-IS.IN.SYMBOLTABLE 
ST-REMOVE.SYMBOL 
ST-REPLACE.SYMBOL 
ST-SAVE 
ST-LOAD 
ST-SET.LOAD.FLAG 
ST-LOAD.FLAG 
ST-READ 
ST-CREATE.VARIABLE 
ST-CREATE.CONSTANT 
ST-CREATE.FUNCTION 
ST=GET.SYMBOLENTRY 
ST=GET.SYMBOLARITY 
ST=GET.SYMBOLATTRIBUTE 
ST=GET.SYMBOLDATA 
ST=GET.SYMBOLDOMAIN 
ST=GET.SYMBOLKIND 
ST=GET.SYMBOLRANGE 
ST=PUT.NEW.ON.STACK 
ST=PUT.CHANGE.ON.STACK 
ST=STACK.EMPTY 
ST=CLEAR.STACK 
ST=RELEASE.SYMBOLTABLE 
ST*STACK1 
ST*STACK2 
ST*LOAD.FLAG 
ST*SYMBOL.ADDRESSES 
;;; Reading source file "prog/edt/symboltable.lisp"
;;; Writing binary file "prog/edt/symboltable.sbin"
;;; Loading binary file "prog/edt/symboltable.sbin"
;;; Loading source file "prog/edt/formulatable.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
FMT*NUMBER.OF.AREAS 
FMT*UNDO.STACK 
FMT*LOAD.FLAG 
FMT*AREA.POINTERS 
FMT*UNDO.INDICATOR 
FMT*LANGUAGE 
FMT-EDIT 
FMT-RESET 
FMT-IS.RESET 
FMT-SET.LOAD.FLAG 
FMT-SET.LANGUAGE 
FMT-INSERT 
FMT-DELETE 
FMT-SWITCH 
FMT=EXCHANGE.CAR 
FMT-SHIFT 
FMT-REPLACE 
FMT-WRITE 
FMT-LOAD 
FMT=LOAD 
FMT=CUT 
FMT-UNDO 
FMT=PUSH.UNDO 
FMT-COMMAND 
FMT=PP 
FMT=STATE 
FMT=PRINT.FORM 
FMT=PRINT.INFIX.FORM 
FMT=AREA.OF.FORMULA 
FMT=POSITION.OF.FORMULA.IN.AREA 
FMT=WRITE.NUMBER.OF.AREA 
FMT-NUMBER.OF.FORMULAS 
FMT=NUMBER.OF.FORMULAS 
FMT-FORMULA 
FMT=FORMULA 
FMT-LAST.DESTRUCTIVE.COMMAND 
FMT=ERRORS 
FMT=FUN.ERRORS 
FMT=OUTPUTS 
FMT=FUN.OUTPUTS 
FMT=AREA 
;;; Reading source file "prog/edt/formulatable.lisp"
;;; Writing binary file "prog/edt/formulatable.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          EDT-STANDARD-READTABLE was referenced by FMT-EDIT
;;;          EDT=EDIT.EXPRESSION was referenced by FMT-EDIT
;;; Loading binary file "prog/edt/formulatable.sbin"
;;; Loading source file "prog/edt/editorwindow.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
EDT*RUN.WINDOW 
EDT*CONTENTS 
EDT=EDIT.EXPRESSION 
EDT=EDIT.CHANGED 
EDT=EDIT.FILE 
;;; Reading source file "prog/edt/editorwindow.lisp"
;;; While compiling EDT=EDIT.EXPRESSION
;;; Warning: Variable EXPRESSION is bound but not referenced
;;; While compiling EDT=EDIT.CHANGED
;;; Warning: Variable EXPRESSION is bound but not referenced
;;; While compiling EDT=EDIT.FILE
;;; Warning: Variable EXPRESSION is bound but not referenced
;;; Writing binary file "prog/edt/editorwindow.sbin"
;;; Loading binary file "prog/edt/editorwindow.sbin"
;;; Loading source file "prog/edt/compile.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
COM*KEYWORDS.PLL 
COM*KEYWORDS.COLON 
COM*KEYWORDS.IND 
COM*LETTERS 
COM*DIGITS 
COM*SPECIAL.SIGNS 
COM*EXPRESSION.PREFIX.PLL 
COM*EXPRESSION.PREFIX.IND 
COM*CHANGED.SYMBOLS 
COM*USED.SYMBOLS 
COM*EQUIVALENCES 
COM*IMPLICATIONS 
COM*ERROR 
COM*VSTACK 
COM-RESET 
COM-KEYWORD 
COM-CHANGED.SYMBOLS 
COM-USED.SYMBOLS 
COM-EXPRESSION.PREFIX 
COM=COLONIZE 
COM-COMPILE 
COM=1=SYMBOL.ANALYSYS 
COM=1=IS.IDENTIFIER 
COM=1=IS.NAME 
COM=1=SYMBOL.ACCEPTED 
COM=1=SYMBOL.IS 
COM=1=NEXT.SYMBOL 
COM=2=STATEMENT 
COM=2=TYPE.DECLARATION 
COM=2=TYPE.DEFINITION 
COM=2=TYPETAIL 
COM=2=TYPELIST 
COM=2=SUBSORT.DECLARATION 
COM=2=AC1 
COM=2=AG 
COM=2=PROPERTY.DECLARATION 
COM=2=QUANTIFICATION 
COM=2=EQUIVALENCE.1 
COM=2=EQUIVALENCE.2 
COM=2=IMPLICATION.1 
COM=2=IMPLICATION.2 
COM=2=DISJUNCTION.1 
COM=2=DISJUNCTION.2 
COM=2=CONJUNCTION.1 
COM=2=CONJUNCTION.2 
COM=2=NEGATION 
COM=2=ATOMAR.FORMULA 
COM=2=STRUCTURE.DECLARATION 
COM=2=STRUCTURE.ANNOUNCEMENT 
COM=2=STRUCTURE.DEFINITION 
COM=2=STRUCTURE.TAIL 
COM=2=CONSTANT.AND.CONSTRUCT 
COM=2=CONSTANT.AND.CONSTRUCT.TAIL1 
COM=2=CONSTANT.AND.CONSTRUCT.TAIL2 
COM=2=CONSTRUCTION.DEFINITION 
COM=2=CONSTRUCTION.DEFINITION.TAIL 
COM=2=FUNCTION.DEFINITION 
COM=2=PARAMETER.LIST 
COM=2=PARAMETER.TAIL 
COM=2=FUNCTION.BODY 
COM=2=FUNCTION.IF.CLAUSE.LIST 
COM=2=FUNCTION.IF.CLAUSE.TAIL 
COM=2=CONDITION 
COM=2=IF.CONJUNCTION.1 
COM=2=IF.CONJUNCTION.2 
COM=2=LITERAL 
COM=2=PREDICATE.DEFINITION 
COM=2=PREDICATE.BODY 
COM=2=PREDICATE.IF.CLAUSE.LIST 
COM=2=PREDICATE.IF.CLAUSE.TAIL 
COM=2=VARIABLE.DECLARATION 
COM=2=VARIABLE.TYPE 
COM=2=PROPOSITION 
COM=2=ATOM 
COM=2=EQUALITY 
COM=2=EQUALITY.SYMBOL 
COM=2=TERM 
COM=2=TERMTAIL 
COM=2=TERMLIST 
COM=2=IDENTIFIER.LIST 
COM=2=IDENTIFIER.TAIL 
COM=2=CONSTANT.LIST 
COM=2=CONSTANT.TAIL 
COM=2=IDENTIFIER.OR.NAME 
COM=2=IDENTIFIER 
COM=2=NUMBER 
COM=2=NAME 
COM=2=SORT.SYMBOL 
COM=2=SORT.TERM 
COM=2=SORT.SYMBOLLIST 
COM=2=SORT.SYMBOL.TAIL 
COM=2=SORT.SYMBOL.SEQUENCE 
COM=2=SORT.SYMBOL.SEQUENCE.TAIL 
COM=QUANTIFICATION.CLOSURE 
COM=JUNCTION.CLOSURE 
COM=CREATE.STRUCTURE.SCHEME 
COM=3=ENTER.SYMBOL 
COM=3=ENTER.SORT 
COM=3=VSTACK.PUSH 
COM=3=VSTACK.POP 
COM=3=VSTACK.NEWNAME 
COM=3=VSTACK.OLDNAME 
COM=3=INSERT.PROPERTY 
COM=3=ENTER.PARAMETER.BINDING 
COM=3=GET.PARAMETER.BINDING 
COM=3=IS.PARAMETER.UNBOUND.ATOM 
COM=3=IS.PARAMETER.BINDING 
COM=3=IS.STRUCTURE.TERM.SCHEMA 
COM=4=TYPE.CHECK 
COM-LAST.ERROR.MESSAGE 
COM=ERROR 
COM=ERROR.PRINT 
;;; Reading source file "prog/edt/compile.lisp"
;;; Writing binary file "prog/edt/compile.sbin"
;;; Loading binary file "prog/edt/compile.sbin"
;;; Loading source file "prog/edt/edit.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
EDT*THEOREM.FLAG 
EDT*UNDO.MODE 
EDT*UNDO.STACK 
EDT*SYMBOL.TABLE.LIST 
EDT*SYMBOL.TABLE.UNDO.STACK 
EDT*SAVED.INDICATOR 
EDT*SAVING.INDICATOR 
EDT*SEPARATOR 
EDT*INPUT.FILES 
EDT*DIALOGUE.INPUT.FILE 
EDT*DIALOGUE.OUTPUT.FILE 
EDT*COMMANDS 
EDT*LINELENGTH 
EDT*STANDARD.READTABLE 
EDT*COMMAND.READTABLE 
EDT*SEPARATOR.READTABLE 
EDT*-READTABLE 
EDT*NUMBER.READTABLE 
EDT*NORMAL.READTABLE 
EDT-SET.READTABLES 
EDT-STANDARD-READTABLE 
EDT=READ 
EDT=READP 
EDT=FORMULA.TO.INSERT 
EDT=CHANGED.FORMULA 
EDT=GET.CL 
EDT=GET 
EDT*BUFFER 
EDT-EDIT 
EDT=GET.FILE.ACTIVE 
EDT-GET.FILES 
EDT=WORK 
EDT=GET.ACTIVE.FORMULAS 
EDT=NORM.COMMAND.NAME 
EDT=READ.COMMAND 
EDT=IGNORE.COMMAND 
EDT=WRITELN 
EDT=READLN 
EDT=READ.COMMAND.LINE 
EDT=ASK.READLN 
EDT=EXECUTE.COMMAND 
EDT=INSERT 
EDT=INSERT.INTERNAL 
EDT=DELETE 
EDT=SHIFT.UP 
EDT=SHIFT.ONE.UP 
EDT=SHIFT.DOWN 
EDT=SHIFT.ONE.DOWN 
EDT=EDIT 
EDT=CHANGE 
EDT=FORMULAE.FILE.IS 
EDT=READ* 
EDT=WRITE.GET 
EDT=WRITE 
EDT=EXECUTE 
EDT=SWITCH 
EDT=UNDO 
EDT=PUSH.UNDO 
EDT=REPLACE 
EDT=REPLACE.IN.ATOMS 
EDT=REPLACE.PART.OF.LIST 
EDT=PPRINT 
EDT=SHOW 
EDT=PRINT.TABLE 
EDT=PRINT.TABLE.DASH 
EDT=WRITE.TAB 
EDT=LIST.SYMBOL.PROPERTIES 
EDT=SYMBOLS&TABULATOR 
EDT=PREFIX 
EDT=INFIX 
EDT=END 
EDT=V 
EDT=HELP 
EDT=HHELP 
EDT=CREATE.FORMULA 
EDT=GET.INFIX.FORMULA 
EDT=GET.PREFIX.FORMULA 
EDT=IS.FIRST.INPUT.FILE 
EDT=INPUT.FILE 
EDT=SET.INPUT.FILE 
EDT=RESET.INPUT.FILE 
EDT=IS.INPUT.FILE.SEQUENCE.RECURSIVE 
EDT=COMMAND.COUNTER 
EDT=OUTPUTS 
EDT=SECOND.PART.ENGLISH 
EDT=SECOND.PART.GERMAN 
EDT=ERRORS 
EDT=GET.COMMAND 
;;; Reading source file "prog/edt/edit.lisp"
;;; Writing binary file "prog/edt/edit.sbin"
;;; Loading binary file "prog/edt/edit.sbin"
;;; Loading source file "prog/init/init.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MKRP-INIT 
;;; Reading source file "prog/init/init.lisp"
;;; Writing binary file "prog/init/init.sbin"
;;; Expanding Dynamic Memory
;;; Loading binary file "prog/init/init.sbin"
;;; Loading source file "prog/ds/datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DS*SIGN.PLUS.SYMBOLS 
DS*SIGN.MINUS.SYMBOLS 
DS*CLAUSE.COMMON.CELLS 
DS*CLAUSE.LITERAL.CELLS 
DS=CLAUSE.STORAGE 
DS=CLAUSE.GET 
DS==CLAUSE.GET 
DS=CLAUSE.PUT 
DS==CLAUSE.PUT 
DS=CLAUSE.IS 
DS-LIT.CREATE 
DS-LIT.RENAMED 
DS-LIT.SIGN 
DS-LIT.PREDICATE 
DS-LIT.TERMLIST 
DS-LIT.IS.NEGATIVE 
DS-LIT.IS.POSITIVE 
DS-LIT.IS.EQUALITY 
DS-LITS.VARS 
DS-SIGN.IS.POSITIVE 
DS-SIGN.IS.NEGATIVE 
DS-SIGN.ARE.EQUAL 
DS-SIGN.ARE.NOT.EQUAL 
DS-SIGN.OTHER.SIGN 
DS=LIT.STORAGE 
DS=LIT.GETSIGN 
DS=LIT.PUTSIGN 
DS=LIT.GETPREDICATE 
DS=LIT.PUTPREDICATE 
DS=LIT.GETTERMLIST 
DS=LIT.PUTTERMLIST 
DS-PREDICATE.OTHERSIDES 
DS-PREDICATE.GET.OTHERSIDE.SIGN 
DS-PREDICATE.GET.OTHERSIDE.PREDICATE 
DS-PREDICATE.GET.OTHERSIDE.RULES 
DS*RULE.ADMISSIBLE.OTHERSIDES_T 
DS*RULE.ADMISSIBLE.OTHERSIDES_S+ 
DS*RULE.ADMISSIBLE.OTHERSIDES_S- 
DS*RULE.ADMISSIBLE.OTHERSIDES_R 
DS*RULES 
DS-RULES 
DS-RULE.TERMLISTS 
DS-RULE.ORIENTED 
DS-RULE.INSERT 
DS-RULE.R.IFF.T 
DS=RULE.CONSTRUCT.OTHERSIDE 
DS=RULE.SHORTEN.OTHERSIDE 
DS=CLAUSE.CREATE 
DS-CLAUSE.DO 
DS-CLAUSE.SOME 
DS-CLAUSE.CREATE 
DS-CLAUSE.POS.EQUATION 
DS-CLAUSE.FINITE.DOMAIN 
DS-LIT.FINITE.DOMAIN 
DS*FINITE.DOMAIN 
DS-FINITE.DOMAIN.SET 
DS-FINITE.DOMAIN.DOMAIN 
DS-FINITE.DOMAIN.CLAUSE 
DS-CLAUSE.ONLY.EQUATIONS 
DS-LIT.POS.EQUATION 
DS=REWRITE.UPDATE 
DS-REWRITE.UPDATE 
DS=CLAUSE.PUT.RULE 
DS=KZ.COMPUTE.LITERAL 
DS-COMPUTE.LITERAL 
DS-CLAUSE.LITERAL 
DS-CLAUSE.COMPUTE.MAX.LITNO 
DS=CLAUSE.REWRITE.RULE.SET 
DS-CLAUSE.REWRITE.RULE.SET 
DS-CLAUSE.IRREDUCIBLE.SET 
DS-CLAUSE.IRREDUCIBLE.IS 
DS-CLAUSE.REWRITE.LITERALS 
DS-CLAUSE.LIT.REWRITE.RULE 
DS-CLAUSE.LIT.IS.UNFAILING 
DS-CLAUSE.LIT.UNFAILING.SET 
DS-CLAUSE.LIT.IS.MAX 
DS-CLAUSE.LIT.SET.MAX 
DS-CLAUSE.PASSIVE.POSITIONS 
DS-CLAUSE.PUT.PASSIVE.POSITIONS 
DS-CLAUSE.RESET.REWRITE.RULE 
DS=CLAUSE.LIT.RESET.LINKCOLOURS 
DS-CLAUSE.PNAME 
DS-CLAUSE.LIT.GETPROP 
DS-CLAUSE.LIT.PUTPROP 
DS-CLAUSE.LIT.REMPROP 
DS-CLAUSE.LIT.REMPROPS 
DS-CLAUSE.LIT.GETPROPLIST 
DS-CLAUSE.ALL.LIT.REMPROP 
DS-CLAUSE.ALL.LIT.REMPROPS 
DS-CLAUSE.PARENTS 
DS-CLAUSE.PUT.PARENTS 
DS-CLAUSE.ANCESTORS 
DS-CLAUSE.DEPTH 
DS-CLAUSE.VARIABLES 
DS-CLAUSE.RENAMING 
DS-CLAUSE.NOLIT 
DS-CLAUSE.ATTRIBUTES 
DS-CLAUSE.ADD.ATTRIBUTES 
DS-CLAUSE.POTENTIALLY.FALSE.LITNOS 
DS-CLAUSE.PUT.POTENTIALLY.FALSE.LITNOS 
DS-CLAUSE.POTENTIALLY.TRUE.LITNOS 
DS-CLAUSE.PUT.POTENTIALLY.TRUE.LITNOS 
DS-CLAUSE.SIGN 
DS-CLAUSE.PREDICATE 
DS-CLAUSE.POS.PREDICATES 
DS-CLAUSE.ALL.PREDICATES 
DS-CLAUSE.PREDICATE.OCCURRENCES 
DS-CLAUSE.TERMLIST 
DS-CLAUSE.REPLACE.LITERAL 
DS-CLAUSE.LIT.VARIABLES 
DS-CLAUSE.LINKS 
DS-CLAUSE.LINKS.THISSIDE 
DS-CLAUSE.LINKS.OTHERSIDE 
DS-CLAUSE.LIT 
DS-CLAUSE.ALL.LINKS 
DS-CLAUSE.IS.EQUATION 
DS-CLAUSE.IS.UNIT 
DS-CLAUSE.IS.PURE 
DS-CLAUSE.IS.PREFERRED 
DS-CLAUSE.IS.HORN 
DS-CLAUSE.IS 
DS-CLAUSE.REMOVE.LITERAL 
DS-CLAUSE.ADMISSIBLE.SORT 
DS-CLAUSE.DELETE 
DS-CLAUSE.ONE.LIT.UNIFIER 
DS-CLAUSE.FCTSTACK 
DS-CLAUSE.VAR.OCCUR.IN.LITERAL 
DS*LINK.TYPES 
DS*LINK.CLAUSE 
DS*LINK.LITERALS 
DS*LINK.INITIAL 
DS*LINK.PURITY 
DS*LINK.RENAMED 
DS*LINK.NOPURITY 
DS*LINK.RULES 
DS*LINK.TAUTOLOGY.TYPE 
DS*LINK.WITH.NEGPARENT 
DS*LINK.ACTIVE.OPERATION 
DS*LINK.ACTIVE.OPERATION.EXTENDED 
DS*LINK.AUTOLINKS 
DS*LINK.NOT.AUTOLINKS 
DS*LINK.EXTENDED.PARAMODULATION 
DS*LINK.WITH.UNIFIERS 
DS*LINK.PARAMODULATION 
DS*LINK.ACTIVE.PARAMODULATION 
DS*LINK.STORAGE.SIZE 
DS=LINK.STORAGE 
DS=LINK.GET 
DS==LINK.GET 
DS=LINK.PUT 
DS==LINK.PUT 
DS-LINK.CREATE 
DS-LINK.SORT.INHIBITED 
DS-LINK.PUT.SORT.INHIBITED 
DS-LINK.SORT.RESIDUE 
DS-LINK.PUT.SORT.RESIDUE 
DS-LINK.COLOUR 
DS-LINK.UNIFIERS 
DS-LINK.PUTUNIFIERS 
DS-LINK.NOUNIFIERS 
DS-LINK.UNIFIER 
DS-LINK.RULE 
DS-LINK.REMOVE.UNIFIER 
DS-LINK.LABEL 
DS-LINK.MARK 
DS-LINK.IS.MARKED 
DS-LINK.NEGPAR 
DS-LINK.NEGLITNO 
DS-LINK.NEGFCT 
DS-LINK.DEMODULATION.IS 
DS-LINK.DEMODULATION.SET 
DS-LINK.NEGTERM 
DS-LINK.NEGLIT 
DS-LINK.POSPAR 
DS-LINK.POSLITNO 
DS-LINK.POSFCT 
DS-LINK.RESULT 
DS-LINK.SELECTION.INFO 
DS-LINK.RESULT.VARIABLES 
DS-LINK.PUT.RESULT 
DS-LINK.PUT.SELECTION.INFO 
DS-LINK.PUT.RESULT.VARIABLES 
DS-LINK.POSTERM 
DS-LINK.POSLIT 
DS-LINK.OTHERPAR 
DS-LINK.OTHERLITNO 
DS-LINK.CONNECT 
DS-LINK.DISCONNECT 
DS-LINK.DEPTH 
DS-LINK.NOLIT 
DS-LINK.IS 
DS-LINK.DELETE 
DS-LINK.COLOURS.WITH 
DS-LINK.COLOURS.FOR 
DS-LINK.SIDE 
DS-LINK.THISLITNO 
DS-LINK.THISFCT 
DS-LINK.OTHERFCT 
DS-LINK.THISSIDE 
DS-LINK.OTHERSIDE 
DS-LINK.FUNCTIONSYMBOLS 
DS=LINK.GETCOLOUR 
DS=LINK.IS 
DS=LINK.STORAGE.SIZE 
DS=LINK.COMPUTE.DIRECTION 
DS*DUMMY.ATOM 
DS*EQUALITY.SYMBOLS 
DS-RESET 
DS-TYPE 
DS-GET.TYPE 
DS-PNAME 
DS-UNI.CREATES.VARIABLES 
DS-SAVE 
DS=FIND.VARIABLES 
DS=TERM.FUNCTIONSYMBOL 
DS=TERM.VAR.OCCUR 
;;; Reading source file "prog/ds/datastructure.lisp"
;;; While compiling DS=RULE.SHORTEN.OTHERSIDE
;;; Warning: Variable IGNORE is bound but not referenced
;;; Warning: Variable IGNORE is bound but not referenced
;;; Writing binary file "prog/ds/datastructure.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UNI-LITERAL.SORT.IS was referenced by DS-LINK.CREATE
;;;          UNI-LITERAL.SORT.RESIDUE was referenced by DS-LINK.CREATE
;;;          UNI-LITERAL.SORT.UNIFIER was referenced by DS-LINK.CREATE
;;; Loading binary file "prog/ds/datastructure.sbin"
;;; Warning: Defconstant is called again for the constant DS*CLAUSE.LITERAL.CELLS. Old value is retained.
;;; Loading source file "prog/uni/uni-commutative.lisp"
;;; Warning: File "prog/uni/uni-commutative.lisp" does not begin with IN-PACKAGE.  Loading into package "MARKGRAF-KARL"

COMM=UNIFY 
COMM=UNIFY.TERMS 
COMM=UNIFY.TERMLISTS 
COMM=INSERT 
COMM=INSERT.COMP 
;;; Reading source file "prog/uni/uni-commutative.lisp"
;;; Warning: File does not begin with IN-PACKAGE.  Compiling in package "MARKGRAF-KARL"
;;; Writing binary file "prog/uni/uni-commutative.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UNI=VARIABLE.IS was referenced by COMM=UNIFY.TERMS,
;;;             COMM=INSERT.COMP
;;;          UNI=POLY.X.WITH.T was referenced by COMM=UNIFY.TERMS
;;;          UNI=CONSTANT.IS was referenced by COMM=UNIFY.TERMS
;;;          UNI=UNIFY.TERMLISTS was referenced by COMM=UNIFY.TERMS
;;; Loading binary file "prog/uni/uni-commutative.sbin"
;;; Loading source file "prog/uni/ac-match.lisp"

#<Package "TH-AC-MKRP" 160373E> 
*CONTROLL-BLOCK* 
*AC-MATCH-NEC* 
*AC-ERG-SUBST* 
*ALLE-LOESUNGEN* 
E-COMPL*AC-FUNCTIONS 
*AC-TIME* 
*HELP-ACTIME* 
*AC-MATCH-COUNT* 
*FAIL-MATCHES* 
*NORMALISIERE-TIME* 
*HELP-NORMTIME* 
*SINGLE-MATCH-TIME* 
*SINGLE-MATCH-HELP* 
*GREAT-SINGLE-MATCH-TIME* 
AC-FUNCTION 
GIVE-FUNCTOR-FROM-GL 
GIVE-VARLIST-FROM-GL 
GIVE-ARGLIST-FROM-GL 
CREATE-GL-ENTRY 
GET-VARNAME 
GET-COMPOSITION-POSSIBLE 
GET-ARGUMENTLIST 
GET-FUNCTOR 
CREATE-VARENTRY 
SET-COMPOSITION-IMPOSSIBLE 
SET-ARGUMENTLIST 
CREATE-COMPOSS-ARG 
GET-COMPOSS-ARG 
GET-COMPOSS-COUNT 
GET-COMPOSS-ACTUAL 
SET-COMPOSS-ACTUAL 
SET-COMPOSS-COUNT 
CREATE-NORMAL-ARGLIST 
AC-NORMALFORM 
MERGE-SORT 
TERMEQUAL 
TERMGREATER 
CHECK-GREATER-SET 
CHECK-GREATER-LIST 
AC-MATCH 
MATCH-ARG 
AC-MATCH-LIST 
AC-MATCH-SET 
ADD-GLEICHUNG 
GLEICHUNGSEINTRAG 
MAKE-NF-TO-ARG 
MAKE-SET-TO-ARG 
NEXT-STATEMENT 
SUBSTITUTED 
CHECK-FOR-RIGHT-SUBST 
CHECK-SUBST-RECH-POSSIBLE 
STREICHE-SUBST 
STREICHE-ARGUMENTE 
LOESCHE-SUBST-AUS-GL 
CHECK-POSSIBLE-SOLUTIONS 
LOOK-FOR-VARSOLUTIONS 
FILTER-VAR-SOLUTIONS 
COMBINE-ARGS-AND-FILTER 
FILTER-MIN 
CHANGE-COMP-TO-NORMAL 
NEXT-COMPOSS-ARGUMENT 
READ-VAR-SUBST 
NEXT-NORMAL-ARGUMENT 
CREATE-VAR-SOL-ENTRY 
INSERT-VARENTRY 
CHECK-FOR-ENTHALTEN 
CHECK-FOR-ENTHALTEN-COMPOSS 
LOESE-GLEICHUNGSSYS-NORMAL 
LOESE-GLEICHUNGSSYS-ALLE 
PROBIERE-LOESUNGEN-NORMAL 
PROBIERE-LOESUNGEN-ALLE 
CHECK-FOR-NOT-SUBST 
FIND-GOOD-ORDER 
CHECK-FOR-LINEAR-TERMS 
LOESE-LINEAR-TERMS 
MINIMAL-COUNT-OF-ARGS 
COUNT-MINIMAL-ARGS 
RETTE-LOESUNG 
AC-MATCH-ALLE 
GET-COMPOSS-VALUE 
SU=AC-MATCH 
CONVERT-SUBST-TO-ADLER 
MATCH-STATISTIK 
SCHALTE-NORMAL 
#<Interpreted-Function (NAMED-LAMBDA PROBIERE-LOESUNGEN-NORMAL (VAR-LIST-OF-SOLUTIONS GL-LIST) (BLOCK PROBIERE-LOESUNGEN-NORMAL (IF (NULL VAR-LIST-OF-SOLUTIONS) (IF (NULL GL-LIST) (QUOTE T) (QUOTE NIL)) (IF (NULL GL-LIST) (CHECK-FOR-NOT-SUBST VAR-LIST-OF-SOLUTIONS) (LET ((ARGLIST (GET-ARGUMENTLIST (CAR VAR-LIST-OF-SOLUTIONS))) (VARNAME (GET-VARNAME (CAR VAR-LIST-OF-SOLUTIONS))) (FUNCTOR (GET-FUNCTOR (CAR VAR-LIST-OF-SOLUTIONS))) (COMPOSS-POSSIBLE (GET-COMPOSITION-POSSIBLE (CAR VAR-LIST-OF-SOLUTIONS)))) (IF (SUBSTITUTED VARNAME) (PROBIERE-LOESUNGEN (CDR VAR-LIST-OF-SOLUTIONS) GL-LIST) (LET ((SUBST-LIST *AC-ERG-SUBST*) (FOUND (QUOTE NIL)) (SUCHFUNCTION (IF (EQ COMPOSS-POSSIBLE (QUOTE Y)) (QUOTE NEXT-COMPOSS-ARGUMENT) (PROGN (RPLACA ARGLIST (CDR ARGLIST)) (QUOTE NEXT-NORMAL-ARGUMENT))))) (DO ((NEW-SUBST (FUNCALL (SYMBOL-FUNCTION SUCHFUNCTION) ARGLIST FUNCTOR) (FUNCALL (SYMBOL-FUNCTION SUCHFUNCTION) ARGLIST FUNCTOR))) ((OR (NULL NEW-SUBST) FOUND) (IF FOUND (QUOTE T) (QUOTE NIL))) (LET ((NEW-GL-LIST (LOESCHE-SUBST-AUS-GL (CONS (LIST VARNAME NEW-SUBST) (QUOTE NIL)) GL-LIST))) (IF (EQ NEW-GL-LIST (QUOTE KEINMATCH)) (SETQ *AC-ERG-SUBST* SUBST-LIST) (PROGN (SETQ *AC-ERG-SUBST* (APPEND (CONS (LIST VARNAME NEW-SUBST) (QUOTE NIL)) *AC-ERG-SUBST*)) (IF (PROBIERE-LOESUNGEN (CDR VAR-LIST-OF-SOLUTIONS) NEW-GL-LIST) (SETQ FOUND (QUOTE T)) (SETQ *AC-ERG-SUBST* SUBST-LIST))))))))))))) 27B621E> 
;;; Reading source file "prog/uni/ac-match.lisp"
;;; GC: 173102 words [692408 bytes] of dynamic storage in use.
;;; 498640 words [1994560 bytes] of free storage available before a GC.
;;; 1170382 words [4681528 bytes] of free storage available if GC is disabled.
;;; While compiling NEXT-NORMAL-ARGUMENT
;;; Warning: Variable FUNCTOR is bound but not referenced
;;; Writing binary file "prog/uni/ac-match.sbin"
;;; Loading binary file "prog/uni/ac-match.sbin"
;;; Loading source file "prog/uni/uni-thu.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
THU=TYPE 
THU-TERMS 
THU-TERMLISTS 
;;; Reading source file "prog/uni/uni-thu.lisp"
;;; Writing binary file "prog/uni/uni-thu.sbin"
;;; Loading binary file "prog/uni/uni-thu.sbin"
;;; Loading source file "prog/uni/unification.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
UNI*VARIABLES.REGARDED.AS.CONSTANTS 
UNI*VARIABLES.DECLARED.AS.CONSTANTS 
UNI*BINDINGFLAG 
UNI*BUFFER.STACK 
UNI*CONSTANTIFY.BUFFER 
UNI-RESET 
UNI-UNIFY.TERMS 
UNI-UNIFY.TERMLISTS 
UNI-UNIFY.ATOMS 
UNI-UNIFY.QUICK.TEST 
UNI-UNIFY.LIST.OF.MIXED.TERMLISTS 
UNI-UNIFY.MIXED.TERMLIST 
UNI=WEAK.UNION.OF.SUBSTITUTIONLISTS 
UNI-UNIFY.TERMLISTS.WITH.RULE 
UNI=REMOVE.SUBSTITUTIONS 
UNI-UNIFY.UNIFIER 
UNI-EQUAL.SUBSTS 
UNI-UNIFY.AWAY 
UNI=UNIFY.TERMS 
UNI=UNIFY.TERMLISTS 
UNI=UNIFY.ATOMS 
UNI=UNIFY.QUICK.TEST 
UNI=UNIFY.MIXED.TERMLIST 
UNI=UNIFY.TERMLISTS.WITH.RULE 
UNI=UNMATCHABLE 
UNI-UNIFY1.TERMS 
UNI-UNIFY1.TERMLISTS 
UNI-UNIFY1.ATOMS 
UNI-MATCHABLE 
UNI-UNIFIER.IS.MATCHER 
UNI-UNIFIER.CANBE.MATCHER 
UNI-UNIFIER.BECOMES.MATCHER 
UNI=MATCH.TERMS 
UNI=MATCH.TERMLISTS 
UNI=MATCH.WITH.BUFFER 
UNI=MAKE.MATCHER 
UNI-EQUAL.TERMS 
UNI-EQUAL.TERMLISTS 
UNI-EQUAL.ATOMS 
UNI=EQUAL.TERMS 
UNI=EQUAL.TERMLISTS 
UNI-MERGE.SUBSTITUTIONS 
UNI-MERGE.SUBSTITUTIONLISTS 
UNI-MERGE.LIST.OF.SUBSTITUTIONLISTS 
UNI-MERGE.BINDING.WITH.SUBSTITUTION 
UNI-MERGE1.SUBSTITUTIONS 
UNI-MERGE1.SUBSTITUTIONLISTS 
UNI-MERGE1.LIST.OF.SUBSTITUTIONLISTS 
UNI-MERGE.MATCHERS 
UNI-MERGE.MATCHERLISTS 
UNI-MERGE.LIST.OF.MATCHERLISTS.FIT.ON.SORTS 
UNI-MERGE.LIST.OF.MATCHERLISTS 
UNI-INSTANCE.IS 
UNI-BINDING.IS.INSTANCE.OF 
UNI-WEAK.INSTANCE 
UNI=MERGE.SUBSTITUTIONS 
UNI=MERGE.SUBSTITUTIONLISTS 
UNI=MERGE.LIST.OF.SUBSTITUTIONLISTS 
UNI=MERGE.MATCHERS 
UNI=MERGE.MATCHERLISTS 
UNI=INSTANCE.IS 
UNI=BINDING.IS.INSTANCE.OF 
UNI=WEAK.INSTANCE 
UNI=POLY.VARIABLE.TERM.R 
UNI=POLY.TERM.SORT 
UNI=POLY.WEAKENING 
UNI=POLY.SUBST.LESS 
UNI=VARIABLE.SORT 
UNI=POLY.X.WITH.T 
UNI=POLY.SORT.WITH.T 
UNI-APPLY.SUBSTITUTION.TO.LITLIST 
UNI-APPLY.SUBSTITUTION 
UNI-UNION.OF.SUBSTITUTIONLISTS 
UNI-LITERAL.SORT.UNIFIER 
UNI-LITERAL.SORT.RESIDUE 
UNI-LITERAL.SORT.IS 
UNI-FIT.ON.LITERAL.SORT 
UNI-FIT.ON.SORT 
UNI-UNIFIER.IS.VARIABLE.RENAMING 
UNI-SWITCH 
UNI-RENAME 
UNI-REMOVE.INSTANCES 
UNI-REMOVE.COMPONENTS 
UNI-CONSTANTIFY 
UNI-DECLARE.VARIABLES.AS.CONSTANTS 
UNI-CLEAR.VARIABLES.AS.CONSTANTS 
UNI-UNIFIER.DOMAIN 
UNI-UNIFIER.CODOMAIN 
UNI-SET.BINDINGS.OF.SUBSTITUTION 
UNI-RESET.BINDINGS.OF.SUBSTITUTION 
UNI=UNION.OF.SUBSTITUTIONLISTS 
UNI=SWITCH 
UNI=RENAME 
UNI=REMOVE.INSTANCES 
UNI=REMOVE.COMPONENTS 
UNI=UNIFIER.DOMAIN 
UNI=APPLY.SUBSTITUTION 
UNI=SUBSTITUTE 
UNI=APPLY.SUBSTITUTION.TO.SUBSTITUTION 
UNI=FIND.VARIABLES 
UNI=COMPOSITION.OF.SUBSTITUTIONS 
UNI=COMPOSITION.OF.SUBSTITUTION.AND.SUBSTITUTIONLIST 
UNI=COPY 
UNI=CONSTANT.IS 
UNI=VARIABLE.IS 
UNI=GET.BINDING 
UNI=SET.BINDINGS 
UNI=UNBIND 
UNI=RESET.BINDINGS 
UNI-INSERT.BINDINGS.IN 
UNI=INSERT.BINDINGS.IN 
UNI-DELETE.ALL.BINDINGS 
UNI-SHOW.ALL.BINDINGS 
UNI=TEMP.FIND.VARIABLES 
UNI-EQUAL 
UNI-RESTRICT 
;;; Reading source file "prog/uni/unification.lisp"
;;; Writing binary file "prog/uni/unification.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UPP-INIT was referenced by UNI-RESET
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by UNI-RESET
;;;          UPR-MATCH.SUBSTITUTION was referenced by
;;;             UNI-MERGE.LIST.OF.MATCHERLISTS.FIT.ON.SORTS
;;;          UPR-UNIFY.SUBSTITUTION was referenced by
;;;             UNI-FIT.ON.LITERAL.SORT
;;; Loading binary file "prog/uni/unification.sbin"
;;; Loading source file "prog/norm/normalization.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
NORM*LITERAL.INDEX 
NORM=SET.INDEX 
NORM-NORMALIZATION 
NORM-NEW.FORMULA 
NORM-NEXT.SPLITPART 
NORM-SEVERAL.SPLITPARTS? 
NORM-MORE.SPLITPARTS? 
NORM-PRENEX.FORM 
NORM-RESET 
NORM=NORMALIZE.1 
NORM=NORMALIZE.2 
NORM=MOVE.QUANTIFIERS.INSIDE 
NORM=MOVE.ALL.INSIDE 
NORM=MOVE.EX.INSIDE 
NORM=MOVE.QUANTIFIERS.OUTSIDE 
NORM=EXTRACT.PREFIX.MATRIX 
NORM=MARK.SPLIT 
NORM=REPLACE.EQV 
NORM=REPLACE.IMPL 
NORM=MOVE.NEGATIONS.TO.LITERALS 
NORM=SKOLEMIZE 
NORM=SPLIT.LAZY 
NORM=PREPARE.SPLIT.LAZY 
NORM=PREPARE.SPLIT 
NORM=SPLIT 
NORM=REMOVE.QUANTIFIERS 
NORM=TRANSFORM.TO.PSEUDO.CNF 
NORM=MULTIPLY.TO.CNF 
NORM=TRANSFORM.TO.PSEUDO.DNF 
NORM=MULTIPLY.TO.DNF 
NORM=MULTIPLY.TO.DNF1 
NORM=FLATTEN.CLAUSELIST 
NORM=FLATTEN.LITLIST 
NORM-COPY 
NORM=COPY 
NORM=VARIABLE.OCCURS.IN 
NORM=REPLACE.VARIABLE 
NORM=REPLACE.VARIABLE.IN.TERMLIST 
NORM=CREATE.FORMULA 
NORM-CREATE.FORMULA 
NORM=OP 
NORM=PUT=OP 
NORM=LEFT 
NORM=PUT=LEFT 
NORM=RIGHT 
NORM=PUT=RIGHT 
NORM=PUT=INDEX 
NORM*FUNCTION.COUNTER 
NORM*CONSTANT.COUNTER 
NORM*MAX.SPLIT.DEPTH 
NORM*EXPRESSION 
NORM*EXPRESSION.LENGTH 
NORM*EXPRESSION.LENGTH.ORIGINAL 
NORM*FILE.VERSION 
NORM=DROP.VARIABLE 
NORM=NEW.VARIABLE 
NORM=NEW.TERM 
;;; Reading source file "prog/norm/normalization.lisp"
;;; Writing binary file "prog/norm/normalization.sbin"
;;; Loading binary file "prog/norm/normalization.sbin"
;;; Loading source file "prog/norm/presimplification.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PSIM-PRESIMPLIFICATION 
PSIM-APPLY.DEFINITIONS 
PSIM=DEFINITION 
PSIM=DEFINITION.IS 
PSIM=REPLACE 
PSIM=REMOVE.PROPERTIES 
PSIM=CREATE.TRUTH.VALUES 
PSIM=SIMPLIFY.TRUTH.VALUES 
PSIM=NORMALIZE.SIGN 
PSIM=SIMPLIFY.TRUTH.VALUES.NOT 
PSIM=SIMPLIFY.TRUTH.VALUES.AND 
PSIM=SIMPLIFY.TRUTH.VALUES.OR 
PSIM=SIMPLIFY.TRUTH.VALUES.IMPL 
PSIM=SIMPLIFY.TRUTH.VALUES.EQV 
PSIM=SIMPLIFY.TRUTH.VALUES.QUANTIFIER 
PSIM=OP 
PSIM=PUT=OP 
PSIM=LEFT 
PSIM=PUT=LEFT 
PSIM=RIGHT 
PSIM=PUT=RIGHT 
;;; Reading source file "prog/norm/presimplification.lisp"
;;; Writing binary file "prog/norm/presimplification.sbin"
;;; Loading binary file "prog/norm/presimplification.sbin"
;;; Loading source file "prog/cg/connectiongraph.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CG*COMMONS.TO.SAVE 
CG*RECOLOUR 
CG*OBJECTCLASSES 
CG*SAVESTACK 
CG*GRAPH.REGISTER 
CG-CREATE.EMPTY.GRAPH 
CG-DISJOINTIFY 
CG-FIX 
CG-PUSH 
CG-POP 
CG-STORE.GRAPH.REGISTER 
CG-RECALL.GRAPH.REGISTER 
CG-VIRTUAL.GRAPH 
CG=SAVE 
CG=SAVE.STACK 
CG=INSERT.EPSILON 
CG=REMOVE.EPSILON 
CG=REPLACE.EPSILON 
CG-CLAUSES 
CG-#CLAUSES 
CG-INSERT.CLAUSE 
CG-CLAUSE_ANCESTOR.LITERALS 
CG-CLAUSE_DESCENDANT.LITERALS 
CG-CLAUSE_CREATOR.UNIFIER 
CG-REMOVE.CLAUSE 
CG-REPLACE.LITERAL 
CG-CLAUSE.CHANGED.P 
CG-REMOVE.LITERAL 
CG=MERGE.RELATIVES 
CG=RECALCULATE.LITNOS 
CG=CLAUSE_PUT.DESCENDANT.LITERALS 
CG-LINKS 
CG-#LINKS 
CG-INSERT.LINK 
CG-LINK_ANCESTOR.LINKS 
CG-LINK_DESCENDANT.LINKS 
CG-REMOVE.LINK 
CG-INSERT.UNIFIER 
CG-REMOVE.UNIFIER 
CG-INHIBIT.UNIFIER 
CG=INSERT.LINK 
CG=INSERT.UNIFIER 
CG=REMOVE.LINK 
CG=REMOVE.UNIFIER 
CG=LINK_ANCESTOR.LINKS 
CG=REPR_EMPTY.OBJECTLIST 
CG=REPR_RESET 
CG=REPR_INSERT 
CG=REPR_REMOVE 
CG=REPR_LIST 
CG=REPR_LENGTH 
CG=REPR_SAVE 
CG=REPR_INIT 
CG=REPR_GET 
CG=REPR_PUT 
CG*CHANGE.QUEUE.LITERALS 
CG-CHANGE.QUEUE_APPEND 
CG-CHANGE.QUEUE_TOP 
CG-CHANGE.QUEUE_POP 
CG-CHANGE.QUEUE 
CG*POSITION 
CG-DUMP 
CG==DUMP 
CG=DUMP 
CG-DUMP.SHORT 
CG==DUMP.SHORT 
CG=DUMP.SHORT 
CG=PR_CLAUSES 
CG=PR_CLAUSE 
CG=PR_LITERAL 
CG=PR_CLAUSE.SHORT 
CG=PR_LIST.LITERALS 
CG=PR_LINKS 
CG=PR_LINK 
CG=PR_VARIABLES 
CG=PR_LIST 
;;; Reading source file "prog/cg/connectiongraph.lisp"
;;; Writing binary file "prog/cg/connectiongraph.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by
;;;             CG=INSERT.EPSILON, CG=REPLACE.EPSILON
;;;          UPP-EPSILON.LITERALS.DELETE was referenced by
;;;             CG=REMOVE.EPSILON, CG=REPLACE.EPSILON
;;;          NAR-NARROW.INFO.PUT was referenced by CG=REMOVE.UNIFIER
;;;          NAR-NARROW.INFO was referenced by CG=REMOVE.UNIFIER
;;; Loading binary file "prog/cg/connectiongraph.sbin"
;;; Loading source file "prog/prot/prot-datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PDS-RESET 
PDS-CLAUSE.PROPERTY 
PDS-CLAUSE.ADD.PROPERTY 
PDS-ALLOCATE.MEMORY.ADDRESS 
PDS-PNAME 
PDS-PUT.PROTOCOL.TYPE 
PDS-PUT.COMMENT 
PDS-PUT.PROOF.VERSION 
PDS-PUT.RUN.DATE 
PDS-PUT.OPTIONS 
PDS-PUT.INDICES 
PDS*PROTOCOL.TYPE 
PDS*COMMENT 
PDS*PROOF.VERSION 
PDS*RUN.DATE 
PDS*OPTIONS 
PDS*INDICES 
PDS-GET.PROTOCOL.TYPE 
PDS-GET.COMMENT 
PDS-GET.PROOF.VERSION 
PDS-GET.RUN.DATE 
PDS-GET.OPTIONS 
PDS-GET.INDICES 
PDS-PUT.AXIOMS.INFIX 
PDS-PUT.THEOREMS.INFIX 
PDS-PUT.AXIOMS.PREFIX 
PDS-PUT.THEOREMS.PREFIX 
PDS-ADD.AXIOMS 
PDS-ADD.AX.OPERATION 
PDS-ADD.AX.STATISTICS 
PDS-PUT.FINAL.AXIOM.CLAUSES 
PDS-PUT.AXIOMS.TIME 
PDS-PUT.AX.SYMBOLS 
PDS*AX.INFIX 
PDS*TH.INFIX 
PDS*AX.PREFIX 
PDS*TH.PREFIX 
PDS*AXIOMS.GRAPH 
PDS*AX.OPERATIONS 
PDS*AX.STATISTICS 
PDS*FINAL.AXIOM.CLAUSES 
PDS*AXIOMS.TIME 
PDS*AX.SYMBOLS 
PDS-GET.AXIOMS.INFIX 
PDS-GET.THEOREMS.INFIX 
PDS-GET.AXIOMS.PREFIX 
PDS-GET.THEOREMS.PREFIX 
PDS-GET.AXIOMS 
PDS-GET.AX.OPERATIONS 
PDS-GET.AX.STATISTICS 
PDS-GET.FINAL.AXIOM.CLAUSES 
PDS-GET.AXIOMS.TIME 
PDS-GET.AX.SYMBOLS 
PDS-ADD.PROOF.PART 
PDS*PROOF.PARTS 
PDS-ALL.PROOF.PARTS 
PDS-PROOF.PART.CREATE 
PDS=PROOF.PART.STORAGE 
PDS=PROOF.PART.PUT.IDENTIFIER 
PDS=PROOF.PART.PUT.CHANGED.OPTIONS 
PDS=PROOF.PART.PUT.INITIAL.CLAUSES 
PDS=PROOF.PART.PUT.OPERATIONS 
PDS=PROOF.PART.PUT.STATISTICS.BLOCKS 
PDS=PROOF.PART.PUT.TOTAL.STATISTICS 
PDS=PROOF.PART.PUT.FINAL.CLAUSES 
PDS=PROOF.PART.PUT.RESULT 
PDS=PROOF.PART.PUT.REASON 
PDS=PROOF.PART.PUT.TIME 
PDS=PROOF.PART.PUT.USED.CLAUSES 
PDS=PROOF.PART.PUT.PROOF.TREE 
PDS=PROOF.PART.PUT.SYMBOLS 
PDS=PROOF.PART.PUT.O.N.C.ADDRESSES 
PDS-PROOF.PART.IDENTIFIER 
PDS-PROOF.PART.CHANGED.OPTIONS 
PDS-PROOF.PART.INITIAL.CLAUSES 
PDS-PROOF.PART.OPERATIONS 
PDS-PROOF.PART.STATISTICS.BLOCKS 
PDS-PROOF.PART.TOTAL.STATISTICS 
PDS-PROOF.PART.FINAL.CLAUSES 
PDS-PROOF.PART.RESULT 
PDS-PROOF.PART.REASON 
PDS-PROOF.PART.TIME 
PDS-PROOF.PART.PROOF.TREE 
PDS-PROOF.PART.SYMBOLS 
PDS-PROOF.PART.O.N.C.ADDRESSES 
PDS-ADD.SPLITPART 
PDS*SPLITPARTS 
PDS-ALL.SPLITPARTS 
PDS-SPLITPART.CREATE 
PDS=SPLITPART.STORAGE 
PDS=SPLITPART.PUT.AXIOMS 
PDS=SPLITPART.PUT.THEOREMS 
PDS=SPLITPART.PUT.INITIAL.GRAPH 
PDS=SPLITPART.PUT.CHANGED.OPTIONS 
PDS=SPLITPART.PUT.OPERATIONS 
PDS=SPLITPART.PUT.RESULT 
PDS=SPLITPART.PUT.REASON 
PDS=SPLITPART.PUT.USED.CLAUSE.LIST 
PDS=SPLITPART.PUT.PROOF.TREE 
PDS=SPLITPART.PUT.STATISTICS 
PDS=SPLITPART.PUT.TOTAL.STATISTICS 
PDS=SPLITPART.PUT.SYMBOLS 
PDS=SPLITPART.PUT.IDENTIFIER 
PDS-SPLITPART.INSERT.TOTAL.STATISTICS 
PDS-SPLITPART.AXIOMS 
PDS-SPLITPART.THEOREMS 
PDS-SPLITPART.INITIAL.GRAPH 
PDS-SPLITPART.CHANGED.OPTIONS 
PDS-SPLITPART.OPERATIONS 
PDS-SPLITPART.RESULT 
PDS-SPLITPART.REASON 
PDS-SPLITPART.USED.CLAUSE.LIST 
PDS-SPLITPART.STATISTICS 
PDS-SPLITPART.TOTAL.STATISTICS 
PDS-SPLITPART.SYMBOLS 
PDS-SPLITPART.IDENTIFIER 
PDS-OPERATION.CREATE 
PDS=OPERATION.STORAGE 
PDS=OPERATION.PUT.CLAUSES 
PDS=OPERATION.PUT.TYPE 
PDS=OPERATION.PUT.PARENTS 
PDS=OPERATION.PUT.USE 
PDS=OPERATION.PUT.DESCRIPTORS 
PDS-OPERATION.INSERT.USE 
PDS-OPERATION.CLAUSES 
PDS-OPERATION.TYPE 
PDS-OPERATION.PARENTS 
PDS-OPERATION.USE 
PDS-OPERATION.UNIFIER 
PDS-OPERATION.RULE 
PDS-OPERATION.POS.EQ.PAR 
PDS-OPERATION.LITNO.1 
PDS-OPERATION.POS.EQ.LITNO 
PDS-OPERATION.LITNO.2 
PDS-OPERATION.NEG.PAR 
PDS-OPERATION.NEG.LITNO 
PDS-OPERATION.FCT 
PDS-CLAUSE.CREATE 
PDS=CLAUSE.STORAGE 
PDS=CLAUSE.PUT.PNAME 
PDS=CLAUSE.PUT.PARENTS 
PDS=CLAUSE.PUT.SORTS.VARIABLES 
PDS=CLAUSE.PUT.LITERALS 
PDS=CLAUSE.PUT.USE 
PDS-CLAUSE.ADD.PARENT 
PDS-CLAUSE.ADD.USE 
PDS-CLAUSE.IS 
PDS-CLAUSE.PNAME 
PDS-CLAUSE.PARENTS 
PDS-CLAUSE.SORTS.VARIABLES 
PDS-CLAUSE.LITERALS 
PDS-CLAUSE.USE 
;;; Reading source file "prog/prot/prot-datastructure.lisp"
;;; Writing binary file "prog/prot/prot-datastructure.sbin"
;;; Loading binary file "prog/prot/prot-datastructure.sbin"
;;; Loading source file "prog/prot/prot-print.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPP*AXIOMS.FLAG 
PPP*INFIX.FLAG 
PPP*PREFIX.FLAG 
PPP*DIRECT.PROOF 
PPP*INDENTATION 
PPP*LINE 
PPP*FIRST.LINE 
PPP*LAST.LINE 
PPP*REAL.#.OF.LINES 
PPP-PRINT.PROTOCOL 
PPP=TTY.PROTOCOL 
PPP=DEFINE.COMMON.VARIABLES 
PPP*USED.SIGN 
PPP*IMPLICATION.SIGN 
PPP*CONJUNCTION.SIGN 
PPP=PRINT.HEAD 
PPP=PRINT.HEAD.LINE 
PPP=PRINT.OPTIONS 
PPP=PRINT.INFIX.FORM 
PPP=PRINT.PREFIX.FORM 
PPP=PRINT.PREFIX.FORMULA 
PPP=PRINT.SYMBOLTABLE 
PPP*OLD.NEW.SYMBOL.ADDRESSES 
PPP=RECONSTRUCT.SYMBOLS 
PPP=PRINT.AXIOM.CLAUSES 
PPP=PRINT.AX.OPERATIONS 
PPP=PRINT.SPLITTED.THEOREMS 
PPP=PRINT.INITIAL.OPERATIONS 
PPP=PROOF.PARTS.WITH.OPERATIONS 
PPP=PRINT.OPERATIONS 
PPP=PRINT.SPLITPART 
PPP=OPERATION.PREMISE 
PPP=RULE 
PPP=LONGEST.OPERATION.PREMISE 
PPP=LENGTH.OF.OPERATION.PREMISE 
PPP=LONGEST.CLAUSE.PNAME 
PPP=PRINT.OPERATION 
PPP=PRINT.TOTAL.RESULT 
PPP=PRINT.TOTAL.STATISTICS 
PPP*TOTAL.VARIABLE.NUMBER 
PPP-PRINT.CLAUSE 
PPP=PRINT.CLAUSE 
PPP=RENAME.VARIABLES 
PPP=RENAME.LITERALS 
PPP*UNIVERSAL.QUANTIFIER 
PPP=PRINT.CLAUSE.QUANTIFIERS 
PPP=TERM 
PPP=REPLACE.BY.PNAME 
PPP*DIFFERENT.VARIABLES.FLAG 
PPP=PRINT.TO.RIGHT.END 
PPP=TERPRI 
PPP=TAB 
PPP=PAGE 
PPP=PRINT.TEXT 
PPP=PRINT.WORD 
PPP=PRINT.WITH.UNDERSCORE 
PPP=APPLY.SUBSTITUTION 
;;; Reading source file "prog/prot/prot-print.lisp"
;;; Writing binary file "prog/prot/prot-print.sbin"
;;; Warning: The following function is not known to be defined:
;;;          PPP=LATEX.PROTOCOL was referenced by PPP-PRINT.PROTOCOL
;;; Loading binary file "prog/prot/prot-print.sbin"
;;; Loading source file "prog/prot/prot-latex.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPP*L_AXIOMS.FLAG 
PPP*L_INFIX.FLAG 
PPP*L_PREFIX.FLAG 
PPP*L_DIRECT.PROOF 
PPP*L_INDENTATION 
PPP*L_LINE 
PPP*L_FIRST.LINE 
PPP*L_LAST.LINE 
PPP*L_REAL.#.OF.LINES 
PPP=LATEX.PROTOCOL 
PPP=L_DEFINE.COMMON.VARIABLES 
PPP*L_USED.SIGN 
PPP*L_IMPLICATION.SIGN 
PPP*L_CONJUNCTION.SIGN 
PPP=L_PRINT.HEAD 
PPP=L_PRINT.HEAD.LINE 
PPP=L_PRINT.OPTIONS 
PPP=L_PRINT.INFIX.FORM 
PPP=L_PRINT.PREFIX.FORM 
PPP=L_PRINT.PREFIX.FORMULA 
PPP=L_PRINT.SYMBOLTABLE 
PPP*L_OLD.NEW.SYMBOL.ADDRESSES 
PPP=L_RECONSTRUCT.SYMBOLS 
PPP=L_PRINT.AXIOM.CLAUSES 
PPP=L_PRINT.AX.OPERATIONS 
PPP=L_PRINT.SPLITTED.THEOREMS 
PPP=L_PRINT.INITIAL.OPERATIONS 
PPP=L_PROOF.PARTS.WITH.OPERATIONS 
PPP=L_PRINT.OPERATIONS 
PPP=L_PRINT.SPLITPART 
PPP=L_OPERATION.PREMISE 
PPP=L_RULE 
PPP=L_LONGEST.OPERATION.PREMISE 
PPP=L_LENGTH.OF.OPERATION.PREMISE 
PPP=L_LONGEST.CLAUSE.PNAME 
PPP=L_PRINT.OPERATION 
PPP=L_PRINT.TOTAL.RESULT 
PPP=L_PRINT.TOTAL.STATISTICS 
PPP*L_TOTAL.VARIABLE.NUMBER 
PPP=L_PRINT.CLAUSE 
PPP=L_RENAME.VARIABLES 
PPP=L_RENAME.LITERALS 
PPP*L_UNIVERSAL.QUANTIFIER 
PPP=L_PRINT.CLAUSE.QUANTIFIERS 
PPP=L_TERM 
PPP=L_REPLACE.BY.PNAME 
PPP*L_DIFFERENT.VARIABLES.FLAG 
PPP=L_PRINT.TO.RIGHT.END 
PPP=L_TERPRI 
PPP=L_TAB 
PPP=L_PAGE 
PPP=L_PRINT.TEXT 
PPP=L_PRINT.WORD 
PPP=L_PRINT.WITH.UNDERSCORE 
PPP=L_APPLY.SUBSTITUTION 
;;; Reading source file "prog/prot/prot-latex.lisp"
;;; While compiling PPP=L_PRINT.HEAD
;;; Warning: Variable VERSION is bound but not referenced
;;; Warning: Variable DATE is bound but not referenced
;;; Warning: Variable COMMENT is bound but not referenced
;;; While compiling PPP=L_PRINT.AXIOM.CLAUSES
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.SPLITTED.THEOREMS
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.OPERATIONS
;;; Warning: Free variable PPP=L_LONGEST.OPERATION.PREMISE assumed to be special
;;; While compiling PPP=L_PRINT.SPLITPART
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_LONGEST.OPERATION.PREMISE
;;; Warning: PPP=L_LONGEST.OPERATION.PREMISE called by PPP=L_PRINT.OPERATIONS with too many arguments
;;; While compiling PPP=L_PRINT.OPERATION
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.CLAUSE
;;; Warning: Variable COLON.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.WITH.UNDERSCORE
;;; Warning: Variable UNDERSCORE.SIGN is bound but not referenced
;;; Warning: Variable START.POS is bound but not referenced
;;; Writing binary file "prog/prot/prot-latex.sbin"
;;; Loading binary file "prog/prot/prot-latex.sbin"
;;; Loading source file "prog/prot/prot-prepare.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPR-CODE 
PPR*NEW.PNAMES 
PPR*INITIAL.CLAUSE.NUMBER 
PPR*DEDUCED.CLAUSE.NUMBER 
PPR=RESET 
PPR=RESULT.HANDLING 
PPR=AXIOMS.GRAPH 
PPR=PROOF.PART 
PPR*OLD.NEW.CLAUSE.ADDRESSES 
PPR*OLD.NEW.CLAUSE.ADDRESSES.INITIAL 
PPR*AXIOMS.O.N.C.ADDRESSES 
PPR=SPLITPART 
PPR=PRECEDING.IDENTIFIER 
PPR=CHANGED.OPTIONS 
PPR=CONSTRUCT.DEDUCTION.TREE 
PPR=CONSTRUCT.LIST.OF.ANCESTORS 
PPR=MARK.USED.OPERATIONS 
PPR*SPLITTABLE.OPERATIONS 
PPR*LENGTH.OF.CLAUSE.CHANGED 
PPR=OPERATION 
PPR=OPERATION.DESCRIPTION 
PPR=RULE 
PPR*CLAUSE.CHANGED 
PPR*CLAUSE.SYMBOLS 
PPR=CHANGE.UNIFIER 
PPR=SPLIT.REPLACEMENT.OPERATION 
PPR*OLDLITS.NEWLITS 
PPR=BUILD.OLDLITS.NEWLITS 
PPR=RESOLUTION.OPERATION 
PPR=SIMULATE.RESOLUTION 
PPR=SIMULATE.INSTANTIATION 
PPR=UPDATE.OLD.NEW.LITS 
PPR=DOUBLE.LITERAL.OPERATIONS 
PPR=REM.DBL.LIT.EARLIER 
PPR=DOUBLE.LITERAL.OPERATION 
PPR=SIMULATE.DOUBLE.LITERALS 
PPR=ACTUAL.LITERAL 
PPR=ACTUAL.LITNO 
PPR=APPLY.SUBSTITUTION 
PPR=VARS.SORTS.USED 
PPR=IMPORTED.VARS.SORTS 
PPR=CLAUSES 
PPR=CLAUSE 
PPR=CLAUSE.PARENTS 
PPR=CLAUSE.SORTS.VARIABLES 
PPR=ALLOCATE.CLAUSE.PNAME 
PPR*DESTRUCTIVE.OPERATIONS 
PPR*INITIAL.CLAUSE.INDICATORS 
PPR=GET.CLAUSE.PNAME 
PPR=GET.CLAUSE.ADDRESS 
PPR=GET.CLAUSE.PARENTS 
PPR=GET.CLAUSE.VARIABLES.SORTS 
PPR=GET.CLAUSE.LITERALS 
PPR=GET.NEW.CLAUSE.ADDRESS 
PPR=PREPARE.PRINT.FORMAT 
;;; Reading source file "prog/prot/prot-prepare.lisp"
;;; Writing binary file "prog/prot/prot-prepare.sbin"
;;; Loading binary file "prog/prot/prot-prepare.sbin"
;;; Loading source file "prog/prot/prot-execute.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PRO-LIST.PROTOCOL 
PRO=VERSIONS 
PRO=RESET 
;;; Reading source file "prog/prot/prot-execute.lisp"
;;; Writing binary file "prog/prot/prot-execute.sbin"
;;; Loading binary file "prog/prot/prot-execute.sbin"
;;; Loading source file "prog/prot/post.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PO*RESCOUNTER 
PO*FACCOUNTER 
PO*PARACOUNTER 
PO*INSTCOUNTER 
PO*RENCOUNTER 
PO*INDICES 
PO*FILE 
PO*ALL.FORMULAS 
PO*INDENTATION 
PO*OPERATION.STACK 
PO=INIT.COUNTERS 
PO=PRINT.CONSTANTS 
PO=PRINT.PREDICATES 
PO=PRINT.FUNCTIONS 
PO-CONSTRUCT.START 
PO=MODIFY.QUANTOR 
PO-REARRANGE 
PO-MODIFY-PRED 
PO=TREAT.FORMULA 
PO-AXIOMS.START 
PO-AXIOMS.END 
PO-THEOREMS.START 
PO*ACT.NUM 
PO=GET.FORMULA.POSITION 
PO=GET.FORMULAS.POSITION 
PO=CONVERT.INDICES 
PO-THEOREMS.END 
PO-INITIAL.GRAPH 
PO-CONSTRUCT.END 
PO-SPLITPARTS.START 
PO=PRINT.MKRP.FORMULAS 
PO=PRINT.AXIOMS 
PO=PRINT.THEOREMS 
PO-PREFIX.FORM 
PO-REFUTATION.START 
PO=PCLAUSE 
PO-PARTIAL.GRAPH 
PO=PRINT.OP.HEADER 
PO=PRINT.OPERATION.FRAME 
PO-OPERATION 
PO=OPERATION 
PO=PROVER 
PO-REFUTATION.END 
PO-SPLITPARTS.END 
PO=OPTIONS 
PO-OPTIONS 
PO=PRINT.RESOLUTION 
PO=RESOLUTION 
PO=LINK.PARENTS 
PO=PRINT.PARENTS 
PO=PRINT.INSTANCE 
PO=PRINT.VARS 
PO=PRINT.SUBST 
PO=PRINT.LIT 
PO=PRINT.CLAUSE.FRAME 
PO=REPLACEMENT.RESOLUTION 
PO=FACTORIZATION 
PO=INSTANTIATE 
PO=LINK.FAC 
PO=PRINT.FAC.POSITION 
PO=R.CHAIN.FIRST.RES 
PO=R.CHAIN.REST.RES 
PO=R.CHAIN 
PO=GET.ALL.LITS 
PO=SIM.RESOLUTION 
PO=SIM.FACTORING 
PO=SEARCH.ACT.LITNO 
PO=REPL.CLAUSE 
PO=MERGE.UNIFIER 
PO=GENERATE.REN.REN 
PO=COMPOSITION.OF.SUBSTITUTIONS 
PO=COMPUTE.UNIFIER 
PO=REPL.OP.SUBST 
PO=REPL.OP.ONE.RES 
PO=REPL.OP.ONE.FAC 
PO=REPL.OP.IMPLICIT.MULTIPLE 
PO=REPLACEMENT.OPERATION 
PO=RESTRICT.RENAMING 
PO=VARIABLES.SORTS.OF.CODOMAIN 
PO=DOUBLE.LITERAL 
PO=COMPUTE.RW.MATCH 
PO=PRINT.POSITION 
PO=GENERATE.RENAMING 
PO=MERGE.RENAMING 
PO=CLAUSE.PNAME 
PO=CLAUSE.RENAMING 
PO=CLAUSE.PUTPNAME 
PO=CLAUSE.PUTRENAMING 
PO=PARAMODULATION 
PO=I.PARAMODULATION 
PO=E.PARAMODULATION 
PO=LINK.PAR 
PO=LINK.PAR.INST 
PO=REWRITE 
PO=REWRITE.SYMMETRY 
PO=CLAUSE 
PO=LINK.COLOURS 
PO-INFIX.FORM 
;;; Reading source file "prog/prot/post.lisp"
;;; While compiling PO=TREAT.FORMULA
;;; Warning: Free variable FOO assumed to be special
;;; Warning: Variable FOO is bound but not referenced
;;; While compiling PO=PRINT.MKRP.FORMULAS
;;; Warning: Calling PO=TREAT.FORMULA with the wrong number of arguments
;;; Writing binary file "prog/prot/post.sbin"
;;; Warning: The following function is not known to be defined:
;;;          PO-PART.CLAUSE was referenced by PO=PRINT.RESOLUTION
;;; Loading binary file "prog/prot/post.sbin"
;;; Loading source file "prog/prot/interface.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PR-CONSTRUCT.START 
PR-INFIX.FORM 
PR-PREFIX.FORM 
PR-OPTIONS 
PR-AXIOMS.START 
PR-AXIOMS.END 
PR-THEOREMS.START 
PR-THEOREMS.END 
PR-CONSTRUCT.END 
PR-SPLITPARTS.START 
PR-REFUTATION.START 
PR-PARTIAL.GRAPH 
PR-INITIAL.GRAPH 
PR-OPERATION 
PR-STATISTICS 
PR-REFUTATION.END 
PR-SPLITPARTS.END 
;;; Reading source file "prog/prot/interface.lisp"
;;; Writing binary file "prog/prot/interface.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          PR=CONSTRUCT.START was referenced by PR-CONSTRUCT.START
;;;          PR=INFIX.FORM was referenced by PR-INFIX.FORM
;;;          PR=PREFIX.FORM was referenced by PR-PREFIX.FORM
;;;          PR=OPTIONS.TOP was referenced by PR-OPTIONS
;;;          PR=AXIOMS.START was referenced by PR-AXIOMS.START
;;;          PR=AXIOMS.END was referenced by PR-AXIOMS.END
;;;          PR=THEOREMS.START was referenced by PR-THEOREMS.START
;;;          PR=THEOREMS.END was referenced by PR-THEOREMS.END
;;;          PR=CONSTRUCT.END was referenced by PR-CONSTRUCT.END
;;;          PR=SPLITPARTS.START was referenced by PR-SPLITPARTS.START
;;;          PR=REFUTATION.START was referenced by PR-REFUTATION.START
;;;          PR=PARTIAL.GRAPH was referenced by PR-PARTIAL.GRAPH
;;;          PR=INITIAL.GRAPH was referenced by PR-INITIAL.GRAPH
;;;          PR=OPERATION was referenced by PR-OPERATION
;;;          PR=REFUTATION.END was referenced by PR-REFUTATION.END
;;;          PR=SPLITPARTS.END was referenced by PR-SPLITPARTS.END
;;; Loading binary file "prog/prot/interface.sbin"
;;; Loading source file "prog/prot/protocol.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PR*INDICES 
PR*FILE 
PR*INDENTATION 
PR=CONSTRUCT.START 
PR=INFIX.FORM 
PR=PREFIX.FORM 
PR=OPTIONS.TOP 
PR=AXIOMS.START 
PR=AXIOMS.END 
PR=THEOREMS.START 
PR=THEOREMS.END 
PR=CONSTRUCT.END 
PR=SPLITPARTS.START 
PR=REFUTATION.START 
PR=PARTIAL.GRAPH 
PR=INITIAL.GRAPH 
PR=OPERATION 
PR=REFUTATION.END 
PR=SPLITPARTS.END 
PR=AXIOMS.OR.THEOREMS.END 
PR=OPTIONS 
PR=SYMBOLS 
PR=RESOLUTION 
PR=R.CHAIN 
PR=LINK.RES 
PR=REPLACEMENT.RESOLUTION 
PR=PARAMODULATION 
PR=LINK.PAR 
PR=FACTORIZATION 
PR=INSTANTIATE 
PR=LINK.FAC 
PR=REPLACEMENT.OPERATION 
PR=VARIABLES.SORTS.OF.CODOMAIN 
PR=DOUBLE.LITERAL 
PR=REWRITE 
PR=REWRITE.SYMMETRY 
PR=CLAUSE 
PR=LINK.COLOURS 
;;; Reading source file "prog/prot/protocol.lisp"
;;; While compiling PR=R.CHAIN
;;; Warning: Variable LINK is bound but not referenced
;;; Writing binary file "prog/prot/protocol.sbin"
;;; Loading binary file "prog/prot/protocol.sbin"
;;; Loading source file "prog/op/op-service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP*LINK.COLOURS.LITERAL.INITIAL 
OP*CLAUSECOUNTER 
OP*COUNTER.RESOLVENTS 
OP*COUNTER.PARAMODULANTS 
OP*COUNTER.FACTORS 
OP*COUNTER.INSTANCES 
OP*COLOURS.CIRCLE.LINKS 
OP*UNIFIER.BUFFER 
OP*VARIABLE.BUFFER1 
OP*VARIABLE.BUFFER2 
OP=UNIFY 
OP=MATCH 
OP=WEAK.UNIFY 
OP=C.RPLACA 
OP=C.NIL.COMPONENTS 
OP=C.REMOVE.INSTANCES 
OP=ADMISSIBLE.RULE 
OP=PREDICATE.OCCURRENCES 
OP=COLOUR.IS.X 
OP=COLOUR.IS.XI 
OP=COLOUR.IS.XIW 
OP=C.RENAME 
OP=FIND.VARIABLES 
OP=SEARCH.VARIABLES 
OP=GENERATE.PASSIVE.POSITIONS 
OP=GENERATE.PASSIVE.POSITIONS.TERMLIST 
OP=GENERATE.PASSIVE.POSITIONS.TERM 
OP=INSERT.POSITIONS 
OP=TRANSMIT.LITERALS 
OP=PAR_TRANSMIT.LITERAL 
OP=RES_NEWNAME 
OP=PAR_NEWNAME 
OP=FAC_NEWNAME 
OP=INST_NEWNAME 
OP=RENAME 
OP=REMOVE.COMPONENTS 
OP=REMOVE.INSTANCES 
OP=DISJOINTIFY 
OP=PARALLEL.LINKS 
OP=PARALLEL.LINKS.1 
OP=COLOUR 
OP==COLOUR 
OP=REMOVE.PROPERTY 
;;; Reading source file "prog/op/op-service.lisp"
;;; While compiling OP=UNIFY
;;; Warning: Free variable OP*RULE.DUMMY assumed to be special
;;; While compiling OP=MATCH
;;; Warning: Free variable OP*RULE.DUMMY assumed to be special
;;; Writing binary file "prog/op/op-service.sbin"
;;; Warning: The following function is not known to be defined:
;;;          NAR-NARROW.INFO was referenced by OP=PARALLEL.LINKS
;;; Loading binary file "prog/op/op-service.sbin"
;;; Loading source file "prog/op/op-inherit.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP=INHERIT1 
OP=INHERIT.LINKS 
OP=INHERIT.R 
OP=INHERIT.S 
OP=INHERIT.T 
OP=INHERIT.X.TO.X 
OP=INHERIT.X.TO.X.XI.XIW 
OP=INHERIT.XIW.TO.X.XI.XIW 
OP=INHERIT.CIRCLE.LINKS 
OP=INHERIT.XI.TO.XI 
OP=INHERIT_POT.TRUE.AND.FALSE.LITNOS 
OP=INHERIT_ERPATHS 
OP=INHERIT_RELINKS 
;;; Reading source file "prog/op/op-inherit.lisp"
;;; Writing binary file "prog/op/op-inherit.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          CONS-RECONSTRUCT.LINKS was referenced by OP=INHERIT.LINKS
;;;          NAR-NARROW.INFO was referenced by OP=INHERIT.R,
;;;             OP=INHERIT.S, OP=INHERIT.T
;;; Loading binary file "prog/op/op-inherit.sbin"
;;; Loading source file "prog/op/op-create.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP-CONSTRUCT.CLAUSES 
OP-CLAUSE.REWRITE.RULE.AC.EXTEND 
OP-CONSTRUCT.LITERAL.LINKS 
OP=POT.T.AND.F.LITNOS 
OP=CREATE.XLINKS 
OP=CREATE.XILINKS 
OP=CREATE.XIWLINKS 
OP=CREATE.XI.CIRCLE.LINKS 
OP=CREATE.XIW.CIRCLE.LINKS 
OP=CREATE.LINKS 
OP=CREATE_P.PD.AND.PIW.LINKS 
OP=PAR_CREATE.POT.TRUE.AND.FALSE.LITNO.FOR.PARAMOD.LIT 
;;; Reading source file "prog/op/op-create.lisp"
;;; Writing binary file "prog/op/op-create.sbin"
;;; Warning: The following function is not known to be defined:
;;;          CONS-CONSTRUCT.PLINKS was referenced by
;;;             OP=CREATE_P.PD.AND.PIW.LINKS
;;; Loading binary file "prog/op/op-create.sbin"
;;; Loading source file "prog/op/operation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP-RESET 
OP-SAVE 
OP-#RESOLVENTS 
OP-#PARAMODULANTS 
OP-#FACTORS 
OP=REPLACE 
OP=RENAMINGS 
OP=CREATE.ELEMENT.LITERALS 
OP-RESOLVE 
OP=PARAMODULATE 
OP=PIW.PARAMODULATE 
OP-PARAMODULATE 
OP=FACTORIZE 
OP-FACTORIZE 
OP-CREATE.INSTANCE 
OP-CREATE.UNIT.FACTORS 
OP=TWO.CREATE.UNIT.FACTORS 
OP-R.CHAIN 
OP=RIW.RESOLVE 
OP-OPERATE 
OP=SUBSUMED.P.MAP.RULES 
OP=SUBSUMED.P.OCC 
OP=SUBSUMED.P 
OP-SUBSUMED.P 
OP*RULE.DUMMY 
OP=PAR_CONNECT 
OP=CONNECT.TO.PARENTS 
OP=INSERT.LINK 
OP=SI.COMPLETE.GROUPS 
OP=NEGATIVE.SIDES 
;;; Reading source file "prog/op/operation.lisp"
;;; Writing binary file "prog/op/operation.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          NAR-NARROW.INFO was referenced by OP-RESOLVE
;;;          NAR-PR.NARROW was referenced by OP-RESOLVE
;;;          RED-REWRITE was referenced by OP-RESOLVE, OP=PARAMODULATE,
;;;             OP=PIW.PARAMODULATE, OP=FACTORIZE, OP-CREATE.INSTANCE,
;;;             OP-R.CHAIN
;;;          CONS-RECONSTRUCT.LINKS was referenced by OP-RESOLVE
;;;          CONS-CONSTRUCT.LINKS was referenced by OP-RESOLVE,
;;;             OP=PARAMODULATE, OP=PIW.PARAMODULATE, OP=FACTORIZE,
;;;             OP-CREATE.INSTANCE
;;; Loading binary file "prog/op/operation.sbin"
;;; Loading source file "prog/red/two.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
TWO*RULES.MAXLEVEL 
TWO*CONTROL 
TWO*SUPPRESS.NORULES 
TWO*DIALOG 
TWO*EXTERNAL.RULE.COLOURS 
TWO*INTERNAL.RULE.COLOURS 
TWO*RULES 
TWO*ADDED.RULES 
TWO*EMPTY.CLAUSE.FOUND 
TWO*NEW.RULES 
TWO*NORULE.CLAUSES 
TWO*TR.RULES 
TWO*TR.NORULES 
TWO-UPDATE.RULES 
TWO-RESET 
TWO-SAVE 
TWO=INIT 
TWO-END 
TWO=COMPLETE.RULES 
TWO=ADD.AND.LEVEL.SATURATE 
TWO=ADD.NEW.LEVEL 
TWO=RESOLVE.ALL 
TWO=SELECT.RULES 
TWO=S 
TWO=S.ADDED 
TWO=S.UNIONS 
TWO=S.ADDED.UNIONS 
TWO=MERGE 
TWO=FACTORIZE 
TWO=RESOLVE 
TWO=REDUCE 
TWO=GET.ADJACENT.CLAUSES.OF 
TWO=ADJACENT.LITERALS 
TWO=CONSTRUCT.LINKS 
TWO=UPDATE.GRAPH 
TWO=ADMISSIBLE.RULE.IS 
TWO=CLASSIFY.CLAUSE 
TWO=ADMISSIBLE.SIW.HAS 
TWO=NOT.PARTIAL.IS 
TWO=DIALOG 
TWO-LAST.CALL.NEW.RULES 
TWO-LAST.CALL.NEW.NORULES 
;;; Reading source file "prog/red/two.lisp"
;;; Writing binary file "prog/red/two.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          RED-REMOVE.CLAUSE was referenced by TWO-UPDATE.RULES
;;;          RED-REDUCE.RULE.GRAPH was referenced by TWO=REDUCE
;;; Loading binary file "prog/red/two.sbin"
;;; Loading source file "prog/red/red-service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED.SERVICE-BINDING.RENAMES.VARIABLES 
RED.SERVICE-NIL.IN.UNIFIERS 
RED.SERVICE-SWITCHED.UNIFIERS 
RED.SERVICE-CLAUSE.LINKS 
RED.SERVICE==CLAUSE.LINKS 
RED.SERVICE-OTHERPAR.EXTERNAL 
RED.SERVICE-OTHERLITNO.EXTERNAL 
RED.SERVICE-OTHERLITNO.INTERNAL 
RED.SERVICE-LINK.NEGPAR 
RED.SERVICE-LINK.PARENTS 
RED.SERVICE-LINK.ORIENTED 
RED.SERVICE-TRUE.LITERAL.IS 
RED.SERVICE-FALSE.LITERAL.IS 
RED.SERVICE-TRUE.CLAUSE 
RED.SERVICE-FALSE.CLAUSE 
RED*SERVICE_RENAME.VARIABLES 
RED.SERVICE-RENAME.POINT 
RED.SERVICE-RENAME.DELETE 
RED.SERVICE-RENAME 
;;; Reading source file "prog/red/red-service.lisp"
;;; Writing binary file "prog/red/red-service.sbin"
;;; Loading binary file "prog/red/red-service.sbin"
;;; Loading source file "prog/red/red-datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RDS-RULES 
RDS==RULES 
RDS-LINK.COLOURS 
RDS==LINK.COLOURS 
RED*LINK.SUBSUMPTION.SUBJECT 
RED*LINK.SUBSUMPTION.OBJECT 
RED*LINK.TAUTOLOGY 
RED*LINK.INCOMPATIBILITY 
RED*CLAUSE.REWRITING 
RED*CLAUSE.REPL.RESOLUTION.SUBJECT 
RED*CLAUSE.REPL.RESOLUTION.OBJECT 
RED*CLAUSE.SUBSUMPTION.OBJECT 
RED*CLAUSE.SUBSUMPTION.SUBJECT 
RED*CLAUSE.REPL.FACTORING 
RED*CLAUSE.TAUTOLOGY 
RED*CLAUSE.PURITY 
RED*CLAUSE.MULTIPLE.LITERALS 
RDS==RULE 
RDS-RULE 
RDS==RULE.PUT 
RDS-RULE.PUT 
RED*RULES.SWITCHED.ON 
RDS-RULES.SWITCHED.ON 
RDS-RULES.SWITCHED.ON.PUT 
RED*BINDING.STACK 
RDS-BINDING.STACK.RESET 
RDS-BINDING.RESET 
RDS-BINDING.PUSH 
RDS-BINDING.POP 
RDS-BINDING.TOP 
RDS*BUFFERS 
RDS-BUFFER 
RDS*MARKS 
RDS*MARKS.ALL 
RDS-MARK 
RDS-MARK.PUT 
RDS-MARKS.CREATE 
RDS-MARKS.RESET 
RDS-MARKS.DESTROY 
RDS-AGENDA.INSERT.CLAUSE.GREATER 
RDS-AGENDA.INSERT.CLAUSE.LESS 
RDS-RW_RULE 
RDS*RW_VARIABLES 
RDS*RW_ASSIGN 
RDS=RW_GET.VAR 
RDS=RW_RESET.VAR 
RDS=RW_CONS.TERM 
RDS-RW_RULE.CREATE 
;;; Reading source file "prog/red/red-datastructure.lisp"
;;; Writing binary file "prog/red/red-datastructure.sbin"
;;; Loading binary file "prog/red/red-datastructure.sbin"
;;; Loading source file "prog/red/red-rw.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED*RW_RULES 
RED*RW_TAF 
RED*RW_RULES.COMPLETION 
RED*RW_RULES.UNFAILING 
RED=APPLY_CLAUSE.REWRITING.TO.CLAUSE 
RED=RW_ADD.COMPLETION.RULE 
RED=RW_REDUCE.CC 
RED=RW_ADD.COMPLETION.UNFAIL 
RED=RW_ADD.COMPLETION.TREE 
RED=RW_ADD.COMPLETION.SINGLE 
RED=RW_ADD.COMPLETION 
RED=RW_APPLY.TO.TERMLIST.INTERNAL 
RED=RW_APPLY.TO.TERMLIST 
RED=RW_CONTEXTUAL 
RED=REWRITE.LIT 
RED-REWRITE 
RED=RW_COMPLETION 
RED=RW_REPLACE 
RED=RW_FIND.MATCHES.IN.TERMLIST 
RED=RW_REWRITE.CLAUSE 
RED=RW_REWRITE.CONSTANT.IS 
RED=RW_REWRITE.FUNCTION.IS 
;;; Reading source file "prog/red/red-rw.lisp"
;;; Writing binary file "prog/red/red-rw.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          RED=CTL_RECONSTRUCT was referenced by
;;;             RED=APPLY_CLAUSE.REWRITING.TO.CLAUSE, RED=RW_COMPLETION
;;;          RED-INFO_P.LINK.RULES was referenced by RED=RW_REDUCE.CC,
;;;             RED-REWRITE, RED=RW_COMPLETION
;;;          RED-INFO_P.LINK.UNFAIL.RULES was referenced by
;;;             RED=RW_REDUCE.CC, RED-REWRITE, RED=RW_COMPLETION
;;;          RED=RW_C.INSERT was referenced by
;;;             RED=RW_ADD.COMPLETION.TREE
;;;          RED=CRR_COMPUTE.S.AND.R.LINKS was referenced by
;;;             RED=RW_CONTEXTUAL
;;;          RED=CRR_MARK.ALL.SUBJECT.LITERALS was referenced by
;;;             RED=RW_CONTEXTUAL
;;;          RED=CRR_MARKED.NOT.REMOVED was referenced by
;;;             RED=RW_CONTEXTUAL
;;;          RED=CRR_PROTOCOL.RECONSTRUCT was referenced by
;;;             RED=RW_CONTEXTUAL
;;;          RED=CTL_REPLACE.LITERAL was referenced by
;;;             RED=RW_CONTEXTUAL, RED=REWRITE.LIT, RED=RW_COMPLETION,
;;;             RED=RW_REPLACE, RED=RW_REWRITE.CLAUSE
;;;          RED=CTL_AGENDA.UPDATE was referenced by RED=RW_CONTEXTUAL,
;;;             RED=RW_COMPLETION, RED=RW_REPLACE
;;;          RED=CS_SUBSUME.TRUE.LITERAL was referenced by
;;;             RED=RW_COMPLETION
;;; Loading binary file "prog/red/red-rw.sbin"
;;; Loading source file "prog/red/red-crr.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED=APPLY_CLAUSE.REPL.RESOLUTION.SUBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.REPL.RESOLUTION.SUBJECT.TO.LINK 
RED=APPLY_CLAUSE.REPL.RESOLUTION.OBJECT.TO.CLAUSE 
RED=CRR_ATTEMPT.TO.RESOLVE 
RED=CRR_TO.EXT.SUBSUMPTION.LINK 
RED=CRR_TO.INT.SUBSUMPTION.LINK 
RED=CRR_REMOVE.MARKED.LITS 
RED=CRR_COMPUTE.S.AND.R.LINKS 
RED=CRR_INSERT.ANCESTORS 
RED=CRR_FALSE.LITERALS 
RED=CRR_FALSE.STRUCTURE 
RED=CRR_FALSE.REMOVE 
RED=CRR_MARK.DOUBLE.LITERALS.INTERNAL 
RED=CRR_MARK.DOUBLE.LITERALS.EXTERNAL 
RED=CRR_MARK.FALSE.LITERALS 
RED=CRR_MARK.ALL.SUBJECT.LITERALS 
RED=CRR_MARK.OPERATING 
RED=CRR_MARK.OBJECT.LITERALS 
RED=CRR_MARK.UNIT.RESOLUTION 
RED=CRR_MARK.S.RESOLUTION 
RED=CRR_MARK.OBJECT.FACTORING 
RED=CRR_MARKED.NOT.REMOVED 
RED=CRR_GENERALIZING.CONDITION 
RED=CRR_GENERALIZING.TO.LITERALS 
RED=CRR_GENERALIZING.TO.UNIFIER 
RED=CRR_REPLACE.LITERAL 
RED=CRR_SIMPLE.CONDITION 
RED=CRR_EXISTS.PERMUTATION.OF.DOUBLE.LITERALS 
RED=CRR_PROTOCOL.RECONSTRUCT 
RED=CRR_PROTOCOL.DOUBLE.LITERAL.PATH 
;;; Reading source file "prog/red/red-crr.lisp"
;;; While compiling RED=CRR_REMOVE.MARKED.LITS
;;; Warning: Free variable RED*STATE assumed to be special
;;; Writing binary file "prog/red/red-crr.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          RED=CTL_AGENDA.UPDATE was referenced by
;;;             RED=CRR_ATTEMPT.TO.RESOLVE, RED=CRR_FALSE.REMOVE
;;;          RED=CTL_REMOVE.LITERAL was referenced by
;;;             RED=CRR_REMOVE.MARKED.LITS, RED=CRR_FALSE.REMOVE
;;;          RED=CTL_REPLACE.LITERAL was referenced by
;;;             RED=CRR_REPLACE.LITERAL
;;;          RED=CTL_RECONSTRUCT was referenced by
;;;             RED=CRR_REPLACE.LITERAL
;;; Loading binary file "prog/red/red-crr.sbin"
;;; Loading source file "prog/red/narrow.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
NAR*TERM*ALIST 
NAR*CLAUSES 
NAR-NARROW 
NAR=INSERT.TREE.EQ 
NAR=CREATE.TREE.EQ 
NAR=INSERT.TREE 
NAR=CREATE.TREE 
NAR-NARROW.INFO 
NAR-NARROW.INFO.PUT 
NAR-PR.NARROW 
NAR=DERIV.LIST.EQ 
NAR=DERIV.LIST 
NAR=PR.OPERATION 
NAR=REWRITE 
N*NUMBER 
NAR=N.NAME 
NAR=TRANSLATE.TERM.TO 
NAR=MAKE.RULES 
NAR=TRANSLATE.RULE.TO 
NAR=TRANSLATE.CLAUSE.TO 
NAR=TRANSLATE.LIT.TO 
NAR=TRANSLATE.SUBST.FROM 
NAR=TRANSLATE.TERM.FROM 
NAR-RESET 
;;; Reading source file "prog/red/narrow.lisp"
;;; Writing binary file "prog/red/narrow.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          NAR-SOLUTIONS was referenced by NAR=INSERT.TREE.EQ,
;;;             NAR=INSERT.TREE
;;;          NAR-CREATE-NARROW.PROBLEM was referenced by
;;;             NAR=CREATE.TREE.EQ, NAR=CREATE.TREE
;;;          RED-INFO_P.LINK.RULES was referenced by NAR=CREATE.TREE.EQ,
;;;             NAR=CREATE.TREE
;;;          NAR-NSTEP-REST.CLAUSE was referenced by NAR-PR.NARROW,
;;;             NAR=DERIV.LIST
;;;          NAR-NSTEP-DERIV was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=PR.OPERATION
;;;          DS-DERIV-FATHER was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=PR.OPERATION
;;;          DS-DERIV-MOTHER was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          NAR-NSTEP-SIGMA was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=PR.OPERATION
;;;          DS-DERIV-REDUCTION-LIST was referenced by
;;;             NAR=DERIV.LIST.EQ, NAR=DERIV.LIST
;;;          DS-DERIV-POSITION was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          DS-TERM-SUBTERMS was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=REWRITE, NAR=TRANSLATE.TERM.FROM
;;;          NAR-NSTEP-EQ was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          DS-CLAUSE-LITERALS was referenced by NAR=DERIV.LIST
;;;          DS-TERM-EQ-SYMBOL was referenced by NAR=TRANSLATE.TERM.TO,
;;;             NAR=TRANSLATE.LIT.TO
;;;          DS-MAKE-TERM was referenced by NAR=TRANSLATE.TERM.TO,
;;;             NAR=TRANSLATE.LIT.TO
;;;          DS-MAKE-VARIABLE was referenced by NAR=TRANSLATE.TERM.TO
;;;          DS-RULES-INIT was referenced by NAR=MAKE.RULES
;;;          DS-RULES-EXTEND was referenced by NAR=MAKE.RULES
;;;          DS-MAKE-RULE was referenced by NAR=TRANSLATE.RULE.TO
;;;          DS-MAKE-CLAUSE was referenced by NAR=TRANSLATE.CLAUSE.TO
;;;          DS-TRUE was referenced by NAR=TRANSLATE.LIT.TO
;;;          DS-FALSE was referenced by NAR=TRANSLATE.LIT.TO
;;;          OUT-FORMAT was referenced by NAR=TRANSLATE.LIT.TO
;;;          DS-TERM-SYMBOL was referenced by NAR=TRANSLATE.TERM.FROM
;;;          DS-VARIABLEP was referenced by NAR=TRANSLATE.TERM.FROM
;;; Loading binary file "prog/red/narrow.sbin"
;;; Loading source file "prog/red/red-linkcondition.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED.LC-CLAUSE.TAUTOLOGY 
RED.LC-LINK.TAUTOLOGY 
RED.LC=TAUT_MARK.OTHERS 
RED.LC=TAUT_MARK.RESET 
RED.LC=TAUT_MARK.INTERSECTION 
RED.LC=TAUT_INSTANCE 
RED.LC=TAUT_INSTANCE.C.C.C 
RED.LC=TAUT_INSTANCE.C.C.C.RENAME 
RED.LC=TAUT_INSTANCE.CIW.C.C 
RED.LC=TAUT_INSTANCE.CIW.C.CIW 
RED.LC=TAUT_INSTANCE.C.CIW.C 
RED.LC=TAUT_INSTANCE.CIW.CIW.C 
RED.LC=TAUT_INSTANCE.CIW.CIW.CIW 
RED.LC=TAUT_INSTANCE.TEST 
RED.LC=TAUT_UNIFIERS.RENAME 
RED.LC=TAUT_UNIFIERS.RENAME.SWITCH 
RED.LC=TAUT_UNIFIERS.STANDARD 
RED.LC=TAUT_UNIFIERS.SWITCH 
RED.LC=TAUT_VARIABLES 
RED.LC-CLAUSE.SUBSUMPTION 
RED.LC-LINK.SUBSUMPTION 
RED.LC=SUBS_INTERNAL 
RED.LC=SUBS_INTERNAL.MARK.OTHERS 
RED.LC=SUBS_INTERNAL.MARK.INTERSECTION 
RED.LC=SUBS_INTERNAL.LINK.BLOCKS 
RED.LC=SUBS_INTERNAL.INSTANCE 
RED.LC=SUBS_INTERNAL.INSTANCE.CI.CI.OR.C 
RED.LC=SUBS_INTERNAL.INSTANCE.CIW.CIW 
RED.LC=SUBS_INTERNAL.INSTANCE.CIW.C 
RED.LC=SUBS_EXTERNAL 
RED.LC=SUBS_EXTERNAL.MARK.OTHERS 
RED.LC=SUBS_EXTERNAL.MARK.INTERSECTION 
RED.LC=SUBS_EXTERNAL.LINK.BLOCKS 
RED.LC=SUBS_EXTERNAL.INSTANCE 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.C 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.C.RENAME 
RED.LC=SUBS_EXTERNAL.INSTANCE.CIW.C 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.CIW 
RED.LC=SUBS_EXTERNAL.INSTANCE.CI.C 
RED.LC=SUBS_INSTANCE.TEST 
RED.LC=SUBS_UNIFIERS.STANDARD 
RED.LC=SUBS_UNIFIERS.SWITCH 
RED.LC=SUBS_UNIFIERS.RENAME 
RED.LC=SUBS_UNIFIERS.RENAME.BINDING 
;;; Reading source file "prog/red/red-linkcondition.lisp"
;;; Writing binary file "prog/red/red-linkcondition.sbin"
;;; Loading binary file "prog/red/red-linkcondition.sbin"
;;; Loading source file "prog/red/reduction.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED*FORWARD 
RED*GRAPH.ISOLATION 
RED-REDUCE.DEDUCED.GRAPH.PARTIAL 
RED-REDUCE.DEDUCED.GRAPH 
RED=LINKS 
RED-REDUCE.GRAPH 
RED-REDUCE.INITIAL.GRAPH.PARTIAL 
RED-REDUCE.RESORTED.GRAPH 
RED-REDUCE.INITIAL.GRAPH 
RED-REDUCE.RULE.GRAPH 
RED-CLAUSE.SUBSUMPTION 
RED-REMOVE.CLAUSE 
RED-CLAUSE.TAUTOLOGY.IS 
RED-RESET 
RED-SAVE 
RED-SAVE.RESET 
RED-END 
RED=RESET 
RED=RESET_PUT 
RED=RESET_OPTIONS 
RED*AGENDA 
RED*TEST 
RED*CHECK 
RED=CTL_REDUCE 
RED=CTL_APPLY.RULES 
RED*STATE 
RED=CTL_INIT 
RED=CTL_AGENDA.INSERT.CLAUSE 
RED=CTL_AGENDA.INSERT.LINK 
RED=CTL_AGENDA.INSERT.RECHECK 
RED=CTL_AGENDA.POP.RULE.AND.CLAUSE 
RED=CTL_AGENDA.POP.RULE.AND.LINK 
RED=CTL_AGENDA.POP.RULE.AND.RECHECK 
RED=CTL_AGENDA.UPDATE 
RED=CTL_AGENDAS.INSERT.LINKS 
RED=CTL_APPLY.RULE.TO.RECHECK 
RED=CTL_APPLY.RULE.TO.CLAUSE 
RED=CTL_APPLY.RULE.TO.LINK 
RED=CTL_REMOVE.CLAUSE 
RED=CTL_REMOVE.LITERAL 
RED=CTL_RECONSTRUCT 
RED=CTL_REPLACE.LITERAL 
RED=CTL_REMOVE.LINK 
RED=CTL_REMOVE.UNIFIER 
RED=CTL_UPDATE.RECHECK.INFO 
RED=INFO_REC.P.LINK.LITERALS 
RED=INFO_REC.P.LINK.LIST 
RED-INFO_P.LINK.RULES 
RED-INFO_P.LINK.UNFAIL.RULES 
RED=INFO_RENAME.RULE 
RED*INFO_LINKS.CHANGED 
RED=INFO_LIT.DELETE 
RED=INFO_LIT.UNIFY 
RED=INFO_LIT.DELETE1 
RED=INFO_LINK.RESULT.REPLACE 
RED=INFO_LINK.RESULT.PUT 
RED=INFO_REMOVE 
RED=INFO_INSERT.RESULT 
RED=INFO_UPDATE 
RED=INFO_REDUCE.CC 
RED=APPLY_GRAPH.ISOLATION.TO.GRAPH 
RED=GI_MARK.OBTAINABLE.CLAUSES 
RED=APPLY_CLAUSE.MULTIPLE.LITERALS.TO.CLAUSE 
RED=APPLY_CLAUSE.MULTIPLE.LITERALS.TO.LINK 
RED=CML_TO.DETECTION.LINK 
RED=APPLY_CLAUSE.PURITY.TO.CLAUSE 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.CLAUSE 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.LINK 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.RECHECK 
RED=CT_ATTEMPT.TO.REMOVE 
RED=CT_CANDIDATE.LINKS 
RED=CT_UPDATE.RECHECK.INFO 
RED=APPLY_CLAUSE.REPL.FACTORING.TO.CLAUSE 
RED=APPLY_CLAUSE.REPL.FACTORING.TO.LINK 
RED=CRF_TO.UNIFIER 
RED=CRF_TO.CLAUSE 
RED=CRF_ATTEMPT.TO.FACTORIZE 
RED=CRF_INSERT.ANCESTORS 
RED=CRF_PROTOCOL.RECONSTRUCT 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.SUBSUMPTION.OBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.LINK 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.RECHECK 
RED=CS_TO.SUBSUMPTION.LINK 
RED=CS_TO.LINK.CONDITION.LINK 
RED=CS_ATTEMPT.TO.SUBSUME 
RED=CS_SUBSUME.TRUE.LITERAL 
RED=CS_INSERT.ANCESTORS 
RED=CS_UPDATE.RECHECK.INFO 
RED=CS_CANDIDATES.TO.BE.SUBSUMING 
RED=CS_CANDIDATES.TO.BE.SUBSUMED 
RED=CS_RELATION.MATCH 
RED=CS_RELATION.INJECTIVE 
RED=APPLY_LINK.INCOMPATIBILITY.TO.LINK 
RED=APPLY_LINK.INCOMPATIBILITY.TO.CLAUSE 
RED=LI_PARTITION.LITERALS 
RED=LI_TO.OP.LINK 
RED=LI_TO.INSERTED.LINK 
RED=LI_COMPATIBLE.LITERAL 
RED=LI_UNI.CHANGE 
RED=LI_MERGE 
RED=APPLY_LINK.TAUTOLOGY.TO.LINK 
RED=APPLY_LINK.TAUTOLOGY.TO.CLAUSE 
RED=APPLY_LINK.TAUTOLOGY.TO.RECHECK 
RED=LT_TO.OP.LINK 
RED=LT_RECHECK.INSERT.CONDITION.LINK 
RED=LT_RECHECK.INSERT.DETECTION.LINK 
RED=LT_ATTEMPT.TO.REMOVE 
RED=LT_CANDIDATE.LINKS 
RED=LT_UPDATE.RECHECK.INFO 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.CLAUSE 
RED=APPLY_LINK.SUBSUMPTION.OBJECT.TO.CLAUSE 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.LINK 
RED=APPLY_LINK.SUBSUMPTION.OBJECT.TO.LINK 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.RECHECK 
RED=LS_ATTEMPT.TO.SUBSUME 
RED=LS_P.LINK.NEW 
RED=LS_SUBSUME.P.LINK 
RED=LS_ALL.INSTANCES.TRUE 
RED=LS_TO.EXT.LINK 
RED=LS_TO.INT.LINK 
RED=LS_TO.SUBSUMPTION.LINK 
RED=LS_RECHECK.INSERT.CONDITION.LINK 
RED=LS_UPDATE.RECHECK.INFO 
RED=LS_SUBSUME.TRUE.LITERAL 
RED=LS_OWN.PARENT.TO.CLAUSE 
RED=LS_OWN.PARENT.TO.LITERAL 
RED=LS_OWN.PARENT.TO.SUBSUMER.SUBSUMENT 
RED=LS_OWN.PARENT.TO.LINK 
RED=LS_OWN.PARENT.TO.UNIFIER 
RED=LS_CANDIDATES.TO.BE.SUBSUMING 
RED=LS_CANDIDATES.TO.BE.SUBSUMED 
RED=LS_CANDIDATES.TO.BE.SUBSUMED.SPEC.PARENT 
RED=LS_CANDIDATES.INSERT.RELATION 
RED=LS_RELATION.EXECUTE 
RED=LS_RELATION.INJECTIVE 
RED=LS_RELATION.MARK 
RED=LS_RELATION.S.LINK 
RED=LS_RELATION.CHECK 
RED=LS_RELATION.MATCH 
;;; Reading source file "prog/red/reduction.lisp"
;;; GC: 238588 words [954352 bytes] of dynamic storage in use.
;;; 433154 words [1732616 bytes] of free storage available before a GC.
;;; 1104896 words [4419584 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/red/reduction.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          CONS-CONSTRUCT.LINKS was referenced by
;;;             RED=CTL_REMOVE.LITERAL
;;;          CONS-RECONSTRUCT.LINKS was referenced by
;;;             RED=CTL_RECONSTRUCT
;;;          SEL-WEIGHT was referenced by RED=INFO_LINK.RESULT.PUT
;;; Loading binary file "prog/red/reduction.sbin"
;;; Loading source file "prog/op/construct.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CONS*CLAUSES 
CONS*CLAUSECOUNTER 
CONS*LINK.COLOURS 
CONS*EQ.OCCURRENCES.NEG 
CONS*EQ.OCCURRENCES.POS 
CONS*RW.CLAUSES 
CONS*RW_EQ.OCCURRENCES.NEG 
CONS*RW_EQ.OCCURRENCES.POS 
CONS*NO.LINK.CLAUSES 
CONS=SORT 
CONS-CONSTRUCT.ATTRIBUTE.CLAUSES 
CONS-CONSTRUCT.LINKS 
CONS-RESET 
CONS-VIRTUAL.GRAPH 
CONS-RECONSTRUCT.LINKS 
CONS=CONSTRUCT.LINKS 
CONS-CONSTRUCT.PLINKS 
CONS=CREATE.PLINKS 
CONS=PLINKS.TO.LITERAL 
CONS=PLINKS.TO.TERM 
CONS=PLINKS.TO.TOPLEVEL.OF.TERM 
CONS=PLINKS.BETWEEN.TERM.AND.EQUALITY 
CONS=PIW.COMPLETION.TERM 
CONS=PIW.COMPLETION.FCT 
CONS=PIW.COMPLETION 
CONS=PLINKS.TO.SAME.TERM 
CONS=PLINK.INSERT 
CONS=RW_CONSTRUCT.LINKS 
CONS=RECREATE.PLINKS 
CONS=RW_PLINKS.TO.SAME.TERM 
CONS=EQ.OCCURRENCES 
CONS=PREDICATE.OCCURRENCES 
CONS=PRED.OCCURRENCES.IN.CLAUSES 
CONS=EQ.OCCURRENCES.IN.CLAUSES 
CONS=EXISTING.GRAPH.CLAUSES 
;;; Reading source file "prog/op/construct.lisp"
;;; Writing binary file "prog/op/construct.sbin"
;;; Loading binary file "prog/op/construct.sbin"
;;; Loading source file "prog/ctl/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP-INITIAL.GRAPH 
PREP-PROBLEM.SPECIFICATION 
PREP-INIT 
PREP-END 
PREP-OPEN.PROTOCOL 
PREP-CLOSE.PROTOCOL 
PREP-VIRTUAL.PARTIAL.GRAPH 
PREP-VIRTUAL.INITIAL.GRAPH 
PREP-CREATE.EMPTY.GRAPH 
PREP-EXTEND.GRAPH 
PREP-REDUCE.INITIAL 
PREP-SUBSUMPTION.TEST 
PREP=INIT 
PREP=END 
PREP=READ.PROBLEM.FILE 
PREP=CREATE.AXIOMGRAPH 
PREP=CREATE.INITIAL.GRAPHS 
PREP=ADD.THEOREM 
PREP=CREATE.SPLITGRAPHS 
PREP=REDUCE.INITIAL 
PREP=GET.INSERTED 
PREP=ADD.CLAUSE 
PREP=CREATE.UNIT.FACTORS 
PREP=REDUCE.PARTIAL 
PREP=THEOREMS.CLAUSE.LISTS 
PREP=NEGATION.OF.CONJUNCTION 
PREP=REMOVE.COMMENTS 
PREP=ELIMINATE.EQUALITY 
PREP=PREDICATE.OCCURS.IN 
PREP=CREATE.EMPTY.GRAPH 
PREP=CREATE.EMPTY.PARTIAL.GRAPH 
PREP=VIRTUAL.PARTIAL.GRAPH 
PREP=VIRTUAL.INITIAL.GRAPH 
PREP=CREATE.CLAUSES 
PREP=PR_OPEN 
PREP=PR_CLOSE 
PREP=PR_INFIX.FORM 
PREP=PR_PREFIX.FORM 
PREP=PR_OPTIONS 
PREP=PR_AXIOMS.START 
PREP=PR_AXIOMS.END 
PREP=PR_THEOREMS.START 
PREP=PR_THEOREMS.END 
PREP=PR_PREPROCESSED.PREFIX.FORMULA 
PREP=PR_PARTIAL.GRAPH 
PREP=PR_INITIAL.GRAPH 
PREP=PR_CHANGES 
PREP=PR_GRAPH.DUMP 
PREP=PR_STATISTICS 
PREP=PR_PRINT.MESSAGE 
PREP=PR_PRINT.MESSAGE.FULL.LINE 
PREP=PR_PRETTY.LIST.EXPRESSION 
PREP=PR_PRETTY.EXPRESSION 
PREP=PR_PREFIX.EXPRESSION 
PREP*AXIOM.GRAPH.FILE 
PREP*AXIOM.GRAPH.FILE.## 
PREP*PROBLEM.FILE 
PREP*GRAPH.FILE 
PREP*SEVERAL.SPLITPARTS 
PREP*STEPNUMBER 
PREP*NUMBER.OF.AXIOM.CLAUSES 
PREP*AXIOMS.INFIX 
PREP*AXIOMS.PREFIX 
PREP*THEOREMS.INFIX 
PREP*THEOREMS.PREFIX 
PREP*COMMENT 
PREP*TRACE.OUTPUTSTREAM 
PREP*TRACE.OUTPUTSTREAM.LINELENGTH 
;;; Reading source file "prog/ctl/preparation.lisp"
;;; While compiling PREP-SUBSUMPTION.TEST
;;; Warning: DS-CLAUSE.IS is a macro; (FUNCTION DS-CLAUSE.IS) is probably incorrect
;;; While compiling PREP=CREATE.INITIAL.GRAPHS
;;; Warning: Free variable OS*OPENED.P assumed to be special
;;; Warning: Free variable OS*ACTUAL.GRAPH.FILE assumed to be special
;;; Writing binary file "prog/ctl/preparation.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          SEL-SAVE.RESET was referenced by
;;;             PREP=VIRTUAL.INITIAL.GRAPH
;;;          TWO-DUMP was referenced by PREP=PR_GRAPH.DUMP
;;; Loading binary file "prog/ctl/preparation.sbin"
;;; Loading source file "prog/c/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP.C-INITIAL.GRAPH 
PREP.C=INIT 
PREP.C=END 
PREP.C=CREATE.AXIOMGRAPH 
PREP.C=CREATE.INITIAL.GRAPHS 
PREP*SPS 
PREP.C=PRINT.SPLITPARTS.OBJECTS 
PREP.C=PRINT.SPLITPARTS 
PREP.C=CREATE.SPLITGRAPHS 
PREP.C=PRINT.CLAUSELIST 
PREP.C=PRINT.LITLIST 
PREP.C=PRINT.CLAUSE 
PREP.C=PRINT.TERMLIST 
PREP.C=PRINT.TERM 
PREP.C=PRINT.CLAUSE.OBJECTS 
PREP.C=PRINT.TERM.OBJECTS 
PREP.C=PRINT.FUN.LIST 
;;; Reading source file "prog/c/preparation.lisp"
;;; While compiling PREP.C=INIT
;;; Warning: Free variable PREP*OBJECTS assumed to be special
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; While compiling PREP.C=CREATE.SPLITGRAPHS
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; While compiling PREP.C=PRINT.TERM.OBJECTS
;;; Warning: Free variable PREP*OBJECTS assumed to be special
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; Writing binary file "prog/c/preparation.sbin"
;;; Loading binary file "prog/c/preparation.sbin"
;;; Loading source file "prog/e/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP*OBJECTS 
PREP.ER-INITIAL.GRAPH 
PREP.ER=INIT 
PREP.ER=END 
PREP.ER=CREATE.AXIOMGRAPH 
PREP.ER=CREATE.INITIAL.GRAPHS 
PREP.ER=CREATE.SPLITGRAPHS 
PREP.ER=PRINT.CLAUSE 
PREP.ER=PRINT.TERM 
;;; Reading source file "prog/e/preparation.lisp"
;;; Writing binary file "prog/e/preparation.sbin"
;;; Loading binary file "prog/e/preparation.sbin"
;;; Loading source file "prog/term/mergeinst.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MI*INFORMATION 
MI*FULL.UNIFICATION 
MI-CREATE.EMPTY.TERMSTRUCTURE 
MI-INSERT.TERMLIST.INTO.TERMSTRUCTURE 
MI-INSERT.SUBSTITUTION.INTO.TERMSTRUCTURE 
MI-MERGE.TERMSTRUCTURES 
MI=TERMLIST.IS.NOT.TOO.DEEP 
MI-MERGE 
MI-TERMLIST.INSTANCE 
MI-SUBSTITUTION.INSTANCE 
MI-TERMLIST.STANDARD 
MI-TERMLIST.STANDARD.FULL 
MI-TERMLIST.PROPERTY 
MI-TERMLIST.AUXILIARY 
MI-TERMLIST.PUT.AUXILIARY 
MI-TERMSTRUCTURE.TERMLISTS 
MI=TERMSTRUCTURE_INSERT.TERMLIST.1 
MI=TERMSTRUCTURE_INSERT.TERMLIST.2 
MI=SUBTERMSTRUCTURE_INSERT.TERM 
MI=SUBTERMSTRUCTURE_INSTANCETEST 
MI=OCCURRENCE.TREE 
MI*DUMMY.BUFFER 
MI=TERMS.ARE.RENAMED 
MI=RENAMING.FAILURE 
MI=SUBTERMSTRUCTURE_CREATE.TLINKS 
MI=FUNCTIONLIST_RESET.AUXILIARY 
MI=TYPE 
MI=UNIFIER.IS.VARIABLE.RENAMING 
MI=SUBSTITUTION.TO.TERMLIST 
MI-DUMP 
MI=DUMP.SUBTERMSTRUCTURE 
MI=INTERSECT.POSITIONLISTS 
MI=CUT.TARGETPATTERN 
MI=INSTANCE.TEST 
MI=MERGE.DISJOINT.TERMSTRUCTURES 
MI=MERGE.DISJOINT 
MI=TERMLIST.VARIABLES 
MI=CREATE.TLINKS 
MI=MERGE.CLEAR.AUXILIARY 
MI=SUBSET 
MI=INTERSECT 
MI=TERMSTRUCTURE_INITIALIZE 
MI=TERMSTRUCTURE_ADD.EXPRESSION 
MI=TERMSTRUCTURE_POSITIONLIST 
MI=TERMSTRUCTURE_PATTERN 
MI=TERMSTRUCTURE_EXPRESSIONS 
MI=TERMSTRUCTURE_PATTERN.LENGTH 
MI=TERMSTRUCTURE_T.LENGTH 
MI=TERMSTRUCTURE_VARIABLE.PATTERN 
MI=TERMSTRUCTURE_ARITY 
MI=SINGLETERMS_INITIALIZE 
MI=SINGLETERMS_CONSTANTS 
MI=SINGLETERMS_VARIABLES 
MI=SINGLETERMS_ABBREVIATIONS 
MI=SINGLETERMS_THEORYTERMS 
MI=SINGLETERMS_COMPOSEDTERMS 
MI=SINGLETERMS_ADD.EXPRESSION 
MI=SUBTERMSTRUCTURE_CREATE.EMPTY.FUNCTIONLIST 
MI=SUBTERMSTRUCTURE_ADD.FUNCTIONLIST 
MI=SUBTERMSTRUCTURE_ADD.EXPRESSION 
MI=SUBTERMSTRUCTURE_EXPRESSIONS 
MI=SUBTERMSTRUCTURE_FUNCTIONLIST 
MI=EXPRESSION_INITIALIZE 
MI=EXPRESSION_PROPERTY 
MI=EXPRESSION_PUT.PROPERTY 
MI=EXPRESSION_FUNCTION 
MI=EXPRESSION_STANDARDTERM 
MI=EXPRESSION_AUXILIARY 
MI=EXPRESSION_PUT.AUXILIARY 
MI=EXPRESSION_INCREMENT.AUXILIARY 
MI=EXPRESSION_RESET.AUXILIARY 
MI=EXPRESSION_INSERT.TLINK 
MI=EXPRESSION_TLINKS 
MI=EXPRESSION_SUBTERMS 
MI=EXPRESSION_PUT.SUBTERMS 
MI=EXPRESSION_SUPERTERMS 
MI=EXPRESSION_ADD.SUPERTERM 
MI=EXPRESSION_INCREMENT.SUPERTERMS 
MI=EXPRESSION_CREATE.EMPTY.SINGLETERMS 
;;; Reading source file "prog/term/mergeinst.lisp"
;;; While compiling MI=TERMSTRUCTURE_INITIALIZE
;;; Warning: Variable ELEMENT is bound but not referenced
;;; Writing binary file "prog/term/mergeinst.sbin"
;;; Loading binary file "prog/term/mergeinst.sbin"
;;; Loading source file "prog/term/terminator.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
TERM-TERMINATOR 
TERM-1_TERMINATOR 
TERM-2_TERMINATOR 
TERM-3_TERMINATOR 
TERM-DUMP 
TERM=CLEAR 
TERM=INITIALIZATION 
TERM=TOPOLOGICALLY.RELEVANT.CLAUSES 
TERM=CREATE.INITIAL.UNITS 
TERM=TRIVIAL.PROOF 
TERM=CREATE.MARKS 
TERM=SORT.NOTUNITCLAUSES 
TERM=SORT 
TERM=CREATE.PATTERNS 
TERM=UNINODES.FROM.SILINKS 
TERM=ITERATIONS 
TERM=CREATE.UNITS 
TERM=CREATE.NEW.HINTS 
TERM=SET.UNINODE 
TERM=EXAMINE.CLAUSE 
TERM=DEDUCE.UNITS 
TERM=COMPATIBILITY.TEST.FULL 
TERM=CREATE.INITIAL.TULISTS 
TERM=PREPARE.CLAUSE 
TERM=MERGE.LIST.OF.TULISTS 
TERM=NOT.OLD.WITH.OLD 
TERM=TARGETPATTERN 
TERM=QUOTIENT 
TERM=GET.TULISTS 
TERM=SORT.TULISTS 
TERM=SORT.EXPAND 
TERM=SORT.REPLACE 
TERM=CUT.TULISTS 
TERM=LINEARIZE.UNITS 
TERM=LINEARIZATION 
TERM=LINEARIZATION.LITNO 
TERM=SUBSET.NODES 
TERM=BIND 
TERM=UNBIND 
TERM=MERGE 
TERM=CYCLE 
TERM=CREATE.INITIAL.TRUNIFIERS 
TERM=TRACE.UNIFIER.UNINODES 
TERM=UNIFIER.NORMALIZE 
TERM=IS.TAUTOLOGY 
TERM=1_ITERATIONS 
TERM=1_EXAMINE.CLAUSE 
TERM=1_CREATE.SLTU 
TERM=1_LINEARIZE 
TERM=1_COMPATIBILITY.TEST.PARTIAL 
TERM=2_ITERATIONS 
TERM=3_INITIALIZATION 
TERM=3_CREATE.INITIAL.UNITS 
TERM=3_CREATE.MARKS 
TERM=3_ITERATIONS 
TERM=GENERATOR.LITERALS 
TERM=NESTING.COUNTER 
TERM=UNIT.ADD.NEW.PREDICATELIST 
TERM=UNIT.PREDICATELIST.SIGNLIST 
TERM=UNIT.PREDICATELIST.TRANSFORMATIONS 
TERM=UNIT.CREATE.PARTIAL 
TERM=UNIT.MAKE.TERMLIST 
TERM=UNIT.SET.AUXILIARY 
TERM=UNIT.AUXILIARY 
TERM=UNIT.UNIFIER 
TERM=UNIT.CLAUSE 
TERM=UNIT.NODES 
TERM=UNIT.COUNTER 
TERM=UNIT.SET.COUNTER 
TERM=UNIT.DELETE.NODES 
TERM=CREATE.PSEUDOUNIT 
TERM=HINT.CREATE 
TERM=HINT.UNITS 
TERM=HINT.LINK 
TERM=HINT.IS.ACTIVE 
TERM=HINT.ACTIVATE 
TERM=UNINODE.CREATE 
TERM=UNINODE.UNIFIER 
TERM=UNINODE.LINK 
TERM=UNINODE.UNIT 
TERM=UNINODE.PUT.UNIT 
TERM=UNINODE.IS.NEW 
TERM=UNINODE.MARK.OLD 
TERM=TULIST.CREATE 
TERM=TULIST.LITNOS 
TERM=TULIST.TRACE.UNIFIERS 
TERM=TULIST.IS 
TERM=SLTU.LINK.SUBSTITUTION 
TERM=SLTU.TUNIFIER 
TERM=SLTU.UNINODES 
TERM=SLTU.PUT.TUNIFIER 
TERM=SLTU.PUT.UNINODES 
TERM=STANDARD.UNIFIER 
TERM=APPLY.UNIFIER 
TERM=CLAUSE.LIT.ADDPROP 
TERM=NORMALIZE.SIGN 
TERM=NORMALIZE.PREDICATE 
TERM=NORMALIZE.UNIT 
TERM=NO.NORMALIZING.UNITS 
TERM*UNITS 
TERM*SOLUTION 
TERM*NEW.VARIABLES 
TERM*NOTUNITCLAUSES 
TERM*UNITCOUNTER 
TERM*UNITCOUNTER.PARTIAL 
TERM*UNITCOUNTER.TOTAL 
TERM*UNIFIERCOUNTER.PARTIAL 
TERM*UNIFIERCOUNTER.TOTAL 
TERM*FILE 
TERM*TERMINAL 
TERM*PRINT.UNITS 
TERM*INSTANCETEST 
TERM*GENERATOR.LIMIT 
TERM*NORMALIZING.LITERALS 
TERM*3_PSEUDOCONSTANTS 
TERM*3_VARIABLES.REGARDED.AS.CONSTANTS 
TERM*3_RENAMING 
IND.SIMPL.UNIT 
DIRECT.SIMPL 
IND.SIMPL 
TERM*SIMPLIFICATION 
TERM=SIMPLIFY.UNIT 
TERM=ACCESS.FCT 
TERM=EXTRACT.ACCESS.FCT 
TERM=RECOGNIZE.SIMPLIFIER 
TERM=INDIRECT.SIMPLIFIER.UNIT 
TERM=DIRECT.SIMPLIFY.TERM 
TERM=DIRECT.SIMPLIFY.UNIT 
TERM=INDIRECT.SIMPLIFY.UNIT 
TERM=SIMP.UNIT.IS.NOT.SUBSUMED 
TERM=RENAME 
TERM=TEST.UNIT 
TERM*SIMPLIFICATION.PRINT 
TERM*SIMPLIFICATION.STREAM 
TERM=SIMPLIFICATION.PRINT 
;;; Reading source file "prog/term/terminator.lisp"
;;; While compiling TERM=TOPOLOGICALLY.RELEVANT.CLAUSES
;;; Warning: Variable X is bound but not referenced
;;; While compiling TERM=1_LINEARIZE
;;; Warning: TERM=SLTU.TUNIFIER is a macro; (FUNCTION TERM=SLTU.TUNIFIER) is probably incorrect
;;; While compiling TERM=1_COMPATIBILITY.TEST.PARTIAL
;;; Warning: TERM=SLTU.TUNIFIER is a macro; (FUNCTION TERM=SLTU.TUNIFIER) is probably incorrect
;;; While compiling TERM=NORMALIZE.UNIT
;;; Warning: Variable X is bound but not referenced
;;; Writing binary file "prog/term/terminator.sbin"
;;; Loading binary file "prog/term/terminator.sbin"
;;; Loading source file "prog/sel/selection.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=MANUAL 
SEL=FACTORIZE 
SEL=REDUCTIONS 
SEL=ELIMINATE 
SEL=MERGING 
SEL=INDUCTION 
SEL=TERMINATOR 
SEL=TERMINATOR.UNITS 
SEL=STRATEGIES 
SEL=CHAIN 
SEL*OPERATION.STACK 
SEL*ACTUAL.OPERATION 
SEL*REDUCE.DEDUCE 
SEL*INITIAL.FLAG 
SEL*FINAL.ACTIONS 
SEL*OPERATIONS 
SEL*LINK.CLASSES 
SEL*CLAUSE.CLASSES 
SEL*CLAUSELISTS 
SEL*LINKLISTS 
SEL*TERMINATOR.NEW.CLAUSES 
SEL*REDUCTION.FLAG 
SEL-INITIALIZE 
SEL-END 
SEL-UPDATE.REDUCE 
SEL-UPDATE.DEDUCE 
SEL-MARKED.CLAUSES 
SEL-DEDUCTION.CODE.LINK 
SEL-DEDUCTION.CODE.UNIFIER 
SEL-REDUCTION.CODE.CLAUSES.TO.BE.REDUCED 
SEL-REDUCTION.CODE.CLAUSES.TO.BE.REMOVED 
SEL-REDUCTION.CODE.UNIFIERS.TO.BE.REMOVED 
SEL-REDUCTION.CODE.LITERALS.TO.BE.REMOVED 
SEL-REFUTATION.RESULT 
SEL-REDUCTION.FLAG 
SEL=ELIMINATE 
SEL=ELIMINATE.ACTIVATE? 
SEL=ELIMINATE.UPDATE 
SEL=ELIMINATE.IS.ELIMINATING.LINK 
SEL=IS.ELIMINATING.EQUALITY 
SEL=INDUCTION.ACTIVATE? 
SEL=SHORTEN.TREE 
SEL=SIMPLIFY.TREE 
SEL=ACTIVATE.LITNO 
SEL=IND.ELIMINATE 
SEL=IND.REDUCTION 
SEL=GET.NEXT.EVAL.CLAUSE 
SEL=GET.NEXT.EVAL.LINKS 
SEL=GET.APPLICABLE.LINKS 
SEL=GET.OPTIMIZED.LINKS 
SEL=SELECT.EVAL.LINK 
SEL=GET.ALL.RELEVANT.LINK.CHAINS 
SEL=GET.EVAL.CHAIN 
SEL=FORMAT.EVAL.CHAIN 
SEL=GET.EVAL.LINK 
SEL=GET.PARALLEL.LINK 
SEL=INDUCTION.UPDATE 
SEL=INHERIT.LINKS.AND.LITERALS 
SEL=INHERIT.LITERALS 
SEL=MERGE.LITERALS 
SEL=REMOVE.LINK.FROM.EVAL 
SEL=INSERT.ALL.EVAL.LINKS 
SEL=INSERT.EVAL.PLINKS 
SEL=INSERT.EVAL.RLINKS 
SEL=PUT.MATCH.CHAIN 
SEL=INDUCTION 
SEL=PREPARE.EVAL.CHAINS 
SEL=GET.REFUTATION.CHAIN 
SEL=GET.REFUTATION 
SEL=IS.COMPLETE.REFUTATION 
SEL=GET.CILS.LIST 
SEL=IS.EQUALITY 
SEL=IS.INDUCTION.HYPOTHESIS 
SEL=IS.PART.OF.EQUIVALENCE 
SEL=IS.TERMINAL.RULE 
SEL=SORT.EQUIVALENCES 
SEL=SORT.EQUALITIES 
SEL=CONNECT.EQUIVALENCES 
SEL=COMPUTE.ALL.NEW.IF.CLAUSES 
SEL=COMPUTE.NEW.IF.CLAUSES 
SEL=INSERT.NEW.IF.CLAUSE 
SEL=GET.EQUIVALENT.LITERALS 
SEL=LITERALS.ARE.EQUIVALENT 
SEL=SUBST.LITLIST 
SEL=PERMUTE.LITLIST 
SEL=GET.VARIABLE.RENAMING 
SEL=GET.MERGING.LITERALS 
SEL=IF.CLAUSE.GET 
SEL=IF.CLAUSE.PUT 
SEL=SUBNODE.GET 
SEL=SUBNODE.PUT 
SEL=IND.GET.OPTION 
SEL=IND.PUT.OPTION 
SEL=RESET.TREE 
SEL=NEXT.NODE 
SEL=NEXT.SUBNODE 
SEL=ACTUAL.NODE 
SEL=ACTUAL.SUBNODE 
SEL=GET.SUBNODE 
SEL=SUBTREE.OF 
SEL=REPLACE.NODE 
SEL=REMOVE.SUBTREE 
SEL=RENUMBER.TREE 
SEL*ACTUAL.CLAUSES 
SEL*STEPCOUNTER 
SEL*STEPS 
SEL*TREE.POINTER.1 
SEL*TREE.POINTER.2 
SEL*IND.CASE.COUNTER 
SEL*IND.CHAIN 
SEL*IND.ACTUAL.ENTRY 
SEL*IND.SINGLE.LINK 
SEL*END.OF.INDUCTION 
SEL*IND.OLD.CLAUSES 
SEL*IND.NEW.CLAUSES 
SEL*IND.OLD.LINKS 
SEL*IND.OPTIONS 
SEL=CLASSIFY.CLAUSES 
SEL=WEIGTH_SET.FOREIGN 
SEL=WEIGTH_SYMBOL.WEIGHT 
SEL-WEIGHT 
SEL=WEIGHT_EVAL 
SEL=STRAT_VALUE 
SEL=STRAT_BASIC.VALUE 
SEL=STRAT_TOTAL.VALUE 
SEL=STRAT_ACTIVE.PLINK 
SEL=STRAT_ACTIVE.RLINK 
SEL=STRATEGIES 
SEL=LINK.VARIABLES 
SEL=STRATEGIES.ACTIVATE? 
SEL=STRATEGIES.ACTIVATE?.EXEC 
SEL=STRATEGIES.UPDATE 
SEL=STRATEGIES.UPDATE.EXEC 
SEL=STR.LABEL 
SEL=STR.DEFINE.STRATEGY 
SEL=HORN.RENAMABLE.TEST 
SEL=STR.SET.LINEAR.TOP.CLAUSE 
SEL=STR.LINEAR.CONNECTED.TO.TOP.CLAUSE 
SEL*STR_RESOLUTION.STRATEGY 
SEL*STR_PARAMODULATION.STRATEGY 
SEL*STR_LINEAR.TOP.CLAUSE 
SEL*LINKS_RPASSIVE 
SEL*LINKS_PACTIVE 
SEL*LINKS_PPASSIVE 
SEL*LINKS_RINHIBITED 
SEL*LINKS_PINHIBITED 
SEL=REDUCTIONS 
SEL=REDUCTIONS.ACTIVATE? 
SEL=REDUCTIONS.UPDATE 
SEL=REDUCTIONS.BOTH.PARENTS.PURE 
SEL=REDUCTIONS.RESOLVENT.REPLACES.PARENT 
SEL=MERGING 
SEL=MERGING.ACTIVATE? 
SEL=MERGING.UPDATE 
SEL=FACTORIZE 
SEL=FACTORIZE.ACTIVATE? 
SEL=FACTORIZE.UPDATE 
SEL=TERMINATOR 
SEL=TERMINATOR.ACTIVATE? 
SEL=TERMINATOR.UPDATE 
SEL=TERMINATOR.UNITS 
SEL=TERMINATOR.UNITS.ACTIVATE? 
SEL=TERMINATOR.UNITS.UPDATE 
SEL*TERMINATOR.PROVED.FLAG 
SEL*TERMINATOR.LOOK 
SEL=LINK.NOLIT 
SEL=LINK.NOLIT.UNIFY.P 
SEL=LINK.NOLIT.MERGES 
SEL=LINK.NOLIT.AFFECTED.MERGE 
SEL=MAKE.DEDUCTION.CODE 
SEL=MAKE.REDUCTION.CODE 
SEL=CLEAR.LINK.CLASSES 
SEL*LINKS_RACTIVE 
SEL*LINKS_PIWACTIVE 
SEL*LINKS.COLOUR.FLAG_ACTIVE 
SEL*LINKS.COLOUR.FLAG_PASSIVE 
SEL*LINKS.COLOUR.FLAG_INHIBITED 
SEL*LINKS_REDUCTIONS 
SEL*LINKS.COLOUR.FLAG_REDUCTIONS 
SEL=CLEAR.CLAUSE.CLASSES 
SEL*CLAUSES_SUPPORTED 
SEL*CLAUSES_INDUCTION 
SEL*CLAUSES_EQUIVALENCE 
SEL*CLAUSES_EQUALITY 
SEL*CLAUSES_IMPLICATION 
SEL*CLAUSES_DEDUCTION-RULES 
SEL*CLAUSES_ELIMINATINGEQUATIONS 
SEL*TERMINATOR.LOOK.NEW.CLAUSES 
SEL=UPDATE.CLAUSELISTS 
SEL=UPDATE.LINKLISTS 
SEL=LINKS 
SEL=CLAUSES 
SEL=INSERT.LINK 
SEL=INSERT.CLAUSE 
SEL=REMOVE.LINK 
SEL=REMOVE.CLAUSE 
SEL=PASSIVATE 
SEL=INHIBIT 
SEL=CHAIN 
SEL*CHAIN 
SEL*CHAIN.DELETE.INTERMEDIATE.RESULTS 
SEL*CHAIN.UNITS 
SEL*CHAIN.LINKS 
SEL*CHAIN.TAIL 
SEL*ACTUAL.DEDUCTION.CODE 
SEL*ACTUAL.REDUCTION.CODE 
SEL*DUMMY 
SEL=PASS.CONTROL 
SEL=NEXT.OPERATION 
SEL=RETURN 
SEL=UPDATE 
SEL=LINK.&.TERM.DEPTH.TREATMENT 
SEL=NO.REFUTATION.POSSIBLE? 
SEL=REFUTATION.FOUND 
SEL-SAVE.RESET 
SEL-SAVE 
;;; Reading source file "prog/sel/selection.lisp"
;;; While compiling SEL=INDUCTION.ACTIVATE?
;;; Warning: Variable X is bound but not referenced
;;; While compiling SEL=SIMPLIFY.TREE
;;; Warning: Variable NODE is bound but not referenced
;;; While compiling SEL=GET.NEXT.EVAL.CLAUSE
;;; Warning: Variable LITLIST is bound but not referenced
;;; While compiling SEL=CHAIN
;;; Warning: DS-LINK.IS is a macro; (FUNCTION DS-LINK.IS) is probably incorrect
;;; Writing binary file "prog/sel/selection.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          SEL=STR.INIT.MARK.RLINKS was referenced by
;;;             SEL=STRATEGIES.ACTIVATE?.EXEC
;;;          SEL=STR.INIT.MARK.PLINKS was referenced by
;;;             SEL=STRATEGIES.ACTIVATE?.EXEC
;;;          SEL=STR.MARK.RLINKS was referenced by
;;;             SEL=STRATEGIES.UPDATE.EXEC
;;;          SEL=STR.MARK.PLINKS was referenced by
;;;             SEL=STRATEGIES.UPDATE.EXEC
;;;          SEL=STR.MARK.SILINKS was referenced by
;;;             SEL=FACTORIZE.UPDATE
;;;          SEL=MARK.UPDATE.B.G was referenced by SEL=UPDATE
;;;          SEL=MARK.UPDATE.S.L was referenced by SEL=UPDATE
;;;          SEL=MARK.UPDATE.D was referenced by SEL=UPDATE
;;;          SEL=MARK.UPDATE.Z.K was referenced by SEL=UPDATE
;;;          SEL=MARK.UPDATE.H.C was referenced by SEL=UPDATE
;;;          SEL=SAVE.RESET was referenced by SEL-SAVE
;;; Loading binary file "prog/sel/selection.sbin"
;;; Loading source file "prog/sel/sel-mark.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=STR.INIT.MARK.RLINKS.SOS 
SEL=STR.INIT.MARK.RLINKS 
SEL=STR.MARK.RLINKS.SOS 
SEL=STR.MARK.SILINKS 
SEL=STR.MARK.RLINKS 
SEL=STR.INIT.MARK.PLINKS 
SEL=STR.MARK.PLINKS 
SEL=STR.MARK.PLINK.Z.K 
SEL=STR.MARK.SILINK.Z.K 
SEL=CLAUSE.LITERAL 
SEL=STR.MARK.PLINK.B.G.SPLIT 
SEL=STR.MARK.PLINK.B.G.SPLIT.SIBLING 
SEL=STR.MARK.PLINK.B.G.SIBLING 
SEL=STR.MARK.PLINK.B.G.STRICT.MAX.P 
SEL=STR.MARK.PLINK.B.G.MAX.P 
SEL=STR.MARK.PLINK.B.G.REDUCTIVE 
SEL=STR.MARK.PLINK.B.G.STRICT.P 
SEL=STR.MARK.PLINK.B.G.MERGE.P 
SEL=STR.MARK.SILINK.B.G 
SEL=STR.MARK.RLINK.B.G.IS 
SEL=STR.MARK.RLINK.B.G 
SEL=STR.MARK.PLINK.B.G.IS 
SEL=STR.MARK.PLINK.B.G 
SEL=STR.MARK.PLINK.H.C 
SEL=STR.MARK.PLINK.S.L.IS 
SEL=STR.MARK.PLINK.S.L 
SEL=STR.MARK.PLINK.D.IS 
SEL=STR.MARK.PLINK.D 
SEL=STR.MARK.PLINK 
SEL=MARK.UPDATE.S.L 
SEL=MARK.UPDATE.D 
SEL=MARK.UPDATE.B.G 
SEL=MARK.UPDATE.Z.K 
SEL=MARK.UPDATE.H.C 
;;; Reading source file "prog/sel/sel-mark.lisp"
;;; Writing binary file "prog/sel/sel-mark.sbin"
;;; Loading binary file "prog/sel/sel-mark.sbin"
;;; Loading source file "prog/sel/sel-manual.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=MANUAL 
SEL=MANUAL.EXEC 
SEL=MANUAL.ACTIVATE? 
SEL=PRINT.TO.STRING 
SEL=MANUAL.LIST.ITEMS 
SEL=MANUAL.MENU 
SEL=MANUAL.UPDATE 
;;; Reading source file "prog/sel/sel-manual.lisp"
;;; Writing binary file "prog/sel/sel-manual.sbin"
;;; Loading binary file "prog/sel/sel-manual.sbin"
;;; Loading source file "prog/ctl/control.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CTL-REFUTE.GRAPHS.ON.FILE 
CTL-REFUTE.GRAPHS.ON.FILE1 
CTL-REFUTE.GRAPH.ON.FILE 
CTL-REFUTE.GRAPH 
CTL-INITIAL.GRAPH 
CTL*SPLITPARTS.REMAINING.FILES 
CTL*SPLITPARTS.INPUTSTREAM 
CTL*SPLITPARTS.INPUTSTREAM.COUNTER 
CTL*SPLITPARTS.RESULTS 
CTL*SPLITPART.FLAG 
CTL*CURRENT.SPLITPART.IDENTIFIER 
CTL*CURRENT.SPLITPART.INITIAL.REDUCTION.FLAG 
CTL*CURRENT.SPLITPART.INITIAL.SELECTION.FLAG 
CTL*CURRENT.SPLITPART.RESULT 
CTL*STEPCOUNTER 
CTL*PROOFTIME 
CTL*ABORT.FLAG 
CTL*ABORT.MACRO 
CTL=OPEN.AND.ADVANCE.FILE 
CTL=START 
CTL=END 
CTL=REFUTE.SPLITPARTS 
CTL=REFUTE.SPLITPARTS1 
CTL=REFUTE 
CTL=REDUCE.INITIAL 
CTL=INFERENCE.LOOP 
CTL=INFERENCE.STEP 
CTL=DEDUCE 
CTL=DEDUCE.UNITFACTORS 
CTL=REDUCE.PARTIAL 
CTL=REDUCE 
CTL=SAVE 
CTL=SAVE.FILENAME 
CTL*TRACE.OPEN.FLAG 
CTL*TRACE.OUTPUTSTREAM 
CTL*TRACE.OUTPUTSTREAM.LINELENGTH 
CTL=PR_OPEN 
CTL=PR_CLOSE 
CTL=PR_OPTIONS 
CTL=PR_REFUTATION.START 
CTL=PR_REFUTATION.END 
CTL=PR_CURRENT.GRAPH 
CTL=PR_CHANGES 
CTL=PR_GRAPH.DUMP 
CTL=PR_STATISTICS 
CTL=PR_MESSAGE 
CTL=PR_MESSAGE.FULL.LINE 
;;; Reading source file "prog/ctl/control.lisp"
;;; Writing binary file "prog/ctl/control.sbin"
;;; Warning: The following function is not known to be defined:
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by CTL=START
;;; Loading binary file "prog/ctl/control.sbin"
;;; Loading source file "prog/os/os-explanation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OS.E-GET.EXPLANATION 
OS.E=HELP 
OS.E=COMMON.ERROR.MESSAGE_COMMAND.IGNORED 
OS.E=@ATP_SESSION.LANGUAGE 
OS.E=@ATP_INFO.AND.REPAIR.FILE 
OS.E=@ATP_EXPLAIN.HELP 
OS.E=READ&EXECUTE.ATP.COMMAND_START.EDIT 
OS.E=READ&EXECUTE.ATP.COMMAND_ERROR=ILLEGAL.COMMAND 
OS.E=VDT_ERROR=ILLEGAL.ARGUMENT 
OS.E=HARDCOPY_ERROR=ILLEGAL.ARGUMENT 
OS.E=HELP_V 
OS.E=HELP_VP 
OS.E=HELP_HP 
OS.E=HELP_HC 
OS.E=HELP_HELP 
OS.E=HELP_EXIT 
OS.E=HELP_LOGOFF 
OS.E=HELP_LISP 
OS.E=HELP_OPTIONS 
OS.E=HELP_INDUCTION 
OS.E=HELP_CONSTRUCT 
OS.E=HELP_CONSTRUCT.REFUTE 
OS.E=HELP_CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_EDIT 
OS.E=HELP_EDIT.CONSTRUCT 
OS.E=HELP_EDIT.CONSTRUCT.REFUTE 
OS.E=HELP_EDIT.CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_FORMULA 
OS.E=HELP_FORMULA.CONSTRUCT 
OS.E=HELP_FORMULA.CONSTRUCT.REFUTE 
OS.E=HELP_FORMULA.CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_REFUTE 
OS.E=HELP_REFUTE.PROTOCOL 
OS.E=HELP_PROTOCOL 
OS.E=HELP_COMMAND.NOT.IMPLEMENTED 
OS.E=HELP_DEFINE.DIRECTORY 
OS.E=HELP_DEFINE.EXAMPLE.NAME 
OS.E=HELP_SELECT.EXAMPLE 
OS.E=HELP.EXPLANATION_EXPLAIN.HELP 
OS.E=INDUCTION_ENTER.THEORY 
OS.E=ERROR.ILLEGAL.FILE 
OS.E=ERROR.NO.FILE.EXISTS 
OS.E=ERROR.ILLEGAL.ATP.VERSION 
OS.E=CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=CONSTRUCT.PROC_PROOF.COMMENT 
OS.E=CONSTRUCT.PROC_START.MESSAGE 
OS.E=CONSTRUCT.PROC_THEOREM.PROVED 
OS.E=CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=NO.PROBLEM.FILE.EXISTS 
OS.E=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.PROC_PROOF.COMMENT 
OS.E=EDIT.PROC_ERROR=NOTHING.TO.PROVE 
OS.E=EDIT.PROC_START.EDIT.AXIOMS 
OS.E=EDIT.PROC_START.EDIT.THEOREMS 
OS.E=EDIT.PROC_WARNING=NO.AXIOMS 
OS.E=EDIT.PROC_WARNING=NO.THEOREMS 
OS.E=FORMULA.CONSTRUCT.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.PROC_PROOF.COMMENT 
OS.E=PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=PROTOCOL.PROC_LIST.FILE.MESSAGE 
OS.E=REFUTE.INPUT.CONTROL_ERROR=ILLEGAL.SPLITPART.ID 
OS.E=REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=REFUTE.PROC_THEOREM.NOT.PROVED 
OS.E=REFUTE.PROC_THEOREM.PROVED 
OS.E=REFUTE.PROC_START.MESSAGE 
OS.E=FULL.LINE 
OS.E=FULL.LINES 
OS.E=REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=ILLEGAL.SPLITPART.ID 
OS.E=REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=OPTION_ENTER.MODULE 
OS.E=OPTION_ILLEGAL.OPTION.VALUE 
OS.E=OPTION_GET.HELP 
OS.E=OPT.PRINT_GET.HELP 
OS.E=OPT.READ_FILENAME? 
OS.E=OPT.READ_OPTIONS.SET 
OS.E=OPT.READ_INCONSISTENT.OPTIONS 
OS.E=OPT.WRITE_FILENAME? 
OS.E=OPT.PRETTYPRINT_FILENAME? 
OS.E=OPT.PRETTYPRINT_HEADLINE 
OS.E=OPT.PRETTYPRINT_DEFAULTVAL 
OS.E=OPT_ERROR=ILLEGAL.FILENAME 
OS.E=OPT_OUTPUT.END 
OS.E=OPT.HELP_HELP 
OS.E=OPT.HELP_PRINT 
OS.E=OPT.HELP_PPRINT 
OS.E=OPT.HELP_READ 
OS.E=OPT.HELP_WRITE 
OS.E=OPT.HELP_LISP 
OS.E=OPT.HELP_OK 
OS.E=OPT.HELP_V 
OS.E=OPT.HELP_AREA.ABBREVIATION 
OS.E=OPT.HELP_ALL.COMMANDS 
OS.E=OTHERWISE 
;;; Reading source file "prog/os/os-explanation.lisp"
;;; Writing binary file "prog/os/os-explanation.sbin"
;;; Loading binary file "prog/os/os-explanation.sbin"
;;; Loading source file "prog/os/operatingsystem.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
;;; Warning: Ignoring an unmatched right parenthesis

MKRP 
OS=INIT 
OS*READTABLE 
OS=READ&EXECUTE.ATP.COMMAND 
OS=NORMALIZE.ALLOWED.COMMAND 
@ 
OS*OPENED.P 
OS=VDT 
OS=HARDCOPY 
OS=HELP 
OS=HELP.EXPLANATION 
OS=OPEN.INPUT.FILE 
OS=OUTPUT.FILE.NAME.CHECK 
OS=INDUCTION 
OS=CONSTRUCT.AND.REFUTE 
OS=CONSTRUCT 
OS=CONSTRUCT.INPUT.CONTROL 
OS=CONSTRUCT.REFUTE 
OS=CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=CONSTRUCT.REFUTE.PROTOCOL 
OS=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=CONSTRUCT.PROC 
OS=DEFINE.DIRECTORY 
OS=DEFINE.EXAMPLE.NAME 
OS=SELECT.EXAMPLE 
OS=CLIMB.DIRECTORY 
OS=EDIT 
OS=EDIT.INPUT.CONTROL 
OS=EDIT.CONSTRUCT 
OS=EDIT.CONSTRUCT.INPUT.CONTROL 
OS=EDIT.CONSTRUCT.REFUTE 
OS=EDIT.CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=EDIT.CONSTRUCT.REFUTE.PROTOCOL 
OS=EDIT.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=EDIT.PROC 
OS=FORMULA 
OS=FORMULA.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT 
OS=FORMULA.CONSTRUCT.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT.REFUTE 
OS=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT.REFUTE.PROTOCOL 
OS=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=FORMULA.PROC 
OS=PROTOCOL 
OS=PROTOCOL.INPUT.CONTROL 
OS=PROTOCOL.PROC 
OS=REFUTE 
OS=REFUTE.INPUT.CONTROL 
OS=REFUTE.PROTOCOL 
OS=REFUTE.PROTOCOL.INPUT.CONTROL 
OS=REFUTE.PROC 
OS=REFUTE.PROC.CR 
OS=SYSTEM.IS.READY.FOR 
OS=OPEN.CODE.FILE 
OS=CLOSE.CODE.FILE 
OS=OPEN.LIST.FILE 
OS=CLOSE.LIST.FILE 
OS=OPEN.PROBLEM.FILE 
OS=CLOSE.PROBLEM.FILE 
OS=OPEN.GRAPH.FILE 
OS=CLOSE.GRAPH.FILE 
OS=WRITE.PROBLEM.FILE 
OS=OPTION 
OS=OPT.PRINT 
OS=PRINT.OPTION.AREA 
OS=OPT.READ 
OS=OPT.WRITE 
OS=OPT.PRETTYPRINT 
OS=OPT.WRITE.AT.POS 
OS=OPT.HELP 
OS=WRITE.TEXT 
OS*COMMAND.SPELLINGS 
OS*RESET.FLG 
NIL 
OS*ACTUAL.PROBLEM.FILE 
OS*ACTUAL.CODE.FILE 
OS*ACTUAL.GRAPH.FILE 
OS*ACTUAL.LIST.FILE 
;;; Reading source file "prog/os/operatingsystem.lisp"
;;; Warning: Ignoring an unmatched right parenthesis
;;; GC: 275864 words [1103456 bytes] of dynamic storage in use.
;;; 395878 words [1583512 bytes] of free storage available before a GC.
;;; 1067620 words [4270480 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/os/operatingsystem.sbin"
;;; Loading binary file "prog/os/operatingsystem.sbin"
----- Memory: Initialization with size 10000.
#P"/home1/mkrp/sys/boot.lisp"
USER: (load "sys/boot")
;;; Loading source file "sys/boot.lisp"
;;; Warning: File "sys/boot.lisp" does not begin with IN-PACKAGE.  Loading into package "USER"
;;; You are using the compiler in production mode (compilation-speed = 0)
;;; If you want shorter compile time at the expense of reduced optimization,
;;; you should use the development mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 3)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Optimization of tail calls is enabled (speed = 3)



     1. Laden von .lbin oder .lisp
     2. Laden compiliert
     3. Laden interpretiert
     4. Alle Dateien neu compilieren
     5. Compilieren ab der ersten nicht compilierten Datei
     6. Compilieren von nicht compilierten Dateien


  Bitte waehlen Sie: 4
Do you want to make a protocol?  (Y or N): n
;;; Loading source file "prog/serv/service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP-INTERN 
KKL*ALPHORDER.BUFFER.1 
KKL*ALPHORDER.BUFFER.2 
ALPHORDER 
UNTIL 
PUTASSOC 
DELETE-NTH 
WHILE 
NCONC1 
ATTACH 
KKL=MAP.MACROS 
KKL=MAKE.MAPS 
SOMEL 
C 
ENTERLISP 
READLINE 
MKRP-READ.LINES 
KWOTE 
DATE 
READ-FILE 
DODOWN 
ASET 
NEQ 
TESTEVAL 
LASTN 
FIRSTN 
SUBPAIR 
NSUBPAIR 
CONSES 
MKRP-REM.FILE 
MKRP-MENU 
MKRP-MENU.SCROLL 
MKRP-TIME 
;;; You are using the compiler in development mode (compilation-speed = 3)
;;; If you want faster code at the expense of longer compile time,
;;; you should use the production mode of the compiler, which can be obtained
;;; by evaluating (proclaim '(optimize (compilation-speed 0)))
;;; Generation of full safety checking code is enabled (safety = 3)
;;; Generation of inline code is disabled (speed = 0)
;;; Reading source file "prog/serv/service.lisp"
;;; Writing binary file "prog/serv/service.sbin"
;;; Loading binary file "prog/serv/service.sbin"
;;; Loading source file "prog/serv/serviceqlists.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
QCONC1 
QCONC 
QCONS 
QDELETE 
QINSERT-NTH 
QDELETE-NTH 
;;; Reading source file "prog/serv/serviceqlists.lisp"
;;; Writing binary file "prog/serv/serviceqlists.sbin"
;;; Loading binary file "prog/serv/serviceqlists.sbin"
;;; Loading source file "prog/serv/servicefiles.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MKRP-MAKE.PATHNAME 
MKRP-WITH.PATHNAME 
MKRP-LINELENGTH 
MKRP*DEFAULT.DIRECTORY 
MKRP=GET.DEFAULT.DIRECTORY 
MKRP*DEFAULT.NAME 
MKRP=GET.DEFAULT.NAME 
MKRP-SET.DEFAULT.DIRECTORY 
MKRP-SET.DEFAULT.NAME 
MKRP-OPENOUT 
MKRP-OPENIN 
MKRP-LOAD.FILE 
MKRP*ALL.SYSTEM.STREAMS 
MKRP-ADD.STREAM 
MKRP-REMOVE.STREAM 
MKRP-CLOSE.ALL.STREAMS 
CLOSEFILE 
CLOSE-STREAM 
BREAKMACROS 
MKRP-OUTSTREAMP 
MKRP-INSTREAMP 
*STANDARD-READTABLE* 
T 
T 
T 
READFILE 
MKRP-FILE.FUNCTIONS 
FILE.EXISTS 
FILENAME.CHECK 
MKRP-VIEW.FILE 
MKRP-CONVERSE.FILENAME 
MKRP-DEFAULT.PROBLEM 
MKRP-DEFAULT.LISP 
MKRP-DEFAULT.GRAPH 
MKRP-DEFAULT.CODE 
MKRP-DEFAULT.LIST 
MKRP-DEFAULT.TEXT 
MKRP-DEFAULT.OPTIONS 
MKRP-DEFAULT.AX 
MKRP-DEFAULT.TH 
MKRP-DEFAULT.FORMULAE 
MKRP-DEFAULT.TEMPPREPAXIOMS 
;;; Reading source file "prog/serv/servicefiles.lisp"
;;; Writing binary file "prog/serv/servicefiles.sbin"
;;; Loading binary file "prog/serv/servicefiles.sbin"
;;; Loading source file "prog/serv/atpservice.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SUPERSET 
SET= 
SET*= 
MEMBER* 
ANTIVALENT 
COPY-GRAPH 
COPY-GRAPH.DUPLICATE 
DUPL 
EQUIVALENT 
FLATTEN 
MAXIMA 
IMPLIES 
IN 
MAPPRINT 
INS 
INSASSOC 
INSERT 
INSIDE 
ISEMPTYSTACK 
LISTPOS 
LISTPOSITIONS 
MAKEEMPTYSTACK 
MAXELT 
*RIGHT.MARGIN* 
TAB 
LINELENGTH 
MKRP*STANDARD.RIGHT.MARGIN 
KKL*COUNT.PRINT.BUFFER 
PRINT-LENGTH 
TAB-PRINC 
TAB-PRIN1 
SPACES 
PRINTTAB 
CASSOC 
REMASSOC 
REMPROPS 
REMVALUESASSOC 
DISJOINTP 
DREMAP 
SATISFIABLE 
ZIP 
BUFFER.CREATE 
BUFFER.MULTIPLE.CONS 
BUFFER.CONS 
BUFFER.INS 
BUFFER.INSERT 
BUFFER.CONTENTS 
BUFFER.RESET 
BUFFER.CLEAR 
BUFFER.MAPCAR 
BUFFER.SUBSET 
BUFFER=EXTEND 
PUSH.BUFFER.STACK 
POP.BUFFER.STACK 
CARTESIAN.LOOP 
SAVE-PROPLIST 
PP 
REMAINING-MEMORY 
MKRP-GC.START 
;;; Reading source file "prog/serv/atpservice.lisp"
;;; Writing binary file "prog/serv/atpservice.sbin"
;;; Loading binary file "prog/serv/atpservice.sbin"
;;; Loading source file "prog/opt/options.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OPT=IGNORE 
OPT=GET.OPTION.NAME 
OPT=GET.DEFAULT.VALUE 
OPT=GET.ARGUMENT.RANGE 
OPT=GET.OPTION.EXPLANATIONS 
OPT=GET.OPTION.DEMON 
OPT=GET.AREA.NAME 
OPT=GET.AREA.HEADER 
OPT=GET.AREA.OPTIONS 
OPT=GET.AREA.EXPLANATIONS 
OPT*ALL.AREAS 
OPT*ALL.OPTIONS 
OPT-GET.OPTION 
OPT=GET 
OPT=PUT 
OPT-PUT.OPTION 
OPT-SET.STANDARD 
OPT-GET.LIST.OPTIONS 
OPT-GET.LIST.AREA.OPTIONS 
OPT-PUT.LIST.OPTIONS 
OPT-ALL.OPTIONS 
OPT-SAVE 
OPT-GET.DEFAULT.VALUE 
OPT-GET.OPTION.TEXT 
OPT-ALL.AREAS 
OPT-GET.AREA.OPTIONS 
OPT-GET.AREA.HEADLINE 
OPT-GET.AREA.EXPLANATION 
OPT=CHECK 
OPT=CHECK.IS.LIST 
OPT=CHECK.AND.STANDARDIZE 
OPT=CHECK.IS.ELEMENT.OF.SET 
OPT=CHECK.IS.IN.RANGE 
OPT=CHECK.IS.OF.STRUCTURE 
OPT=CHECK.IS.EITHER.RANGE 
OPT-INIT 
OPT*ALL.RANGE.TYPES 
OPT-IS.COMPLETION 
OPT-IS.HEURISTIC.COMPLETION 
OPT-IS.KZ.COMPLETION 
OPT-IS.WITH.RESIDUES 
OPT*PR_LITERALS 
NIL 
OPT-WND_MAINWINDOW-EXPOSE 
STRINGS-EQUALIZE-LENGTH 
;;; Warning: FUNCTION SEL=STRAT_R.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Warning: FUNCTION SEL=STRAT_P.SELECTION defined more than once in "prog/opt/options.lisp"

NIL 
;;; Reading source file "prog/opt/options.lisp"
;;; Writing binary file "prog/opt/options.sbin"
;;; Loading binary file "prog/opt/options.sbin"
;;; Warning: FUNCTION SEL=STRAT_R.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Warning: FUNCTION SEL=STRAT_P.SELECTION defined more than once in "prog/opt/options.lisp"
;;; Loading source file "prog/ds/memory.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MEM*MEMORY 
MEM*LAST.REUSABLE.VADR 
MEM*FIRST.REUSABLE.VADR 
MEM*COLLECTABLE 
MEM*NEXT.VADR 
MEM*NEXT.RADR 
MEM*RESERVE 
MEM*SIZE 
MEM*REST 
MEM*INCREMENT 
MEM-NEW 
MEM-GET 
MEM-PUT 
MEM-SHORTEN 
MEM-SIZE 
MEM=CLEAN.UP 
MEM-ERASE 
MEM-TYPE 
MEM-GET.TYPE 
MEM-ADDRESS 
MEM-ALL.ADR 
MEM-INITIALIZE 
MEM-RESET 
MEM-SAVE 
MEM-SAVE.SYMBOL 
MEM-MEMORY 
MEM=ALLOC 
MEM=ENLARGE.SIZE 
MEM=GBC 
MEM=NOT.ENOUGH.MEMORY 
MEM=GETSIZE 
MEM=REAL.ADDR 
MEM-PUTPROP 
MEM-GETPROP 
MEM-REMPROP 
MEM-REMPROPS 
MEM-GETPROPLIST 
MEM-SETPROPLIST 
MEM-ADDPROP 
MEM=PROPLIST.RADR 
;;; Reading source file "prog/ds/memory.lisp"
;;; Writing binary file "prog/ds/memory.sbin"
;;; Loading binary file "prog/ds/memory.sbin"
;;; Loading source file "prog/ds/dataterm.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DT-SORT.TRANSITIVE.CLOSURE 
DT-SORT.DIRECT.SUBSORTS 
DT-SORT.DIRECT.SUPERSORTS 
DT*COMMONS.TO.SAVE 
DT*SORT.ALL 
DT*SORT.NR 
DT*SORT.PROPERTIES 
DT*SORT.COMMON.COMPUTE.FLAG 
DT-SORT.IS.SUBSORT 
DT-SORT.INSERT 
DT-SORT.ALL 
DT-SORT.MINIMAL.SUBSORTS 
DT-SORT.NUMBER 
DT-SORT.ST.PUT.DIRECT.SUPERSORTS 
DT-SORT.INVERSE.TRANSITIVE.CLOSURE 
DT-SORT.COMMON.COMPUTE.FLAG 
DT-SORT.DISJOINT.SORTS 
DT-SORT.IS.DISJOINT.WITH 
DT-SORT.GREATEST.COMMON.SUBSORT 
DT-SORT.LEAST.COMMON.SUPERSORT 
DT-SORT.PUT.DISJOINTS 
DT-SORT.PUT.INV.TRANS.CLOSURE 
DT-SORT.PUT.TRANS.CLOSURE 
DT-SORT.UPDATE.ALL 
DT-SORT.UPDATE.DIRECT.SUBSORTS 
DT-SORT.CREATE 
DT-SORT.GREATEST.COMMON.SUBSORTS 
DT-SORT.GREATEST.COMMON.SUBSORT.OF.LIST 
DT-SORT.PUT.COMMON.COMPUTE.FLAG 
DT-SORT.UPDATE.MINIMAL.SUBSORTS 
DT-SORT.ST.REMOVE 
DT-SORT.LATTICE.COMPLETION 
DT-SORT.DELETE.ALL 
DT-SORT.LEAST.COMMON.SUPERSORTS 
DT-SORT.ADD.TO.INV.TRANS.CLOSURE 
DT-SORT.ADD.TO.TRANS.CLOSURE 
DT-SORT.CLEAR.SORTS 
DT-SORT.NEW.SYMBOL 
DT-SORT.UPDATE.MAX.SUBSORTS 
DT=SORT.CREATE.ALL.INTERSECTIONS 
DT=SORT.DIRECT.SUPERSORTS 
DT=SORT.INSERT 
DT=SORT.UPDATE.LEAST.SUPERSORTS 
DT=SORT.UPDATE.INVERSE.TRANS.CLOSURE 
DT=SORT.INVERSE.TRANSITIVE.CLOSURE 
DT=SORT.LEAST.SUPERSORTS 
DT=SORT.ST.UPDATE.SORTS 
DT=SORT.MINIMAL.SUBSORTS 
DT=SORT.UPDATE.TRANS.CLOSURE 
DT=SORT.UPDATE.MINIMAL.SUBSORTS 
DT=SORT.UPDATE.DIRECT.SUBSORTS.OUT.OF.TRANS.CLOSURE 
DT=SORT.DELETE.ALL 
DT-PUT.UNI.CREATES.VARIABLES 
DT=SORT.UPDATE.MAX.SUBSORTS 
DT=SORT.MAX.SUBSORTS 
DT=SORT.TRANSITIVE.CLOSURE 
DT=SORT.NEW.SYMBOL 
DT*VARIABLE.COUNTER 
DT*VARIABLE.BUFFER 
DT-VARIABLE.CREATE 
DT-VARIABLE.PNAME 
DT-VARIABLE.SORT 
DT-VARIABLE.PUTSORT 
DT-VARIABLE.GET.BINDING 
DT-VARIABLE.PUT.BINDING 
DT-VARIABLE.DELETE.BINDING 
DT-VARIABLE.RENAMING.SUBSTITUTION 
DT-VARIABLE.IS 
DT-VARIABLE.IN 
DT-VARIABLE.DELETE 
DT=VARIABLE.STORAGE 
DT=VARIABLE.GETPNAME 
DT=VARIABLE.GETSORT 
DT=VARIABLE.PUTSORT 
DT=VARIABLE.GETBINDING 
DT=VARIABLE.PUTBINDING 
DT=VARIABLE.IS 
DT*CONSTANT.COUNTER 
DT*CONSTANT.ALL 
DT*OMEGA.CONSTANT 
DT-CONSTANT.OMEGA 
DT-CONSTANT.CREATE 
DT-CONSTANT.SORT 
DT-CONSTANT.PUTSORT 
DT-CONSTANT.PUTPNAME 
DT-CONSTANT.PNAME 
DT-CONSTANT.IS 
DT-CONSTANT.ALL 
DT-CONSTANT.DELETE 
DT-CONSTANT.IS.SKOLEM 
DT=CONSTANT.STORAGE 
DT=CONSTANT.CREATE.PNAME 
DT=CONSTANT.GETPNAME 
DT=CONSTANT.GETSORT 
DT=CONSTANT.PUTPNAME 
DT=CONSTANT.PUTSORT 
DT=CONSTANT.IS 
DT*ABBREVIATIONS 
DT-ABBREVIATION.PUSH 
DT-ABBREVIATION.POP 
DT-ABBREVIATION.COMPRESS.TERM 
DT-ABBREVIATION.COMPRESS.TERMLIST 
DT-ABBREVIATION.EXPAND.TERM 
DT-ABBREVIATION.EXPAND.TERMLIST 
DT-ABBREVIATION.SCHEMES 
DT-ABBREVIATION.ALL 
DT-ABBREVIATION.TERM 
DT-ABBREVIATION.SORT 
DT-ABBREVIATION.IS 
DT=ABBREVIATION.EXPAND.ASS 
DT=FUNCTION.TUPLE.FIT 
DT=FUNCTION.TUPLE.MINIMIZE 
DT-ABBREVIATION.EXPAND.ASS 
DT-ABBREVIATION.PUTSORT 
DT=ABBREVIATION.STORAGE 
DT=ABBREVIATION.CREATE 
DT=ABBREVIATION.PUTTERM 
DT=ABBREVIATION.GETTERM 
DT=ABBREVIATION.PUTDEPTH 
DT=ABBREVIATION.GETDEPTH 
DT=ABBREVIATION.IS 
DT=ABBREVIATION.GENERATE 
DT=ABBREVIATION.INSERT 
DT=ABBREVIATION.CREATE.TREE 
DT=ABBREVIATION.EXPAND 
DT=ABBREVIATION.PUTSORT 
DT=ABBREVIATION.GETSORT 
DT=ABBREVIATION.NORMALFORM 
DT=ABBREVIATION.NORMALFORM.XX.TO.X 
DT=ABBREVIATION.NORMALFORM.XYZ.TO.XZ 
DT=ABBREVIATION.CONTAINS.VARIABLE 
DT=ABBREVIATION.NORMALFORM.INSERT.BRACKETS 
DT=ABBREVIATION.NORMALFORM.FOR.COMPRESS 
DT=ABBREVIATION.EXPAND.FOR.COMPRESS 
DT=ABBREVIATION.SEARCH.OLD.SCHEMES 
DT=ABBREVIATION.TERM.LESS 
DT=ABBREVIATION.ARGUMENT.NORMALFORM 
DT=ABBREVIATION.TERM.EQUAL 
DT*FUNCTION.COUNTER 
DT*FUNCTION.ALL 
DT*FUNCTION.ADMISSIBLE.THEORIES 
DT*FUNCTION.ACTUAL.THEORIES 
DT*FUNCTION.WITH.ARGUMENT.SYMMETRIES 
DT*FUNCTION.COMPONENTS 
DT-FUNCTION.CREATE 
DT-FUNCTION.SORT 
DT-FUNCTION.PUTPNAME 
DT-FUNCTION.PNAME 
DT-FUNCTION.ATTRIBUTES 
DT-FUNCTION.ADD.ATTRIBUTES 
DT-FUNCTION.DOMAINSORTS 
DT-FUNCTION.ARITY 
DT-FUNCTION.THEORIES 
DT-FUNCTION.IS.MARKED 
DT-FUNCTION.IS 
DT-FUNCTION.ALL 
DT-FUNCTION.DELETE 
DT-FUNCTION.PUT.ATTRIBUTES 
DT-FUNCTION.CHANGE 
DT-FUNCTION.CHANGE.ONE.ENTRY 
DT-FUNCTION.IS.SKOLEM 
DT-FUNCTION.SORTLIST 
DT-FUNCTION.ARGUMENT.SYMMETRIES 
DT-FUNCTION.BUILD.TREE.CALC 
DT-FUNCTION.GLB.OF.RANGES 
DT-FUNCTION.IS.POLYMORPHIC 
DT-FUNCTION.UPDATE.POLYMORPHIC 
DT-FUNCTION.MAX.DOMAINS.OF.RANGE 
DT-FUNCTION.MAX.RANGE.SORT 
DT-FUNCTION.MIN.RANGES 
DT-FUNCTION.SORT.LIST.INVERSE 
DT-FUNCTION.TUPLE.COMPLETION 
DT-FUNCTION.TUPLE.LESS 
DT=FUNCTION.BUILD.TREE.CALC.R 
DT=FUNCTION.GLB.OF.RANGES 
DT=FUNCTION.MINIMAL.SORTS 
DT=FUNCTION.TUPLE.FIND.INV.TUPLES 
DT=FUNCTION.TUPLE.FIND.INV.TUPLES.R 
DT=FUNCTION.TUPLE.MIN.RANGES 
DT=FUNCTION.TUPLE.RETURN.ADMISSIBLE 
DT=FUNCTION.UPDATE.POLYMORPHIC 
DT=FUNCTION.STORAGE 
DT=FUNCTION.CREATE.PNAME 
DT=FUNCTION.IS 
DT=FUNCTION.GET 
DT==FUNCTION.GET 
DT=FUNCTION.PUT 
DT==FUNCTION.PUT 
DT*PREDICATE.ADMISSABLE.ATTRIBUTES 
DT*PREDICATE.COUNTER 
DT*EQUALITY.SYMBOLS 
DT*EQUALITY.PREDICATES 
DT*NONEQUALITY.PREDICATES 
DT*PREDICATE.ALL 
DT*PREDICATE.WITH.ATTRIBUTES 
DT*PREDICATE.COMPONENTS 
DT*TRUE.PREDICATE 
DT*FALSE.PREDICATE 
DT-PREDICATE.CREATE 
DT-PREDICATE.PUTPNAME 
DT-PREDICATE.PNAME 
DT-PREDICATE.IS.SYMMETRIC 
DT-PREDICATE.IS.EQUALITY 
DT-PREDICATE.ARE.SAME 
DT-PREDICATE.IS 
DT-PREDICATE.MARKED.ALL 
DT-PREDICATE.ALL 
DT-PREDICATE.EQUALITIES 
DT*ELEMENT.PREDICATE 
DT-PREDICATE.ELEMENT 
DT-PREDICATE.NONEQUALITIES 
DT-PREDICATE.PUT.POSITIVE.OCCURRENCES 
DT-PREDICATE.DELETE.POSITIVE.OCCURRENCES 
DT-PREDICATE.DELETE.POSITIVE.OCCURRENCE 
DT-PREDICATE.POSITIVE.OCCURRENCES 
DT-PREDICATE.PUT.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DELETE.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DELETE.NEGATIVE.OCCURRENCE 
DT-PREDICATE.NEGATIVE.OCCURRENCES 
DT-PREDICATE.DOMAINSORTS 
DT-PREDICATE.PUTSORT 
DT-PREDICATE.ATTRIBUTES 
DT-PREDICATE.PUT.ATTRIBUTES 
DT-PREDICATE.ADD.ATTRIBUTES 
DT-PREDICATE.IS.MARKED 
DT-PREDICATE.REFL.CLAUSE 
DT-PREDICATE.DELETE 
DT-PREDICATE.CONVERTSET 
DT-PREDICATE.GET 
DT=PREDICATE.GET 
DT-PREDICATE.PUT 
DT=PREDICATE.PUT 
DT-PREDICATE.IS.TRUE 
DT-PREDICATE.IS.FALSE 
DT-PREDICATE.TRUE 
DT-PREDICATE.FALSE 
DT=PREDICATE.STORAGE 
DT=PREDICATE.CREATE.PNAME 
DT=PREDICATE.IS 
DT=PREDICATE.INSERT.OTHERSIDES 
DT=PREDICATE.OTHERSIDES.ADD.SYMMETRY 
DT=PREDICATE.OTHERSIDES.ADD.ASYMMETRY 
DT-TAF.CREATE 
DT=TAF.CREATE.LIST 
DT-TAF.CREATE.FIRST 
DT-TAF.CREATE.SECOND 
DT-TAF.CREATE.NEXT 
DT-TAF.CREATE.LEFT 
DT-TAF.CREATE.RIGHT 
DT-TAF.IS.LEFT 
DT-TAF.IS.RIGHT 
DT-TAF.TOPLEVEL 
DT-TAF.TOPLEVEL.EQUALITY 
DT-TAF.DIFFERENT.SIDES 
DT-TAF.ARE.EQUAL 
DT-TAF.DEEPER.OR.EQUAL 
DT-TAF.COMPOSE.TWO.TAFS 
DT-TAF.OTHERSIDE 
DT-TAF.ARGUMENT.POSITIONS 
DT-TAF.DEEPEST.ARGUMENT.NUMBER 
DT*UNI.CREATES.VARIABLES 
DT*SIGN.MINUS.SYMBOLS 
DT*SIGN.PLUS.SYMBOLS 
DT-GETPROP 
DT-PUTPROP 
DT-GETPROPLIST 
DT-SETPROPLIST 
DT-REMPROP 
DT-REMPROPS 
DT-ADDPROP 
DT-RESET 
DT-ACCESS 
DT-TYPE 
DT-PNAME 
DT-REPLACE.TERM.IN.TERMLIST 
DT-UPDATE.STRANGE.COMMONS 
DT-APPLY.TO.ALL.ADDR 
DT-UNI.CREATES.VARIABLES 
DT-SAVE 
DT-SAVE.SYMBOLS 
DT-PRINT.SYMBOLS 
DT*SYMBOL.KINDS 
DT-GROUND.TERM.SORT 
DT-SET.DIFFERENCE 
DT-ARITY 
;;; Reading source file "prog/ds/dataterm.lisp"
;;; GC: 261618 words [1046472 bytes] of dynamic storage in use.
;;; 410124 words [1640496 bytes] of free storage available before a GC.
;;; 1081866 words [4327464 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/ds/dataterm.sbin"
;;; Loading binary file "prog/ds/dataterm.sbin"
;;; Loading source file "prog/ds/dt-term.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DT-TERM_TOPSYMBOL 
DT-TERM_EQUAL 
DT-TERM_CREATE 
DT-TERM_ARGUMENTS 
DT-TERM_C.TERM.IS 
DT-TERM_IN 
DT-TERM.IS.WEAKENABLE 
DT=TERM.IS.WEAKENABLE 
DT-TERM.RENAMED 
DT-TERM.SORT 
DT-TERM.MINIMAL.SORTS 
DT-TERMLIST.MAXDEPTH 
DT-TERMLIST.VARIABLES 
DT-TERMLIST.CF 
DT-TERM.VARIABLES 
DT-TERM.CF 
DT-FIND.VARIABLES 
DT=FIND.VARIABLES 
DT=TERM.FUNCTIONSYMBOL 
DT=TERM.VAR.OCCUR 
DT-TERM.IS.CONSTANT 
DT-TERM.IS.VARIABLE 
DT-TERM.IS.ABBREVIATION 
;;; Reading source file "prog/ds/dt-term.lisp"
;;; Writing binary file "prog/ds/dt-term.sbin"
;;; Loading binary file "prog/ds/dt-term.sbin"
;;; Loading source file "prog/ord/ord-poly.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ORD*POL_LIMIT 
ORD-POL_SET.LIMIT 
ORD*POL_DEFAULT 
ORD=POL_DEFAULT 
ORD=POL_GREATER 
MONOMIAL 
COPY-MONOMIAL 
MONOM-LEX-ORDER 
EXPONENT-NAT-ORDER 
POLYNOMIAL 
MAKE-CONSTANT 
COPY-POLYNOMIAL 
MAX-DEGREE 
MIN-VAR-POLYNOMIAL 
APP-ELEM 
POLYNOMIAL-TO-STRING 
PRINT-POLYNOMIAL 
VC-PRINT-POLYNOMIAL 
ADD-POLYNOMIALS 
JOIN-MONOMIALS 
SUBTRACT-POLYNOMIALS 
MULT-POLYNOMIALS 
R-MULT-POLYNOMIALS 
REC-MULT-POL 
PARSE-EXPONENT 
PARSE-MONOMIAL 
READ-POLYNOMIAL 
CREATE-VAR-COEFFS 
EVAL-STRUCT 
DECOMP-POLYNOMIAL 
NO-OF-MULT 
OPT-EVAL-SEQ 
EVAL-POLYNOMIAL 
INTERPRETATION-ENTRY 
ORD=POL_ASSIGN 
ORD=POL_GET.FCT.ENTRY 
INTERPRETE 
AC-OPER-INTERPRETATION-P 
VC-MONOMIAL 
VC-POLYNOMIAL 
NORMALIZE-TO-VC-POLYNOMIAL 
POSITIVE 
*PRINT-POLY* 
*PRINT-POLY-LENGTH* 
T 
TR=POL 
;;; Reading source file "prog/ord/ord-poly.lisp"
;;; Writing binary file "prog/ord/ord-poly.sbin"
;;; Loading binary file "prog/ord/ord-poly.sbin"
;;; Loading source file "prog/ord/orderings.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ORD=LEX.GREATER 
ORD=SYMBOL.GREATER 
ORD=SORT 
ORD=SYMBOL.SEARCH.SORT 
ORD*LIST 
ORD=SYMBOL.SET.FOREIGN 
ORD=SYMBOL.WEIGHT 
ORD=KB_VAR.COUNT 
ORD=KB_VAR.SUBSET 
ORD=KB_VAR.PLUS 
ORD=KB_VAR.CONDITION 
ORD=KB_PUT 
ORD=KB_SET.FOREIGN 
ORD*KB_MINIMUM 
ORD=KB_VARIABLE.WEIGHT 
ORD=KB_SYMBOL.WEIGHT 
ORD=KB_TERM.WEIGHT 
ORD=KB_GREATER 
ORD=RPO_MS.GREATER 
ORD=RPO_SYMBOL.EQUAL 
ORD=RPO_GREATER 
ORD=UNCOMPARABLE.P 
ORD*ARRAY 
ORD*NR 
ORD=CONS.TERM 
ORD=RESET.ARRAY 
ORD=LPO_GREATER 
ORD=TERM_IN 
ORD=TERM_EQUAL 
ORD=COMPARE.EQ 
ORD=GREATER 
ORD-GREATER 
ORD-RESET 
ORD-SHOW 
;;; Reading source file "prog/ord/orderings.lisp"
;;; Writing binary file "prog/ord/orderings.sbin"
;;; Loading binary file "prog/ord/orderings.sbin"
;;; Loading source file "prog/hd/denz.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
DENZ-INIT 
DENZ=TRANS.FROM.JOERG 
DENZ=TRANS.SUBST.FROM.JOERG 
DENZ=TRANS.TO.JOERG 
UNI*TH.TERM.TOP 
DENZ=TERM.CREATE 
DENZ=TRANS.REMOVE.L 
DENZ-MATCH 
DENZ-MATCH.LIST 
;;; Reading source file "prog/hd/denz.lisp"
;;; Writing binary file "prog/hd/denz.sbin"
;;; Loading binary file "prog/hd/denz.sbin"
;;; Loading source file "prog/hd/hades.lisp"

#<Package "HADES" 105C166> 
#<Package "MARKGRAF-KARL" 160370E> 
T 
T 
NIL 
HD-RESET 
HD=INSTANTIATE 
HD=TRANSLATE.ASSOCIATIVE.TO 
HD=TRANSLATE.AC.TO 
HD=TRANSLATE.AC1.TO 
HD=TRANSLATE.AG.TO 
HD=TRANSLATE.OBJECTS.TO 
HD=TRANSLATE.OBJECTS.FROM 
HD-UNIFY.TERMS 
HD-UNIFY.TERMLISTS 
HD=UNIFY 
;;; Reading source file "prog/hd/hades.lisp"
;;; Writing binary file "prog/hd/hades.sbin"
;;; Loading binary file "prog/hd/hades.sbin"
;;; Loading source file "prog/pp/pprint.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PP*LEFT.MARGIN 
PP*RIGHT.MARGIN 
PP*NEGATIVE.SIGN 
PP*POSITIVE.SIGN 
PP*POSITIVE.SIGNS 
PP*EMPTY.CLAUSE.SIGN 
PP*DISJUNCTION.SIGN 
PP-PRINT.INFIX.FORMULA 
PP=PRINT.INFIX.FORMULA 
PP=EXTRACT.&.PRINT.INFIX.QUANTIFIERS 
PP*INFIX.SEPARATORS 
PP=FORMULA.SEPARATOR 
PP=SPLIT.INFIX.FORMULA 
PP=SPLIT 
PP=PRINT.INFIX.FORMULA.ONE.LINE 
PP=INFIX.FORMULA.LENGTH.ONE.LINE 
PP-PRINT.LITERALS 
PP=PRINT.LITERALS 
PP-PRINT.LITERAL 
PP=PRINT.LITERAL 
PP=PRINT.LITERAL.ONE.LINE 
PP=LITERAL.LENGTH.ONE.LINE 
PP-PRINT.TERM 
PP=PRINT.TERM 
PP-PRINT.TERM.ONE.LINE 
PP=PRINT.TERM.ONE.LINE 
PP-TERM.LENGTH.ONE.LINE 
PP=TERM.LENGTH.ONE.LINE 
PP-SUM 
;;; Reading source file "prog/pp/pprint.lisp"
;;; Writing binary file "prog/pp/pprint.sbin"
;;; Loading binary file "prog/pp/pprint.sbin"
;;; Loading source file "prog/pp/pprint-latex.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PP*L_LEFT.MARGIN 
PP*L_RIGHT.MARGIN 
PP*L_NEGATIVE.SIGN 
PP*L_POSITIVE.SIGN 
PP*L_POSITIVE.SIGNS 
PP*L_EMPTY.CLAUSE.SIGN 
PP*L_DISJUNCTION.SIGN 
PP-L_PRINT.INFIX.FORMULA 
PP=L_PRINT.INFIX.FORMULA 
PP=L_EXTRACT.&.PRINT.INFIX.QUANTIFIERS 
PP*L_INFIX.SEPARATORS 
PP=L_FORMULA.SEPARATOR 
PP=L_SPLIT.INFIX.FORMULA 
PP=L_SPLIT 
PP=L_PRINT.INFIX.FORMULA.ONE.LINE 
PP=L_INFIX.FORMULA.LENGTH.ONE.LINE 
PP-L_PRINT.LITERALS 
PP=L_PRINT.LITERALS 
PP-L_PRINT.LITERAL 
PP=L_PRINT.LITERAL 
PP=L_PRINT.LITERAL.ONE.LINE 
PP=L_LITERAL.LENGTH.ONE.LINE 
PP-L_PRINT.TERM 
PP=L_PRINT.TERM 
PP-L_PRINT.TERM.ONE.LINE 
PP=L_PRINT.TERM.ONE.LINE 
PP-L_TERM.LENGTH.ONE.LINE 
PP=L_TERM.LENGTH.ONE.LINE 
PP-L_SUM 
;;; Reading source file "prog/pp/pprint-latex.lisp"
;;; While compiling PP=L_PRINT.LITERALS
;;; Warning: Variable RIGHT.POS is bound but not referenced
;;; Warning: Variable LEFT.POS is bound but not referenced
;;; Writing binary file "prog/pp/pprint-latex.sbin"
;;; Loading binary file "prog/pp/pprint-latex.sbin"
;;; Loading source file "prog/edt/symboltable.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
ST-RESET 
ST-FIX 
ST-POP.SYMBOLTABLE 
ST-PUSH.SYMBOLTABLE 
ST-CLEAR.STACK 
ST-STACK.EMPTY 
ST-STACK.LENGTH 
ST-ENTER.SYMBOLENTRY 
ST-CHANGE.SYMBOLENTRY 
ST-ENTER.SYMBOL.CLASSIFICATION 
ST-GET.SYMBOL.CLASSIFICATION 
ST-GET.TRANSITIVE.CLOSURE 
ST-GET.INVERSE.TRANSITIVE.CLOSURE 
ST-ALL.SYMBOLNAMES 
ST-IS.IN.SYMBOLTABLE 
ST-REMOVE.SYMBOL 
ST-REPLACE.SYMBOL 
ST-SAVE 
ST-LOAD 
ST-SET.LOAD.FLAG 
ST-LOAD.FLAG 
ST-READ 
ST-CREATE.VARIABLE 
ST-CREATE.CONSTANT 
ST-CREATE.FUNCTION 
ST=GET.SYMBOLENTRY 
ST=GET.SYMBOLARITY 
ST=GET.SYMBOLATTRIBUTE 
ST=GET.SYMBOLDATA 
ST=GET.SYMBOLDOMAIN 
ST=GET.SYMBOLKIND 
ST=GET.SYMBOLRANGE 
ST=PUT.NEW.ON.STACK 
ST=PUT.CHANGE.ON.STACK 
ST=STACK.EMPTY 
ST=CLEAR.STACK 
ST=RELEASE.SYMBOLTABLE 
ST*STACK1 
ST*STACK2 
ST*LOAD.FLAG 
ST*SYMBOL.ADDRESSES 
;;; Reading source file "prog/edt/symboltable.lisp"
;;; Writing binary file "prog/edt/symboltable.sbin"
;;; Loading binary file "prog/edt/symboltable.sbin"
;;; Loading source file "prog/edt/formulatable.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
FMT*NUMBER.OF.AREAS 
FMT*UNDO.STACK 
FMT*LOAD.FLAG 
FMT*AREA.POINTERS 
FMT*UNDO.INDICATOR 
FMT*LANGUAGE 
FMT-EDIT 
FMT-RESET 
FMT-IS.RESET 
FMT-SET.LOAD.FLAG 
FMT-SET.LANGUAGE 
FMT-INSERT 
FMT-DELETE 
FMT-SWITCH 
FMT=EXCHANGE.CAR 
FMT-SHIFT 
FMT-REPLACE 
FMT-WRITE 
FMT-LOAD 
FMT=LOAD 
FMT=CUT 
FMT-UNDO 
FMT=PUSH.UNDO 
FMT-COMMAND 
FMT=PP 
FMT=STATE 
FMT=PRINT.FORM 
FMT=PRINT.INFIX.FORM 
FMT=AREA.OF.FORMULA 
FMT=POSITION.OF.FORMULA.IN.AREA 
FMT=WRITE.NUMBER.OF.AREA 
FMT-NUMBER.OF.FORMULAS 
FMT=NUMBER.OF.FORMULAS 
FMT-FORMULA 
FMT=FORMULA 
FMT-LAST.DESTRUCTIVE.COMMAND 
FMT=ERRORS 
FMT=FUN.ERRORS 
FMT=OUTPUTS 
FMT=FUN.OUTPUTS 
FMT=AREA 
;;; Reading source file "prog/edt/formulatable.lisp"
;;; Writing binary file "prog/edt/formulatable.sbin"
;;; Loading binary file "prog/edt/formulatable.sbin"
;;; Loading source file "prog/edt/editorwindow.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
EDT*RUN.WINDOW 
EDT*CONTENTS 
EDT=EDIT.EXPRESSION 
EDT=EDIT.CHANGED 
EDT=EDIT.FILE 
;;; Reading source file "prog/edt/editorwindow.lisp"
;;; Writing binary file "prog/edt/editorwindow.sbin"
;;; Loading binary file "prog/edt/editorwindow.sbin"
;;; Loading source file "prog/edt/compile.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
COM*KEYWORDS.PLL 
COM*KEYWORDS.COLON 
COM*KEYWORDS.IND 
COM*LETTERS 
COM*DIGITS 
COM*SPECIAL.SIGNS 
COM*EXPRESSION.PREFIX.PLL 
COM*EXPRESSION.PREFIX.IND 
COM*CHANGED.SYMBOLS 
COM*USED.SYMBOLS 
COM*EQUIVALENCES 
COM*IMPLICATIONS 
COM*ERROR 
COM*VSTACK 
COM-RESET 
COM-KEYWORD 
COM-CHANGED.SYMBOLS 
COM-USED.SYMBOLS 
COM-EXPRESSION.PREFIX 
COM=COLONIZE 
COM-COMPILE 
COM=1=SYMBOL.ANALYSYS 
COM=1=IS.IDENTIFIER 
COM=1=IS.NAME 
COM=1=SYMBOL.ACCEPTED 
COM=1=SYMBOL.IS 
COM=1=NEXT.SYMBOL 
COM=2=STATEMENT 
COM=2=TYPE.DECLARATION 
COM=2=TYPE.DEFINITION 
COM=2=TYPETAIL 
COM=2=TYPELIST 
COM=2=SUBSORT.DECLARATION 
COM=2=AC1 
COM=2=AG 
COM=2=PROPERTY.DECLARATION 
COM=2=QUANTIFICATION 
COM=2=EQUIVALENCE.1 
COM=2=EQUIVALENCE.2 
COM=2=IMPLICATION.1 
COM=2=IMPLICATION.2 
COM=2=DISJUNCTION.1 
COM=2=DISJUNCTION.2 
COM=2=CONJUNCTION.1 
COM=2=CONJUNCTION.2 
COM=2=NEGATION 
COM=2=ATOMAR.FORMULA 
COM=2=STRUCTURE.DECLARATION 
COM=2=STRUCTURE.ANNOUNCEMENT 
COM=2=STRUCTURE.DEFINITION 
COM=2=STRUCTURE.TAIL 
COM=2=CONSTANT.AND.CONSTRUCT 
COM=2=CONSTANT.AND.CONSTRUCT.TAIL1 
COM=2=CONSTANT.AND.CONSTRUCT.TAIL2 
COM=2=CONSTRUCTION.DEFINITION 
COM=2=CONSTRUCTION.DEFINITION.TAIL 
COM=2=FUNCTION.DEFINITION 
COM=2=PARAMETER.LIST 
COM=2=PARAMETER.TAIL 
COM=2=FUNCTION.BODY 
COM=2=FUNCTION.IF.CLAUSE.LIST 
COM=2=FUNCTION.IF.CLAUSE.TAIL 
COM=2=CONDITION 
COM=2=IF.CONJUNCTION.1 
COM=2=IF.CONJUNCTION.2 
COM=2=LITERAL 
COM=2=PREDICATE.DEFINITION 
COM=2=PREDICATE.BODY 
COM=2=PREDICATE.IF.CLAUSE.LIST 
COM=2=PREDICATE.IF.CLAUSE.TAIL 
COM=2=VARIABLE.DECLARATION 
COM=2=VARIABLE.TYPE 
COM=2=PROPOSITION 
COM=2=ATOM 
COM=2=EQUALITY 
COM=2=EQUALITY.SYMBOL 
COM=2=TERM 
COM=2=TERMTAIL 
COM=2=TERMLIST 
COM=2=IDENTIFIER.LIST 
COM=2=IDENTIFIER.TAIL 
COM=2=CONSTANT.LIST 
COM=2=CONSTANT.TAIL 
COM=2=IDENTIFIER.OR.NAME 
COM=2=IDENTIFIER 
COM=2=NUMBER 
COM=2=NAME 
COM=2=SORT.SYMBOL 
COM=2=SORT.TERM 
COM=2=SORT.SYMBOLLIST 
COM=2=SORT.SYMBOL.TAIL 
COM=2=SORT.SYMBOL.SEQUENCE 
COM=2=SORT.SYMBOL.SEQUENCE.TAIL 
COM=QUANTIFICATION.CLOSURE 
COM=JUNCTION.CLOSURE 
COM=CREATE.STRUCTURE.SCHEME 
COM=3=ENTER.SYMBOL 
COM=3=ENTER.SORT 
COM=3=VSTACK.PUSH 
COM=3=VSTACK.POP 
COM=3=VSTACK.NEWNAME 
COM=3=VSTACK.OLDNAME 
COM=3=INSERT.PROPERTY 
COM=3=ENTER.PARAMETER.BINDING 
COM=3=GET.PARAMETER.BINDING 
COM=3=IS.PARAMETER.UNBOUND.ATOM 
COM=3=IS.PARAMETER.BINDING 
COM=3=IS.STRUCTURE.TERM.SCHEMA 
COM=4=TYPE.CHECK 
COM-LAST.ERROR.MESSAGE 
COM=ERROR 
COM=ERROR.PRINT 
;;; Reading source file "prog/edt/compile.lisp"
;;; Writing binary file "prog/edt/compile.sbin"
;;; Loading binary file "prog/edt/compile.sbin"
;;; Loading source file "prog/edt/edit.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
EDT*THEOREM.FLAG 
EDT*UNDO.MODE 
EDT*UNDO.STACK 
EDT*SYMBOL.TABLE.LIST 
EDT*SYMBOL.TABLE.UNDO.STACK 
EDT*SAVED.INDICATOR 
EDT*SAVING.INDICATOR 
EDT*SEPARATOR 
EDT*INPUT.FILES 
EDT*DIALOGUE.INPUT.FILE 
EDT*DIALOGUE.OUTPUT.FILE 
EDT*COMMANDS 
EDT*LINELENGTH 
EDT*STANDARD.READTABLE 
EDT*COMMAND.READTABLE 
EDT*SEPARATOR.READTABLE 
EDT*-READTABLE 
EDT*NUMBER.READTABLE 
EDT*NORMAL.READTABLE 
EDT-SET.READTABLES 
EDT-STANDARD-READTABLE 
EDT=READ 
EDT=READP 
EDT=FORMULA.TO.INSERT 
EDT=CHANGED.FORMULA 
EDT=GET.CL 
EDT=GET 
EDT*BUFFER 
EDT-EDIT 
EDT=GET.FILE.ACTIVE 
EDT-GET.FILES 
EDT=WORK 
EDT=GET.ACTIVE.FORMULAS 
EDT=NORM.COMMAND.NAME 
EDT=READ.COMMAND 
EDT=IGNORE.COMMAND 
EDT=WRITELN 
EDT=READLN 
EDT=READ.COMMAND.LINE 
EDT=ASK.READLN 
EDT=EXECUTE.COMMAND 
EDT=INSERT 
EDT=INSERT.INTERNAL 
EDT=DELETE 
EDT=SHIFT.UP 
EDT=SHIFT.ONE.UP 
EDT=SHIFT.DOWN 
EDT=SHIFT.ONE.DOWN 
EDT=EDIT 
EDT=CHANGE 
EDT=FORMULAE.FILE.IS 
EDT=READ* 
EDT=WRITE.GET 
EDT=WRITE 
EDT=EXECUTE 
EDT=SWITCH 
EDT=UNDO 
EDT=PUSH.UNDO 
EDT=REPLACE 
EDT=REPLACE.IN.ATOMS 
EDT=REPLACE.PART.OF.LIST 
EDT=PPRINT 
EDT=SHOW 
EDT=PRINT.TABLE 
EDT=PRINT.TABLE.DASH 
EDT=WRITE.TAB 
EDT=LIST.SYMBOL.PROPERTIES 
EDT=SYMBOLS&TABULATOR 
EDT=PREFIX 
EDT=INFIX 
EDT=END 
EDT=V 
EDT=HELP 
EDT=HHELP 
EDT=CREATE.FORMULA 
EDT=GET.INFIX.FORMULA 
EDT=GET.PREFIX.FORMULA 
EDT=IS.FIRST.INPUT.FILE 
EDT=INPUT.FILE 
EDT=SET.INPUT.FILE 
EDT=RESET.INPUT.FILE 
EDT=IS.INPUT.FILE.SEQUENCE.RECURSIVE 
EDT=COMMAND.COUNTER 
EDT=OUTPUTS 
EDT=SECOND.PART.ENGLISH 
EDT=SECOND.PART.GERMAN 
EDT=ERRORS 
EDT=GET.COMMAND 
;;; Reading source file "prog/edt/edit.lisp"
;;; Writing binary file "prog/edt/edit.sbin"
;;; Loading binary file "prog/edt/edit.sbin"
;;; Loading source file "prog/init/init.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MKRP-INIT 
;;; Reading source file "prog/init/init.lisp"
;;; Writing binary file "prog/init/init.sbin"
;;; Loading binary file "prog/init/init.sbin"
;;; Loading source file "prog/ds/datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
DS*SIGN.PLUS.SYMBOLS 
DS*SIGN.MINUS.SYMBOLS 
DS*CLAUSE.COMMON.CELLS 
;;; Warning: Defconstant is called again for the constant DS*CLAUSE.LITERAL.CELLS. Old value is retained.

DS*CLAUSE.LITERAL.CELLS 
DS=CLAUSE.STORAGE 
DS=CLAUSE.GET 
DS==CLAUSE.GET 
DS=CLAUSE.PUT 
DS==CLAUSE.PUT 
DS=CLAUSE.IS 
DS-LIT.CREATE 
DS-LIT.RENAMED 
DS-LIT.SIGN 
DS-LIT.PREDICATE 
DS-LIT.TERMLIST 
DS-LIT.IS.NEGATIVE 
DS-LIT.IS.POSITIVE 
DS-LIT.IS.EQUALITY 
DS-LITS.VARS 
DS-SIGN.IS.POSITIVE 
DS-SIGN.IS.NEGATIVE 
DS-SIGN.ARE.EQUAL 
DS-SIGN.ARE.NOT.EQUAL 
DS-SIGN.OTHER.SIGN 
DS=LIT.STORAGE 
DS=LIT.GETSIGN 
DS=LIT.PUTSIGN 
DS=LIT.GETPREDICATE 
DS=LIT.PUTPREDICATE 
DS=LIT.GETTERMLIST 
DS=LIT.PUTTERMLIST 
DS-PREDICATE.OTHERSIDES 
DS-PREDICATE.GET.OTHERSIDE.SIGN 
DS-PREDICATE.GET.OTHERSIDE.PREDICATE 
DS-PREDICATE.GET.OTHERSIDE.RULES 
DS*RULE.ADMISSIBLE.OTHERSIDES_T 
DS*RULE.ADMISSIBLE.OTHERSIDES_S+ 
DS*RULE.ADMISSIBLE.OTHERSIDES_S- 
DS*RULE.ADMISSIBLE.OTHERSIDES_R 
DS*RULES 
DS-RULES 
DS-RULE.TERMLISTS 
DS-RULE.ORIENTED 
DS-RULE.INSERT 
DS-RULE.R.IFF.T 
DS=RULE.CONSTRUCT.OTHERSIDE 
DS=RULE.SHORTEN.OTHERSIDE 
DS=CLAUSE.CREATE 
DS-CLAUSE.DO 
DS-CLAUSE.SOME 
DS-CLAUSE.CREATE 
DS-CLAUSE.POS.EQUATION 
DS-CLAUSE.FINITE.DOMAIN 
DS-LIT.FINITE.DOMAIN 
DS*FINITE.DOMAIN 
DS-FINITE.DOMAIN.SET 
DS-FINITE.DOMAIN.DOMAIN 
DS-FINITE.DOMAIN.CLAUSE 
DS-CLAUSE.ONLY.EQUATIONS 
DS-LIT.POS.EQUATION 
DS=REWRITE.UPDATE 
DS-REWRITE.UPDATE 
DS=CLAUSE.PUT.RULE 
DS=KZ.COMPUTE.LITERAL 
DS-COMPUTE.LITERAL 
DS-CLAUSE.LITERAL 
DS-CLAUSE.COMPUTE.MAX.LITNO 
DS=CLAUSE.REWRITE.RULE.SET 
DS-CLAUSE.REWRITE.RULE.SET 
DS-CLAUSE.IRREDUCIBLE.SET 
DS-CLAUSE.IRREDUCIBLE.IS 
DS-CLAUSE.REWRITE.LITERALS 
DS-CLAUSE.LIT.REWRITE.RULE 
DS-CLAUSE.LIT.IS.UNFAILING 
DS-CLAUSE.LIT.UNFAILING.SET 
DS-CLAUSE.LIT.IS.MAX 
DS-CLAUSE.LIT.SET.MAX 
DS-CLAUSE.PASSIVE.POSITIONS 
DS-CLAUSE.PUT.PASSIVE.POSITIONS 
DS-CLAUSE.RESET.REWRITE.RULE 
DS=CLAUSE.LIT.RESET.LINKCOLOURS 
DS-CLAUSE.PNAME 
DS-CLAUSE.LIT.GETPROP 
DS-CLAUSE.LIT.PUTPROP 
DS-CLAUSE.LIT.REMPROP 
DS-CLAUSE.LIT.REMPROPS 
DS-CLAUSE.LIT.GETPROPLIST 
DS-CLAUSE.ALL.LIT.REMPROP 
DS-CLAUSE.ALL.LIT.REMPROPS 
DS-CLAUSE.PARENTS 
DS-CLAUSE.PUT.PARENTS 
DS-CLAUSE.ANCESTORS 
DS-CLAUSE.DEPTH 
DS-CLAUSE.VARIABLES 
DS-CLAUSE.RENAMING 
DS-CLAUSE.NOLIT 
DS-CLAUSE.ATTRIBUTES 
DS-CLAUSE.ADD.ATTRIBUTES 
DS-CLAUSE.POTENTIALLY.FALSE.LITNOS 
DS-CLAUSE.PUT.POTENTIALLY.FALSE.LITNOS 
DS-CLAUSE.POTENTIALLY.TRUE.LITNOS 
DS-CLAUSE.PUT.POTENTIALLY.TRUE.LITNOS 
DS-CLAUSE.SIGN 
DS-CLAUSE.PREDICATE 
DS-CLAUSE.POS.PREDICATES 
DS-CLAUSE.ALL.PREDICATES 
DS-CLAUSE.PREDICATE.OCCURRENCES 
DS-CLAUSE.TERMLIST 
DS-CLAUSE.REPLACE.LITERAL 
DS-CLAUSE.LIT.VARIABLES 
DS-CLAUSE.LINKS 
DS-CLAUSE.LINKS.THISSIDE 
DS-CLAUSE.LINKS.OTHERSIDE 
DS-CLAUSE.LIT 
DS-CLAUSE.ALL.LINKS 
DS-CLAUSE.IS.EQUATION 
DS-CLAUSE.IS.UNIT 
DS-CLAUSE.IS.PURE 
DS-CLAUSE.IS.PREFERRED 
DS-CLAUSE.IS.HORN 
DS-CLAUSE.IS 
DS-CLAUSE.REMOVE.LITERAL 
DS-CLAUSE.ADMISSIBLE.SORT 
DS-CLAUSE.DELETE 
DS-CLAUSE.ONE.LIT.UNIFIER 
DS-CLAUSE.FCTSTACK 
DS-CLAUSE.VAR.OCCUR.IN.LITERAL 
DS*LINK.TYPES 
DS*LINK.CLAUSE 
DS*LINK.LITERALS 
DS*LINK.INITIAL 
DS*LINK.PURITY 
DS*LINK.RENAMED 
DS*LINK.NOPURITY 
DS*LINK.RULES 
DS*LINK.TAUTOLOGY.TYPE 
DS*LINK.WITH.NEGPARENT 
DS*LINK.ACTIVE.OPERATION 
DS*LINK.ACTIVE.OPERATION.EXTENDED 
DS*LINK.AUTOLINKS 
DS*LINK.NOT.AUTOLINKS 
DS*LINK.EXTENDED.PARAMODULATION 
DS*LINK.WITH.UNIFIERS 
DS*LINK.PARAMODULATION 
DS*LINK.ACTIVE.PARAMODULATION 
DS*LINK.STORAGE.SIZE 
DS=LINK.STORAGE 
DS=LINK.GET 
DS==LINK.GET 
DS=LINK.PUT 
DS==LINK.PUT 
DS-LINK.CREATE 
DS-LINK.SORT.INHIBITED 
DS-LINK.PUT.SORT.INHIBITED 
DS-LINK.SORT.RESIDUE 
DS-LINK.PUT.SORT.RESIDUE 
DS-LINK.COLOUR 
DS-LINK.UNIFIERS 
DS-LINK.PUTUNIFIERS 
DS-LINK.NOUNIFIERS 
DS-LINK.UNIFIER 
DS-LINK.RULE 
DS-LINK.REMOVE.UNIFIER 
DS-LINK.LABEL 
DS-LINK.MARK 
DS-LINK.IS.MARKED 
DS-LINK.NEGPAR 
DS-LINK.NEGLITNO 
DS-LINK.NEGFCT 
DS-LINK.DEMODULATION.IS 
DS-LINK.DEMODULATION.SET 
DS-LINK.NEGTERM 
DS-LINK.NEGLIT 
DS-LINK.POSPAR 
DS-LINK.POSLITNO 
DS-LINK.POSFCT 
DS-LINK.RESULT 
DS-LINK.SELECTION.INFO 
DS-LINK.RESULT.VARIABLES 
DS-LINK.PUT.RESULT 
DS-LINK.PUT.SELECTION.INFO 
DS-LINK.PUT.RESULT.VARIABLES 
DS-LINK.POSTERM 
DS-LINK.POSLIT 
DS-LINK.OTHERPAR 
DS-LINK.OTHERLITNO 
DS-LINK.CONNECT 
DS-LINK.DISCONNECT 
DS-LINK.DEPTH 
DS-LINK.NOLIT 
DS-LINK.IS 
DS-LINK.DELETE 
DS-LINK.COLOURS.WITH 
DS-LINK.COLOURS.FOR 
DS-LINK.SIDE 
DS-LINK.THISLITNO 
DS-LINK.THISFCT 
DS-LINK.OTHERFCT 
DS-LINK.THISSIDE 
DS-LINK.OTHERSIDE 
DS-LINK.FUNCTIONSYMBOLS 
DS=LINK.GETCOLOUR 
DS=LINK.IS 
DS=LINK.STORAGE.SIZE 
DS=LINK.COMPUTE.DIRECTION 
DS*DUMMY.ATOM 
DS*EQUALITY.SYMBOLS 
DS-RESET 
DS-TYPE 
DS-GET.TYPE 
DS-PNAME 
DS-UNI.CREATES.VARIABLES 
DS-SAVE 
DS=FIND.VARIABLES 
DS=TERM.FUNCTIONSYMBOL 
DS=TERM.VAR.OCCUR 
;;; Reading source file "prog/ds/datastructure.lisp"
;;; GC: 347016 words [1388064 bytes] of dynamic storage in use.
;;; 324726 words [1298904 bytes] of free storage available before a GC.
;;; 996468 words [3985872 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/ds/datastructure.sbin"
;;; Loading binary file "prog/ds/datastructure.sbin"
;;; Warning: Defconstant is called again for the constant DS*CLAUSE.LITERAL.CELLS. Old value is retained.
;;; Loading source file "prog/uni/uni-commutative.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
COMM=UNIFY 
COMM=UNIFY.TERMS 
COMM=UNIFY.TERMLISTS 
COMM=INSERT 
COMM=INSERT.COMP 
;;; Reading source file "prog/uni/uni-commutative.lisp"
;;; Writing binary file "prog/uni/uni-commutative.sbin"
;;; Loading binary file "prog/uni/uni-commutative.sbin"
;;; Loading source file "prog/uni/ac-match.lisp"

#<Package "TH-AC-MKRP" 160373E> 
*CONTROLL-BLOCK* 
*AC-MATCH-NEC* 
*AC-ERG-SUBST* 
*ALLE-LOESUNGEN* 
E-COMPL*AC-FUNCTIONS 
*AC-TIME* 
*HELP-ACTIME* 
*AC-MATCH-COUNT* 
*FAIL-MATCHES* 
*NORMALISIERE-TIME* 
*HELP-NORMTIME* 
*SINGLE-MATCH-TIME* 
*SINGLE-MATCH-HELP* 
*GREAT-SINGLE-MATCH-TIME* 
AC-FUNCTION 
GIVE-FUNCTOR-FROM-GL 
GIVE-VARLIST-FROM-GL 
GIVE-ARGLIST-FROM-GL 
CREATE-GL-ENTRY 
GET-VARNAME 
GET-COMPOSITION-POSSIBLE 
GET-ARGUMENTLIST 
GET-FUNCTOR 
CREATE-VARENTRY 
SET-COMPOSITION-IMPOSSIBLE 
SET-ARGUMENTLIST 
CREATE-COMPOSS-ARG 
GET-COMPOSS-ARG 
GET-COMPOSS-COUNT 
GET-COMPOSS-ACTUAL 
SET-COMPOSS-ACTUAL 
SET-COMPOSS-COUNT 
CREATE-NORMAL-ARGLIST 
AC-NORMALFORM 
MERGE-SORT 
TERMEQUAL 
TERMGREATER 
CHECK-GREATER-SET 
CHECK-GREATER-LIST 
AC-MATCH 
MATCH-ARG 
AC-MATCH-LIST 
AC-MATCH-SET 
ADD-GLEICHUNG 
GLEICHUNGSEINTRAG 
MAKE-NF-TO-ARG 
MAKE-SET-TO-ARG 
NEXT-STATEMENT 
SUBSTITUTED 
CHECK-FOR-RIGHT-SUBST 
CHECK-SUBST-RECH-POSSIBLE 
STREICHE-SUBST 
STREICHE-ARGUMENTE 
LOESCHE-SUBST-AUS-GL 
CHECK-POSSIBLE-SOLUTIONS 
LOOK-FOR-VARSOLUTIONS 
FILTER-VAR-SOLUTIONS 
COMBINE-ARGS-AND-FILTER 
FILTER-MIN 
CHANGE-COMP-TO-NORMAL 
NEXT-COMPOSS-ARGUMENT 
READ-VAR-SUBST 
NEXT-NORMAL-ARGUMENT 
CREATE-VAR-SOL-ENTRY 
INSERT-VARENTRY 
CHECK-FOR-ENTHALTEN 
CHECK-FOR-ENTHALTEN-COMPOSS 
LOESE-GLEICHUNGSSYS-NORMAL 
LOESE-GLEICHUNGSSYS-ALLE 
PROBIERE-LOESUNGEN-NORMAL 
PROBIERE-LOESUNGEN-ALLE 
CHECK-FOR-NOT-SUBST 
FIND-GOOD-ORDER 
CHECK-FOR-LINEAR-TERMS 
LOESE-LINEAR-TERMS 
MINIMAL-COUNT-OF-ARGS 
COUNT-MINIMAL-ARGS 
RETTE-LOESUNG 
AC-MATCH-ALLE 
GET-COMPOSS-VALUE 
SU=AC-MATCH 
CONVERT-SUBST-TO-ADLER 
MATCH-STATISTIK 
SCHALTE-NORMAL 
#<Interpreted-Function (NAMED-LAMBDA PROBIERE-LOESUNGEN-NORMAL (VAR-LIST-OF-SOLUTIONS GL-LIST) (BLOCK PROBIERE-LOESUNGEN-NORMAL (IF (NULL VAR-LIST-OF-SOLUTIONS) (IF (NULL GL-LIST) (QUOTE T) (QUOTE NIL)) (IF (NULL GL-LIST) (CHECK-FOR-NOT-SUBST VAR-LIST-OF-SOLUTIONS) (LET ((ARGLIST (GET-ARGUMENTLIST (CAR VAR-LIST-OF-SOLUTIONS))) (VARNAME (GET-VARNAME (CAR VAR-LIST-OF-SOLUTIONS))) (FUNCTOR (GET-FUNCTOR (CAR VAR-LIST-OF-SOLUTIONS))) (COMPOSS-POSSIBLE (GET-COMPOSITION-POSSIBLE (CAR VAR-LIST-OF-SOLUTIONS)))) (IF (SUBSTITUTED VARNAME) (PROBIERE-LOESUNGEN (CDR VAR-LIST-OF-SOLUTIONS) GL-LIST) (LET ((SUBST-LIST *AC-ERG-SUBST*) (FOUND (QUOTE NIL)) (SUCHFUNCTION (IF (EQ COMPOSS-POSSIBLE (QUOTE Y)) (QUOTE NEXT-COMPOSS-ARGUMENT) (PROGN (RPLACA ARGLIST (CDR ARGLIST)) (QUOTE NEXT-NORMAL-ARGUMENT))))) (DO ((NEW-SUBST (FUNCALL (SYMBOL-FUNCTION SUCHFUNCTION) ARGLIST FUNCTOR) (FUNCALL (SYMBOL-FUNCTION SUCHFUNCTION) ARGLIST FUNCTOR))) ((OR (NULL NEW-SUBST) FOUND) (IF FOUND (QUOTE T) (QUOTE NIL))) (LET ((NEW-GL-LIST (LOESCHE-SUBST-AUS-GL (CONS (LIST VARNAME NEW-SUBST) (QUOTE NIL)) GL-LIST))) (IF (EQ NEW-GL-LIST (QUOTE KEINMATCH)) (SETQ *AC-ERG-SUBST* SUBST-LIST) (PROGN (SETQ *AC-ERG-SUBST* (APPEND (CONS (LIST VARNAME NEW-SUBST) (QUOTE NIL)) *AC-ERG-SUBST*)) (IF (PROBIERE-LOESUNGEN (CDR VAR-LIST-OF-SOLUTIONS) NEW-GL-LIST) (SETQ FOUND (QUOTE T)) (SETQ *AC-ERG-SUBST* SUBST-LIST))))))))))))) 2785186> 
;;; Reading source file "prog/uni/ac-match.lisp"
;;; While compiling NEXT-NORMAL-ARGUMENT
;;; Warning: Variable FUNCTOR is bound but not referenced
;;; Writing binary file "prog/uni/ac-match.sbin"
;;; Loading binary file "prog/uni/ac-match.sbin"
;;; Loading source file "prog/uni/uni-thu.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
THU=TYPE 
THU-TERMS 
THU-TERMLISTS 
;;; Reading source file "prog/uni/uni-thu.lisp"
;;; Writing binary file "prog/uni/uni-thu.sbin"
;;; Loading binary file "prog/uni/uni-thu.sbin"
;;; Loading source file "prog/uni/unification.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
UNI*VARIABLES.REGARDED.AS.CONSTANTS 
UNI*VARIABLES.DECLARED.AS.CONSTANTS 
UNI*BINDINGFLAG 
UNI*BUFFER.STACK 
UNI*CONSTANTIFY.BUFFER 
UNI-RESET 
UNI-UNIFY.TERMS 
UNI-UNIFY.TERMLISTS 
UNI-UNIFY.ATOMS 
UNI-UNIFY.QUICK.TEST 
UNI-UNIFY.LIST.OF.MIXED.TERMLISTS 
UNI-UNIFY.MIXED.TERMLIST 
UNI=WEAK.UNION.OF.SUBSTITUTIONLISTS 
UNI-UNIFY.TERMLISTS.WITH.RULE 
UNI=REMOVE.SUBSTITUTIONS 
UNI-UNIFY.UNIFIER 
UNI-EQUAL.SUBSTS 
UNI-UNIFY.AWAY 
UNI=UNIFY.TERMS 
UNI=UNIFY.TERMLISTS 
UNI=UNIFY.ATOMS 
UNI=UNIFY.QUICK.TEST 
UNI=UNIFY.MIXED.TERMLIST 
UNI=UNIFY.TERMLISTS.WITH.RULE 
UNI=UNMATCHABLE 
UNI-UNIFY1.TERMS 
UNI-UNIFY1.TERMLISTS 
UNI-UNIFY1.ATOMS 
UNI-MATCHABLE 
UNI-UNIFIER.IS.MATCHER 
UNI-UNIFIER.CANBE.MATCHER 
UNI-UNIFIER.BECOMES.MATCHER 
UNI=MATCH.TERMS 
UNI=MATCH.TERMLISTS 
UNI=MATCH.WITH.BUFFER 
UNI=MAKE.MATCHER 
UNI-EQUAL.TERMS 
UNI-EQUAL.TERMLISTS 
UNI-EQUAL.ATOMS 
UNI=EQUAL.TERMS 
UNI=EQUAL.TERMLISTS 
UNI-MERGE.SUBSTITUTIONS 
UNI-MERGE.SUBSTITUTIONLISTS 
UNI-MERGE.LIST.OF.SUBSTITUTIONLISTS 
UNI-MERGE.BINDING.WITH.SUBSTITUTION 
UNI-MERGE1.SUBSTITUTIONS 
UNI-MERGE1.SUBSTITUTIONLISTS 
UNI-MERGE1.LIST.OF.SUBSTITUTIONLISTS 
UNI-MERGE.MATCHERS 
UNI-MERGE.MATCHERLISTS 
UNI-MERGE.LIST.OF.MATCHERLISTS.FIT.ON.SORTS 
UNI-MERGE.LIST.OF.MATCHERLISTS 
UNI-INSTANCE.IS 
UNI-BINDING.IS.INSTANCE.OF 
UNI-WEAK.INSTANCE 
UNI=MERGE.SUBSTITUTIONS 
UNI=MERGE.SUBSTITUTIONLISTS 
UNI=MERGE.LIST.OF.SUBSTITUTIONLISTS 
UNI=MERGE.MATCHERS 
UNI=MERGE.MATCHERLISTS 
UNI=INSTANCE.IS 
UNI=BINDING.IS.INSTANCE.OF 
UNI=WEAK.INSTANCE 
UNI=POLY.VARIABLE.TERM.R 
UNI=POLY.TERM.SORT 
UNI=POLY.WEAKENING 
UNI=POLY.SUBST.LESS 
UNI=VARIABLE.SORT 
UNI=POLY.X.WITH.T 
UNI=POLY.SORT.WITH.T 
UNI-APPLY.SUBSTITUTION.TO.LITLIST 
UNI-APPLY.SUBSTITUTION 
UNI-UNION.OF.SUBSTITUTIONLISTS 
UNI-LITERAL.SORT.UNIFIER 
UNI-LITERAL.SORT.RESIDUE 
UNI-LITERAL.SORT.IS 
UNI-FIT.ON.LITERAL.SORT 
UNI-FIT.ON.SORT 
UNI-UNIFIER.IS.VARIABLE.RENAMING 
UNI-SWITCH 
UNI-RENAME 
UNI-REMOVE.INSTANCES 
UNI-REMOVE.COMPONENTS 
UNI-CONSTANTIFY 
UNI-DECLARE.VARIABLES.AS.CONSTANTS 
UNI-CLEAR.VARIABLES.AS.CONSTANTS 
UNI-UNIFIER.DOMAIN 
UNI-UNIFIER.CODOMAIN 
UNI-SET.BINDINGS.OF.SUBSTITUTION 
UNI-RESET.BINDINGS.OF.SUBSTITUTION 
UNI=UNION.OF.SUBSTITUTIONLISTS 
UNI=SWITCH 
UNI=RENAME 
UNI=REMOVE.INSTANCES 
UNI=REMOVE.COMPONENTS 
UNI=UNIFIER.DOMAIN 
UNI=APPLY.SUBSTITUTION 
UNI=SUBSTITUTE 
UNI=APPLY.SUBSTITUTION.TO.SUBSTITUTION 
UNI=FIND.VARIABLES 
UNI=COMPOSITION.OF.SUBSTITUTIONS 
UNI=COMPOSITION.OF.SUBSTITUTION.AND.SUBSTITUTIONLIST 
UNI=COPY 
UNI=CONSTANT.IS 
UNI=VARIABLE.IS 
UNI=GET.BINDING 
UNI=SET.BINDINGS 
UNI=UNBIND 
UNI=RESET.BINDINGS 
UNI-INSERT.BINDINGS.IN 
UNI=INSERT.BINDINGS.IN 
UNI-DELETE.ALL.BINDINGS 
UNI-SHOW.ALL.BINDINGS 
UNI=TEMP.FIND.VARIABLES 
UNI-EQUAL 
UNI-RESTRICT 
;;; Reading source file "prog/uni/unification.lisp"
;;; GC: 310636 words [1242544 bytes] of dynamic storage in use.
;;; 361106 words [1444424 bytes] of free storage available before a GC.
;;; 1032848 words [4131392 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/uni/unification.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UPP-INIT was referenced by UNI-RESET
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by UNI-RESET
;;;          UPR-MATCH.SUBSTITUTION was referenced by
;;;             UNI-MERGE.LIST.OF.MATCHERLISTS.FIT.ON.SORTS
;;;          UPR-UNIFY.SUBSTITUTION was referenced by
;;;             UNI-FIT.ON.LITERAL.SORT
;;; Loading binary file "prog/uni/unification.sbin"
;;; Loading source file "prog/norm/normalization.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
NORM*LITERAL.INDEX 
NORM=SET.INDEX 
NORM-NORMALIZATION 
NORM-NEW.FORMULA 
NORM-NEXT.SPLITPART 
NORM-SEVERAL.SPLITPARTS? 
NORM-MORE.SPLITPARTS? 
NORM-PRENEX.FORM 
NORM-RESET 
NORM=NORMALIZE.1 
NORM=NORMALIZE.2 
NORM=MOVE.QUANTIFIERS.INSIDE 
NORM=MOVE.ALL.INSIDE 
NORM=MOVE.EX.INSIDE 
NORM=MOVE.QUANTIFIERS.OUTSIDE 
NORM=EXTRACT.PREFIX.MATRIX 
NORM=MARK.SPLIT 
NORM=REPLACE.EQV 
NORM=REPLACE.IMPL 
NORM=MOVE.NEGATIONS.TO.LITERALS 
NORM=SKOLEMIZE 
NORM=SPLIT.LAZY 
NORM=PREPARE.SPLIT.LAZY 
NORM=PREPARE.SPLIT 
NORM=SPLIT 
NORM=REMOVE.QUANTIFIERS 
NORM=TRANSFORM.TO.PSEUDO.CNF 
NORM=MULTIPLY.TO.CNF 
NORM=TRANSFORM.TO.PSEUDO.DNF 
NORM=MULTIPLY.TO.DNF 
NORM=MULTIPLY.TO.DNF1 
NORM=FLATTEN.CLAUSELIST 
NORM=FLATTEN.LITLIST 
NORM-COPY 
NORM=COPY 
NORM=VARIABLE.OCCURS.IN 
NORM=REPLACE.VARIABLE 
NORM=REPLACE.VARIABLE.IN.TERMLIST 
NORM=CREATE.FORMULA 
NORM-CREATE.FORMULA 
NORM=OP 
NORM=PUT=OP 
NORM=LEFT 
NORM=PUT=LEFT 
NORM=RIGHT 
NORM=PUT=RIGHT 
NORM=PUT=INDEX 
NORM*FUNCTION.COUNTER 
NORM*CONSTANT.COUNTER 
NORM*MAX.SPLIT.DEPTH 
NORM*EXPRESSION 
NORM*EXPRESSION.LENGTH 
NORM*EXPRESSION.LENGTH.ORIGINAL 
NORM*FILE.VERSION 
NORM=DROP.VARIABLE 
NORM=NEW.VARIABLE 
NORM=NEW.TERM 
;;; Reading source file "prog/norm/normalization.lisp"
;;; Writing binary file "prog/norm/normalization.sbin"
;;; Loading binary file "prog/norm/normalization.sbin"
;;; Loading source file "prog/norm/presimplification.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PSIM-PRESIMPLIFICATION 
PSIM-APPLY.DEFINITIONS 
PSIM=DEFINITION 
PSIM=DEFINITION.IS 
PSIM=REPLACE 
PSIM=REMOVE.PROPERTIES 
PSIM=CREATE.TRUTH.VALUES 
PSIM=SIMPLIFY.TRUTH.VALUES 
PSIM=NORMALIZE.SIGN 
PSIM=SIMPLIFY.TRUTH.VALUES.NOT 
PSIM=SIMPLIFY.TRUTH.VALUES.AND 
PSIM=SIMPLIFY.TRUTH.VALUES.OR 
PSIM=SIMPLIFY.TRUTH.VALUES.IMPL 
PSIM=SIMPLIFY.TRUTH.VALUES.EQV 
PSIM=SIMPLIFY.TRUTH.VALUES.QUANTIFIER 
PSIM=OP 
PSIM=PUT=OP 
PSIM=LEFT 
PSIM=PUT=LEFT 
PSIM=RIGHT 
PSIM=PUT=RIGHT 
;;; Reading source file "prog/norm/presimplification.lisp"
;;; Writing binary file "prog/norm/presimplification.sbin"
;;; Loading binary file "prog/norm/presimplification.sbin"
;;; Loading source file "prog/cg/connectiongraph.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CG*COMMONS.TO.SAVE 
CG*RECOLOUR 
CG*OBJECTCLASSES 
CG*SAVESTACK 
CG*GRAPH.REGISTER 
CG-CREATE.EMPTY.GRAPH 
CG-DISJOINTIFY 
CG-FIX 
CG-PUSH 
CG-POP 
CG-STORE.GRAPH.REGISTER 
CG-RECALL.GRAPH.REGISTER 
CG-VIRTUAL.GRAPH 
CG=SAVE 
CG=SAVE.STACK 
CG=INSERT.EPSILON 
CG=REMOVE.EPSILON 
CG=REPLACE.EPSILON 
CG-CLAUSES 
CG-#CLAUSES 
CG-INSERT.CLAUSE 
CG-CLAUSE_ANCESTOR.LITERALS 
CG-CLAUSE_DESCENDANT.LITERALS 
CG-CLAUSE_CREATOR.UNIFIER 
CG-REMOVE.CLAUSE 
CG-REPLACE.LITERAL 
CG-CLAUSE.CHANGED.P 
CG-REMOVE.LITERAL 
CG=MERGE.RELATIVES 
CG=RECALCULATE.LITNOS 
CG=CLAUSE_PUT.DESCENDANT.LITERALS 
CG-LINKS 
CG-#LINKS 
CG-INSERT.LINK 
CG-LINK_ANCESTOR.LINKS 
CG-LINK_DESCENDANT.LINKS 
CG-REMOVE.LINK 
CG-INSERT.UNIFIER 
CG-REMOVE.UNIFIER 
CG-INHIBIT.UNIFIER 
CG=INSERT.LINK 
CG=INSERT.UNIFIER 
CG=REMOVE.LINK 
CG=REMOVE.UNIFIER 
CG=LINK_ANCESTOR.LINKS 
CG=REPR_EMPTY.OBJECTLIST 
CG=REPR_RESET 
CG=REPR_INSERT 
CG=REPR_REMOVE 
CG=REPR_LIST 
CG=REPR_LENGTH 
CG=REPR_SAVE 
CG=REPR_INIT 
CG=REPR_GET 
CG=REPR_PUT 
CG*CHANGE.QUEUE.LITERALS 
CG-CHANGE.QUEUE_APPEND 
CG-CHANGE.QUEUE_TOP 
CG-CHANGE.QUEUE_POP 
CG-CHANGE.QUEUE 
CG*POSITION 
CG-DUMP 
CG==DUMP 
CG=DUMP 
CG-DUMP.SHORT 
CG==DUMP.SHORT 
CG=DUMP.SHORT 
CG=PR_CLAUSES 
CG=PR_CLAUSE 
CG=PR_LITERAL 
CG=PR_CLAUSE.SHORT 
CG=PR_LIST.LITERALS 
CG=PR_LINKS 
CG=PR_LINK 
CG=PR_VARIABLES 
CG=PR_LIST 
;;; Reading source file "prog/cg/connectiongraph.lisp"
;;; Writing binary file "prog/cg/connectiongraph.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by
;;;             CG=INSERT.EPSILON, CG=REPLACE.EPSILON
;;;          UPP-EPSILON.LITERALS.DELETE was referenced by
;;;             CG=REMOVE.EPSILON, CG=REPLACE.EPSILON
;;; Loading binary file "prog/cg/connectiongraph.sbin"
;;; Loading source file "prog/prot/prot-datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PDS-RESET 
PDS-CLAUSE.PROPERTY 
PDS-CLAUSE.ADD.PROPERTY 
PDS-ALLOCATE.MEMORY.ADDRESS 
PDS-PNAME 
PDS-PUT.PROTOCOL.TYPE 
PDS-PUT.COMMENT 
PDS-PUT.PROOF.VERSION 
PDS-PUT.RUN.DATE 
PDS-PUT.OPTIONS 
PDS-PUT.INDICES 
PDS*PROTOCOL.TYPE 
PDS*COMMENT 
PDS*PROOF.VERSION 
PDS*RUN.DATE 
PDS*OPTIONS 
PDS*INDICES 
PDS-GET.PROTOCOL.TYPE 
PDS-GET.COMMENT 
PDS-GET.PROOF.VERSION 
PDS-GET.RUN.DATE 
PDS-GET.OPTIONS 
PDS-GET.INDICES 
PDS-PUT.AXIOMS.INFIX 
PDS-PUT.THEOREMS.INFIX 
PDS-PUT.AXIOMS.PREFIX 
PDS-PUT.THEOREMS.PREFIX 
PDS-ADD.AXIOMS 
PDS-ADD.AX.OPERATION 
PDS-ADD.AX.STATISTICS 
PDS-PUT.FINAL.AXIOM.CLAUSES 
PDS-PUT.AXIOMS.TIME 
PDS-PUT.AX.SYMBOLS 
PDS*AX.INFIX 
PDS*TH.INFIX 
PDS*AX.PREFIX 
PDS*TH.PREFIX 
PDS*AXIOMS.GRAPH 
PDS*AX.OPERATIONS 
PDS*AX.STATISTICS 
PDS*FINAL.AXIOM.CLAUSES 
PDS*AXIOMS.TIME 
PDS*AX.SYMBOLS 
PDS-GET.AXIOMS.INFIX 
PDS-GET.THEOREMS.INFIX 
PDS-GET.AXIOMS.PREFIX 
PDS-GET.THEOREMS.PREFIX 
PDS-GET.AXIOMS 
PDS-GET.AX.OPERATIONS 
PDS-GET.AX.STATISTICS 
PDS-GET.FINAL.AXIOM.CLAUSES 
PDS-GET.AXIOMS.TIME 
PDS-GET.AX.SYMBOLS 
PDS-ADD.PROOF.PART 
PDS*PROOF.PARTS 
PDS-ALL.PROOF.PARTS 
PDS-PROOF.PART.CREATE 
PDS=PROOF.PART.STORAGE 
PDS=PROOF.PART.PUT.IDENTIFIER 
PDS=PROOF.PART.PUT.CHANGED.OPTIONS 
PDS=PROOF.PART.PUT.INITIAL.CLAUSES 
PDS=PROOF.PART.PUT.OPERATIONS 
PDS=PROOF.PART.PUT.STATISTICS.BLOCKS 
PDS=PROOF.PART.PUT.TOTAL.STATISTICS 
PDS=PROOF.PART.PUT.FINAL.CLAUSES 
PDS=PROOF.PART.PUT.RESULT 
PDS=PROOF.PART.PUT.REASON 
PDS=PROOF.PART.PUT.TIME 
PDS=PROOF.PART.PUT.USED.CLAUSES 
PDS=PROOF.PART.PUT.PROOF.TREE 
PDS=PROOF.PART.PUT.SYMBOLS 
PDS=PROOF.PART.PUT.O.N.C.ADDRESSES 
PDS-PROOF.PART.IDENTIFIER 
PDS-PROOF.PART.CHANGED.OPTIONS 
PDS-PROOF.PART.INITIAL.CLAUSES 
PDS-PROOF.PART.OPERATIONS 
PDS-PROOF.PART.STATISTICS.BLOCKS 
PDS-PROOF.PART.TOTAL.STATISTICS 
PDS-PROOF.PART.FINAL.CLAUSES 
PDS-PROOF.PART.RESULT 
PDS-PROOF.PART.REASON 
PDS-PROOF.PART.TIME 
PDS-PROOF.PART.PROOF.TREE 
PDS-PROOF.PART.SYMBOLS 
PDS-PROOF.PART.O.N.C.ADDRESSES 
PDS-ADD.SPLITPART 
PDS*SPLITPARTS 
PDS-ALL.SPLITPARTS 
PDS-SPLITPART.CREATE 
PDS=SPLITPART.STORAGE 
PDS=SPLITPART.PUT.AXIOMS 
PDS=SPLITPART.PUT.THEOREMS 
PDS=SPLITPART.PUT.INITIAL.GRAPH 
PDS=SPLITPART.PUT.CHANGED.OPTIONS 
PDS=SPLITPART.PUT.OPERATIONS 
PDS=SPLITPART.PUT.RESULT 
PDS=SPLITPART.PUT.REASON 
PDS=SPLITPART.PUT.USED.CLAUSE.LIST 
PDS=SPLITPART.PUT.PROOF.TREE 
PDS=SPLITPART.PUT.STATISTICS 
PDS=SPLITPART.PUT.TOTAL.STATISTICS 
PDS=SPLITPART.PUT.SYMBOLS 
PDS=SPLITPART.PUT.IDENTIFIER 
PDS-SPLITPART.INSERT.TOTAL.STATISTICS 
PDS-SPLITPART.AXIOMS 
PDS-SPLITPART.THEOREMS 
PDS-SPLITPART.INITIAL.GRAPH 
PDS-SPLITPART.CHANGED.OPTIONS 
PDS-SPLITPART.OPERATIONS 
PDS-SPLITPART.RESULT 
PDS-SPLITPART.REASON 
PDS-SPLITPART.USED.CLAUSE.LIST 
PDS-SPLITPART.STATISTICS 
PDS-SPLITPART.TOTAL.STATISTICS 
PDS-SPLITPART.SYMBOLS 
PDS-SPLITPART.IDENTIFIER 
PDS-OPERATION.CREATE 
PDS=OPERATION.STORAGE 
PDS=OPERATION.PUT.CLAUSES 
PDS=OPERATION.PUT.TYPE 
PDS=OPERATION.PUT.PARENTS 
PDS=OPERATION.PUT.USE 
PDS=OPERATION.PUT.DESCRIPTORS 
PDS-OPERATION.INSERT.USE 
PDS-OPERATION.CLAUSES 
PDS-OPERATION.TYPE 
PDS-OPERATION.PARENTS 
PDS-OPERATION.USE 
PDS-OPERATION.UNIFIER 
PDS-OPERATION.RULE 
PDS-OPERATION.POS.EQ.PAR 
PDS-OPERATION.LITNO.1 
PDS-OPERATION.POS.EQ.LITNO 
PDS-OPERATION.LITNO.2 
PDS-OPERATION.NEG.PAR 
PDS-OPERATION.NEG.LITNO 
PDS-OPERATION.FCT 
PDS-CLAUSE.CREATE 
PDS=CLAUSE.STORAGE 
PDS=CLAUSE.PUT.PNAME 
PDS=CLAUSE.PUT.PARENTS 
PDS=CLAUSE.PUT.SORTS.VARIABLES 
PDS=CLAUSE.PUT.LITERALS 
PDS=CLAUSE.PUT.USE 
PDS-CLAUSE.ADD.PARENT 
PDS-CLAUSE.ADD.USE 
PDS-CLAUSE.IS 
PDS-CLAUSE.PNAME 
PDS-CLAUSE.PARENTS 
PDS-CLAUSE.SORTS.VARIABLES 
PDS-CLAUSE.LITERALS 
PDS-CLAUSE.USE 
;;; Reading source file "prog/prot/prot-datastructure.lisp"
;;; Writing binary file "prog/prot/prot-datastructure.sbin"
;;; Loading binary file "prog/prot/prot-datastructure.sbin"
;;; Loading source file "prog/prot/prot-print.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPP*AXIOMS.FLAG 
PPP*INFIX.FLAG 
PPP*PREFIX.FLAG 
PPP*DIRECT.PROOF 
PPP*INDENTATION 
PPP*LINE 
PPP*FIRST.LINE 
PPP*LAST.LINE 
PPP*REAL.#.OF.LINES 
PPP-PRINT.PROTOCOL 
PPP=TTY.PROTOCOL 
PPP=DEFINE.COMMON.VARIABLES 
PPP*USED.SIGN 
PPP*IMPLICATION.SIGN 
PPP*CONJUNCTION.SIGN 
PPP=PRINT.HEAD 
PPP=PRINT.HEAD.LINE 
PPP=PRINT.OPTIONS 
PPP=PRINT.INFIX.FORM 
PPP=PRINT.PREFIX.FORM 
PPP=PRINT.PREFIX.FORMULA 
PPP=PRINT.SYMBOLTABLE 
PPP*OLD.NEW.SYMBOL.ADDRESSES 
PPP=RECONSTRUCT.SYMBOLS 
PPP=PRINT.AXIOM.CLAUSES 
PPP=PRINT.AX.OPERATIONS 
PPP=PRINT.SPLITTED.THEOREMS 
PPP=PRINT.INITIAL.OPERATIONS 
PPP=PROOF.PARTS.WITH.OPERATIONS 
PPP=PRINT.OPERATIONS 
PPP=PRINT.SPLITPART 
PPP=OPERATION.PREMISE 
PPP=RULE 
PPP=LONGEST.OPERATION.PREMISE 
PPP=LENGTH.OF.OPERATION.PREMISE 
PPP=LONGEST.CLAUSE.PNAME 
PPP=PRINT.OPERATION 
PPP=PRINT.TOTAL.RESULT 
PPP=PRINT.TOTAL.STATISTICS 
PPP*TOTAL.VARIABLE.NUMBER 
PPP-PRINT.CLAUSE 
PPP=PRINT.CLAUSE 
PPP=RENAME.VARIABLES 
PPP=RENAME.LITERALS 
PPP*UNIVERSAL.QUANTIFIER 
PPP=PRINT.CLAUSE.QUANTIFIERS 
PPP=TERM 
PPP=REPLACE.BY.PNAME 
PPP*DIFFERENT.VARIABLES.FLAG 
PPP=PRINT.TO.RIGHT.END 
PPP=TERPRI 
PPP=TAB 
PPP=PAGE 
PPP=PRINT.TEXT 
PPP=PRINT.WORD 
PPP=PRINT.WITH.UNDERSCORE 
PPP=APPLY.SUBSTITUTION 
;;; Reading source file "prog/prot/prot-print.lisp"
;;; Writing binary file "prog/prot/prot-print.sbin"
;;; Loading binary file "prog/prot/prot-print.sbin"
;;; Loading source file "prog/prot/prot-latex.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPP*L_AXIOMS.FLAG 
PPP*L_INFIX.FLAG 
PPP*L_PREFIX.FLAG 
PPP*L_DIRECT.PROOF 
PPP*L_INDENTATION 
PPP*L_LINE 
PPP*L_FIRST.LINE 
PPP*L_LAST.LINE 
PPP*L_REAL.#.OF.LINES 
PPP=LATEX.PROTOCOL 
PPP=L_DEFINE.COMMON.VARIABLES 
PPP*L_USED.SIGN 
PPP*L_IMPLICATION.SIGN 
PPP*L_CONJUNCTION.SIGN 
PPP=L_PRINT.HEAD 
PPP=L_PRINT.HEAD.LINE 
PPP=L_PRINT.OPTIONS 
PPP=L_PRINT.INFIX.FORM 
PPP=L_PRINT.PREFIX.FORM 
PPP=L_PRINT.PREFIX.FORMULA 
PPP=L_PRINT.SYMBOLTABLE 
PPP*L_OLD.NEW.SYMBOL.ADDRESSES 
PPP=L_RECONSTRUCT.SYMBOLS 
PPP=L_PRINT.AXIOM.CLAUSES 
PPP=L_PRINT.AX.OPERATIONS 
PPP=L_PRINT.SPLITTED.THEOREMS 
PPP=L_PRINT.INITIAL.OPERATIONS 
PPP=L_PROOF.PARTS.WITH.OPERATIONS 
PPP=L_PRINT.OPERATIONS 
PPP=L_PRINT.SPLITPART 
PPP=L_OPERATION.PREMISE 
PPP=L_RULE 
PPP=L_LONGEST.OPERATION.PREMISE 
PPP=L_LENGTH.OF.OPERATION.PREMISE 
PPP=L_LONGEST.CLAUSE.PNAME 
PPP=L_PRINT.OPERATION 
PPP=L_PRINT.TOTAL.RESULT 
PPP=L_PRINT.TOTAL.STATISTICS 
PPP*L_TOTAL.VARIABLE.NUMBER 
PPP=L_PRINT.CLAUSE 
PPP=L_RENAME.VARIABLES 
PPP=L_RENAME.LITERALS 
PPP*L_UNIVERSAL.QUANTIFIER 
PPP=L_PRINT.CLAUSE.QUANTIFIERS 
PPP=L_TERM 
PPP=L_REPLACE.BY.PNAME 
PPP*L_DIFFERENT.VARIABLES.FLAG 
PPP=L_PRINT.TO.RIGHT.END 
PPP=L_TERPRI 
PPP=L_TAB 
PPP=L_PAGE 
PPP=L_PRINT.TEXT 
PPP=L_PRINT.WORD 
PPP=L_PRINT.WITH.UNDERSCORE 
PPP=L_APPLY.SUBSTITUTION 
;;; Reading source file "prog/prot/prot-latex.lisp"
;;; While compiling PPP=L_PRINT.HEAD
;;; Warning: Variable VERSION is bound but not referenced
;;; Warning: Variable DATE is bound but not referenced
;;; Warning: Variable COMMENT is bound but not referenced
;;; While compiling PPP=L_PRINT.AXIOM.CLAUSES
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.SPLITTED.THEOREMS
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.OPERATIONS
;;; Warning: Free variable PPP=L_LONGEST.OPERATION.PREMISE assumed to be special
;;; Warning: Calling PPP=L_LONGEST.OPERATION.PREMISE with the wrong number of arguments
;;; While compiling PPP=L_PRINT.SPLITPART
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.OPERATION
;;; Warning: Variable CURRENT.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.CLAUSE
;;; Warning: Variable COLON.POS is bound but not referenced
;;; While compiling PPP=L_PRINT.WITH.UNDERSCORE
;;; Warning: Variable UNDERSCORE.SIGN is bound but not referenced
;;; Warning: Variable START.POS is bound but not referenced
;;; Writing binary file "prog/prot/prot-latex.sbin"
;;; Loading binary file "prog/prot/prot-latex.sbin"
;;; Loading source file "prog/prot/prot-prepare.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PPR-CODE 
PPR*NEW.PNAMES 
PPR*INITIAL.CLAUSE.NUMBER 
PPR*DEDUCED.CLAUSE.NUMBER 
PPR=RESET 
PPR=RESULT.HANDLING 
PPR=AXIOMS.GRAPH 
PPR=PROOF.PART 
PPR*OLD.NEW.CLAUSE.ADDRESSES 
PPR*OLD.NEW.CLAUSE.ADDRESSES.INITIAL 
PPR*AXIOMS.O.N.C.ADDRESSES 
PPR=SPLITPART 
PPR=PRECEDING.IDENTIFIER 
PPR=CHANGED.OPTIONS 
PPR=CONSTRUCT.DEDUCTION.TREE 
PPR=CONSTRUCT.LIST.OF.ANCESTORS 
PPR=MARK.USED.OPERATIONS 
PPR*SPLITTABLE.OPERATIONS 
PPR*LENGTH.OF.CLAUSE.CHANGED 
PPR=OPERATION 
PPR=OPERATION.DESCRIPTION 
PPR=RULE 
PPR*CLAUSE.CHANGED 
PPR*CLAUSE.SYMBOLS 
PPR=CHANGE.UNIFIER 
PPR=SPLIT.REPLACEMENT.OPERATION 
PPR*OLDLITS.NEWLITS 
PPR=BUILD.OLDLITS.NEWLITS 
PPR=RESOLUTION.OPERATION 
PPR=SIMULATE.RESOLUTION 
PPR=SIMULATE.INSTANTIATION 
PPR=UPDATE.OLD.NEW.LITS 
PPR=DOUBLE.LITERAL.OPERATIONS 
PPR=REM.DBL.LIT.EARLIER 
PPR=DOUBLE.LITERAL.OPERATION 
PPR=SIMULATE.DOUBLE.LITERALS 
PPR=ACTUAL.LITERAL 
PPR=ACTUAL.LITNO 
PPR=APPLY.SUBSTITUTION 
PPR=VARS.SORTS.USED 
PPR=IMPORTED.VARS.SORTS 
PPR=CLAUSES 
PPR=CLAUSE 
PPR=CLAUSE.PARENTS 
PPR=CLAUSE.SORTS.VARIABLES 
PPR=ALLOCATE.CLAUSE.PNAME 
PPR*DESTRUCTIVE.OPERATIONS 
PPR*INITIAL.CLAUSE.INDICATORS 
PPR=GET.CLAUSE.PNAME 
PPR=GET.CLAUSE.ADDRESS 
PPR=GET.CLAUSE.PARENTS 
PPR=GET.CLAUSE.VARIABLES.SORTS 
PPR=GET.CLAUSE.LITERALS 
PPR=GET.NEW.CLAUSE.ADDRESS 
PPR=PREPARE.PRINT.FORMAT 
;;; Reading source file "prog/prot/prot-prepare.lisp"
;;; Writing binary file "prog/prot/prot-prepare.sbin"
;;; Loading binary file "prog/prot/prot-prepare.sbin"
;;; Loading source file "prog/prot/prot-execute.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PRO-LIST.PROTOCOL 
PRO=VERSIONS 
PRO=RESET 
;;; Reading source file "prog/prot/prot-execute.lisp"
;;; Writing binary file "prog/prot/prot-execute.sbin"
;;; Loading binary file "prog/prot/prot-execute.sbin"
;;; Loading source file "prog/prot/post.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PO*RESCOUNTER 
PO*FACCOUNTER 
PO*PARACOUNTER 
PO*INSTCOUNTER 
PO*RENCOUNTER 
PO*INDICES 
PO*FILE 
PO*ALL.FORMULAS 
PO*INDENTATION 
PO*OPERATION.STACK 
PO=INIT.COUNTERS 
PO=PRINT.CONSTANTS 
PO=PRINT.PREDICATES 
PO=PRINT.FUNCTIONS 
PO-CONSTRUCT.START 
PO=MODIFY.QUANTOR 
PO-REARRANGE 
PO-MODIFY-PRED 
PO=TREAT.FORMULA 
PO-AXIOMS.START 
PO-AXIOMS.END 
PO-THEOREMS.START 
PO*ACT.NUM 
PO=GET.FORMULA.POSITION 
PO=GET.FORMULAS.POSITION 
PO=CONVERT.INDICES 
PO-THEOREMS.END 
PO-INITIAL.GRAPH 
PO-CONSTRUCT.END 
PO-SPLITPARTS.START 
PO=PRINT.MKRP.FORMULAS 
PO=PRINT.AXIOMS 
PO=PRINT.THEOREMS 
PO-PREFIX.FORM 
PO-REFUTATION.START 
PO=PCLAUSE 
PO-PARTIAL.GRAPH 
PO=PRINT.OP.HEADER 
PO=PRINT.OPERATION.FRAME 
PO-OPERATION 
PO=OPERATION 
PO=PROVER 
PO-REFUTATION.END 
PO-SPLITPARTS.END 
PO=OPTIONS 
PO-OPTIONS 
PO=PRINT.RESOLUTION 
PO=RESOLUTION 
PO=LINK.PARENTS 
PO=PRINT.PARENTS 
PO=PRINT.INSTANCE 
PO=PRINT.VARS 
PO=PRINT.SUBST 
PO=PRINT.LIT 
PO=PRINT.CLAUSE.FRAME 
PO=REPLACEMENT.RESOLUTION 
PO=FACTORIZATION 
PO=INSTANTIATE 
PO=LINK.FAC 
PO=PRINT.FAC.POSITION 
PO=R.CHAIN.FIRST.RES 
PO=R.CHAIN.REST.RES 
PO=R.CHAIN 
PO=GET.ALL.LITS 
PO=SIM.RESOLUTION 
PO=SIM.FACTORING 
PO=SEARCH.ACT.LITNO 
PO=REPL.CLAUSE 
PO=MERGE.UNIFIER 
PO=GENERATE.REN.REN 
PO=COMPOSITION.OF.SUBSTITUTIONS 
PO=COMPUTE.UNIFIER 
PO=REPL.OP.SUBST 
PO=REPL.OP.ONE.RES 
PO=REPL.OP.ONE.FAC 
PO=REPL.OP.IMPLICIT.MULTIPLE 
PO=REPLACEMENT.OPERATION 
PO=RESTRICT.RENAMING 
PO=VARIABLES.SORTS.OF.CODOMAIN 
PO=DOUBLE.LITERAL 
PO=COMPUTE.RW.MATCH 
PO=PRINT.POSITION 
PO=GENERATE.RENAMING 
PO=MERGE.RENAMING 
PO=CLAUSE.PNAME 
PO=CLAUSE.RENAMING 
PO=CLAUSE.PUTPNAME 
PO=CLAUSE.PUTRENAMING 
PO=PARAMODULATION 
PO=I.PARAMODULATION 
PO=E.PARAMODULATION 
PO=LINK.PAR 
PO=LINK.PAR.INST 
PO=REWRITE 
PO=REWRITE.SYMMETRY 
PO=CLAUSE 
PO=LINK.COLOURS 
PO-INFIX.FORM 
;;; Reading source file "prog/prot/post.lisp"
;;; While compiling PO=TREAT.FORMULA
;;; Warning: Free variable FOO assumed to be special
;;; Warning: Variable FOO is bound but not referenced
;;; While compiling PO=PRINT.MKRP.FORMULAS
;;; Warning: Calling PO=TREAT.FORMULA with the wrong number of arguments
;;; Writing binary file "prog/prot/post.sbin"
;;; Warning: The following function is not known to be defined:
;;;          PO-PART.CLAUSE was referenced by PO=PRINT.RESOLUTION
;;; Loading binary file "prog/prot/post.sbin"
;;; Loading source file "prog/prot/interface.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PR-CONSTRUCT.START 
PR-INFIX.FORM 
PR-PREFIX.FORM 
PR-OPTIONS 
PR-AXIOMS.START 
PR-AXIOMS.END 
PR-THEOREMS.START 
PR-THEOREMS.END 
PR-CONSTRUCT.END 
PR-SPLITPARTS.START 
PR-REFUTATION.START 
PR-PARTIAL.GRAPH 
PR-INITIAL.GRAPH 
PR-OPERATION 
PR-STATISTICS 
PR-REFUTATION.END 
PR-SPLITPARTS.END 
;;; Reading source file "prog/prot/interface.lisp"
;;; Writing binary file "prog/prot/interface.sbin"
;;; Loading binary file "prog/prot/interface.sbin"
;;; Loading source file "prog/prot/protocol.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PR*INDICES 
PR*FILE 
PR*INDENTATION 
PR=CONSTRUCT.START 
PR=INFIX.FORM 
PR=PREFIX.FORM 
PR=OPTIONS.TOP 
PR=AXIOMS.START 
PR=AXIOMS.END 
PR=THEOREMS.START 
PR=THEOREMS.END 
PR=CONSTRUCT.END 
PR=SPLITPARTS.START 
PR=REFUTATION.START 
PR=PARTIAL.GRAPH 
PR=INITIAL.GRAPH 
PR=OPERATION 
PR=REFUTATION.END 
PR=SPLITPARTS.END 
PR=AXIOMS.OR.THEOREMS.END 
PR=OPTIONS 
PR=SYMBOLS 
PR=RESOLUTION 
PR=R.CHAIN 
PR=LINK.RES 
PR=REPLACEMENT.RESOLUTION 
PR=PARAMODULATION 
PR=LINK.PAR 
PR=FACTORIZATION 
PR=INSTANTIATE 
PR=LINK.FAC 
PR=REPLACEMENT.OPERATION 
PR=VARIABLES.SORTS.OF.CODOMAIN 
PR=DOUBLE.LITERAL 
PR=REWRITE 
PR=REWRITE.SYMMETRY 
PR=CLAUSE 
PR=LINK.COLOURS 
;;; Reading source file "prog/prot/protocol.lisp"
;;; While compiling PR=R.CHAIN
;;; Warning: Variable LINK is bound but not referenced
;;; Writing binary file "prog/prot/protocol.sbin"
;;; Loading binary file "prog/prot/protocol.sbin"
;;; Loading source file "prog/op/op-service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP*LINK.COLOURS.LITERAL.INITIAL 
OP*CLAUSECOUNTER 
OP*COUNTER.RESOLVENTS 
OP*COUNTER.PARAMODULANTS 
OP*COUNTER.FACTORS 
OP*COUNTER.INSTANCES 
OP*COLOURS.CIRCLE.LINKS 
OP*UNIFIER.BUFFER 
OP*VARIABLE.BUFFER1 
OP*VARIABLE.BUFFER2 
OP=UNIFY 
OP=MATCH 
OP=WEAK.UNIFY 
OP=C.RPLACA 
OP=C.NIL.COMPONENTS 
OP=C.REMOVE.INSTANCES 
OP=ADMISSIBLE.RULE 
OP=PREDICATE.OCCURRENCES 
OP=COLOUR.IS.X 
OP=COLOUR.IS.XI 
OP=COLOUR.IS.XIW 
OP=C.RENAME 
OP=FIND.VARIABLES 
OP=SEARCH.VARIABLES 
OP=GENERATE.PASSIVE.POSITIONS 
OP=GENERATE.PASSIVE.POSITIONS.TERMLIST 
OP=GENERATE.PASSIVE.POSITIONS.TERM 
OP=INSERT.POSITIONS 
OP=TRANSMIT.LITERALS 
OP=PAR_TRANSMIT.LITERAL 
OP=RES_NEWNAME 
OP=PAR_NEWNAME 
OP=FAC_NEWNAME 
OP=INST_NEWNAME 
OP=RENAME 
OP=REMOVE.COMPONENTS 
OP=REMOVE.INSTANCES 
OP=DISJOINTIFY 
OP=PARALLEL.LINKS 
OP=PARALLEL.LINKS.1 
OP=COLOUR 
OP==COLOUR 
OP=REMOVE.PROPERTY 
;;; Reading source file "prog/op/op-service.lisp"
;;; Writing binary file "prog/op/op-service.sbin"
;;; Loading binary file "prog/op/op-service.sbin"
;;; Loading source file "prog/op/op-inherit.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP=INHERIT1 
OP=INHERIT.LINKS 
OP=INHERIT.R 
OP=INHERIT.S 
OP=INHERIT.T 
OP=INHERIT.X.TO.X 
OP=INHERIT.X.TO.X.XI.XIW 
OP=INHERIT.XIW.TO.X.XI.XIW 
OP=INHERIT.CIRCLE.LINKS 
OP=INHERIT.XI.TO.XI 
OP=INHERIT_POT.TRUE.AND.FALSE.LITNOS 
OP=INHERIT_ERPATHS 
OP=INHERIT_RELINKS 
;;; Reading source file "prog/op/op-inherit.lisp"
;;; Writing binary file "prog/op/op-inherit.sbin"
;;; Loading binary file "prog/op/op-inherit.sbin"
;;; Loading source file "prog/op/op-create.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP-CONSTRUCT.CLAUSES 
OP-CLAUSE.REWRITE.RULE.AC.EXTEND 
OP-CONSTRUCT.LITERAL.LINKS 
OP=POT.T.AND.F.LITNOS 
OP=CREATE.XLINKS 
OP=CREATE.XILINKS 
OP=CREATE.XIWLINKS 
OP=CREATE.XI.CIRCLE.LINKS 
OP=CREATE.XIW.CIRCLE.LINKS 
OP=CREATE.LINKS 
OP=CREATE_P.PD.AND.PIW.LINKS 
OP=PAR_CREATE.POT.TRUE.AND.FALSE.LITNO.FOR.PARAMOD.LIT 
;;; Reading source file "prog/op/op-create.lisp"
;;; Writing binary file "prog/op/op-create.sbin"
;;; Loading binary file "prog/op/op-create.sbin"
;;; Loading source file "prog/op/operation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OP-RESET 
OP-SAVE 
OP-#RESOLVENTS 
OP-#PARAMODULANTS 
OP-#FACTORS 
OP=REPLACE 
OP=RENAMINGS 
OP=CREATE.ELEMENT.LITERALS 
OP-RESOLVE 
OP=PARAMODULATE 
OP=PIW.PARAMODULATE 
OP-PARAMODULATE 
OP=FACTORIZE 
OP-FACTORIZE 
OP-CREATE.INSTANCE 
OP-CREATE.UNIT.FACTORS 
OP=TWO.CREATE.UNIT.FACTORS 
OP-R.CHAIN 
OP=RIW.RESOLVE 
OP-OPERATE 
OP=SUBSUMED.P.MAP.RULES 
OP=SUBSUMED.P.OCC 
OP=SUBSUMED.P 
OP-SUBSUMED.P 
OP*RULE.DUMMY 
OP=PAR_CONNECT 
OP=CONNECT.TO.PARENTS 
OP=INSERT.LINK 
OP=SI.COMPLETE.GROUPS 
OP=NEGATIVE.SIDES 
;;; Reading source file "prog/op/operation.lisp"
;;; Writing binary file "prog/op/operation.sbin"
;;; Loading binary file "prog/op/operation.sbin"
;;; Loading source file "prog/red/two.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
TWO*RULES.MAXLEVEL 
TWO*CONTROL 
TWO*SUPPRESS.NORULES 
TWO*DIALOG 
TWO*EXTERNAL.RULE.COLOURS 
TWO*INTERNAL.RULE.COLOURS 
TWO*RULES 
TWO*ADDED.RULES 
TWO*EMPTY.CLAUSE.FOUND 
TWO*NEW.RULES 
TWO*NORULE.CLAUSES 
TWO*TR.RULES 
TWO*TR.NORULES 
TWO-UPDATE.RULES 
TWO-RESET 
TWO-SAVE 
TWO=INIT 
TWO-END 
TWO=COMPLETE.RULES 
TWO=ADD.AND.LEVEL.SATURATE 
TWO=ADD.NEW.LEVEL 
TWO=RESOLVE.ALL 
TWO=SELECT.RULES 
TWO=S 
TWO=S.ADDED 
TWO=S.UNIONS 
TWO=S.ADDED.UNIONS 
TWO=MERGE 
TWO=FACTORIZE 
TWO=RESOLVE 
TWO=REDUCE 
TWO=GET.ADJACENT.CLAUSES.OF 
TWO=ADJACENT.LITERALS 
TWO=CONSTRUCT.LINKS 
TWO=UPDATE.GRAPH 
TWO=ADMISSIBLE.RULE.IS 
TWO=CLASSIFY.CLAUSE 
TWO=ADMISSIBLE.SIW.HAS 
TWO=NOT.PARTIAL.IS 
TWO=DIALOG 
TWO-LAST.CALL.NEW.RULES 
TWO-LAST.CALL.NEW.NORULES 
;;; Reading source file "prog/red/two.lisp"
;;; Writing binary file "prog/red/two.sbin"
;;; Loading binary file "prog/red/two.sbin"
;;; Loading source file "prog/red/red-service.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED.SERVICE-BINDING.RENAMES.VARIABLES 
RED.SERVICE-NIL.IN.UNIFIERS 
RED.SERVICE-SWITCHED.UNIFIERS 
RED.SERVICE-CLAUSE.LINKS 
RED.SERVICE==CLAUSE.LINKS 
RED.SERVICE-OTHERPAR.EXTERNAL 
RED.SERVICE-OTHERLITNO.EXTERNAL 
RED.SERVICE-OTHERLITNO.INTERNAL 
RED.SERVICE-LINK.NEGPAR 
RED.SERVICE-LINK.PARENTS 
RED.SERVICE-LINK.ORIENTED 
RED.SERVICE-TRUE.LITERAL.IS 
RED.SERVICE-FALSE.LITERAL.IS 
RED.SERVICE-TRUE.CLAUSE 
RED.SERVICE-FALSE.CLAUSE 
RED*SERVICE_RENAME.VARIABLES 
RED.SERVICE-RENAME.POINT 
RED.SERVICE-RENAME.DELETE 
RED.SERVICE-RENAME 
;;; Reading source file "prog/red/red-service.lisp"
;;; Writing binary file "prog/red/red-service.sbin"
;;; Loading binary file "prog/red/red-service.sbin"
;;; Loading source file "prog/red/red-datastructure.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RDS-RULES 
RDS==RULES 
RDS-LINK.COLOURS 
RDS==LINK.COLOURS 
RED*LINK.SUBSUMPTION.SUBJECT 
RED*LINK.SUBSUMPTION.OBJECT 
RED*LINK.TAUTOLOGY 
RED*LINK.INCOMPATIBILITY 
RED*CLAUSE.REWRITING 
RED*CLAUSE.REPL.RESOLUTION.SUBJECT 
RED*CLAUSE.REPL.RESOLUTION.OBJECT 
RED*CLAUSE.SUBSUMPTION.OBJECT 
RED*CLAUSE.SUBSUMPTION.SUBJECT 
RED*CLAUSE.REPL.FACTORING 
RED*CLAUSE.TAUTOLOGY 
RED*CLAUSE.PURITY 
RED*CLAUSE.MULTIPLE.LITERALS 
RDS==RULE 
RDS-RULE 
RDS==RULE.PUT 
RDS-RULE.PUT 
RED*RULES.SWITCHED.ON 
RDS-RULES.SWITCHED.ON 
RDS-RULES.SWITCHED.ON.PUT 
RED*BINDING.STACK 
RDS-BINDING.STACK.RESET 
RDS-BINDING.RESET 
RDS-BINDING.PUSH 
RDS-BINDING.POP 
RDS-BINDING.TOP 
RDS*BUFFERS 
RDS-BUFFER 
RDS*MARKS 
RDS*MARKS.ALL 
RDS-MARK 
RDS-MARK.PUT 
RDS-MARKS.CREATE 
RDS-MARKS.RESET 
RDS-MARKS.DESTROY 
RDS-AGENDA.INSERT.CLAUSE.GREATER 
RDS-AGENDA.INSERT.CLAUSE.LESS 
RDS-RW_RULE 
RDS*RW_VARIABLES 
RDS*RW_ASSIGN 
RDS=RW_GET.VAR 
RDS=RW_RESET.VAR 
RDS=RW_CONS.TERM 
RDS-RW_RULE.CREATE 
;;; Reading source file "prog/red/red-datastructure.lisp"
;;; Writing binary file "prog/red/red-datastructure.sbin"
;;; Loading binary file "prog/red/red-datastructure.sbin"
;;; Loading source file "prog/red/red-rw.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED*RW_RULES 
RED*RW_TAF 
RED*RW_RULES.COMPLETION 
RED*RW_RULES.UNFAILING 
RED=APPLY_CLAUSE.REWRITING.TO.CLAUSE 
RED=RW_ADD.COMPLETION.RULE 
RED=RW_REDUCE.CC 
RED=RW_ADD.COMPLETION.UNFAIL 
RED=RW_ADD.COMPLETION.TREE 
RED=RW_ADD.COMPLETION.SINGLE 
RED=RW_ADD.COMPLETION 
RED=RW_APPLY.TO.TERMLIST.INTERNAL 
RED=RW_APPLY.TO.TERMLIST 
RED=RW_CONTEXTUAL 
RED=REWRITE.LIT 
RED-REWRITE 
RED=RW_COMPLETION 
RED=RW_REPLACE 
RED=RW_FIND.MATCHES.IN.TERMLIST 
RED=RW_REWRITE.CLAUSE 
RED=RW_REWRITE.CONSTANT.IS 
RED=RW_REWRITE.FUNCTION.IS 
;;; Reading source file "prog/red/red-rw.lisp"
;;; Writing binary file "prog/red/red-rw.sbin"
;;; Warning: The following function is not known to be defined:
;;;          RED=RW_C.INSERT was referenced by
;;;             RED=RW_ADD.COMPLETION.TREE
;;; Loading binary file "prog/red/red-rw.sbin"
;;; Loading source file "prog/red/red-crr.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED=APPLY_CLAUSE.REPL.RESOLUTION.SUBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.REPL.RESOLUTION.SUBJECT.TO.LINK 
RED=APPLY_CLAUSE.REPL.RESOLUTION.OBJECT.TO.CLAUSE 
RED=CRR_ATTEMPT.TO.RESOLVE 
RED=CRR_TO.EXT.SUBSUMPTION.LINK 
RED=CRR_TO.INT.SUBSUMPTION.LINK 
RED=CRR_REMOVE.MARKED.LITS 
RED=CRR_COMPUTE.S.AND.R.LINKS 
RED=CRR_INSERT.ANCESTORS 
RED=CRR_FALSE.LITERALS 
RED=CRR_FALSE.STRUCTURE 
RED=CRR_FALSE.REMOVE 
RED=CRR_MARK.DOUBLE.LITERALS.INTERNAL 
RED=CRR_MARK.DOUBLE.LITERALS.EXTERNAL 
RED=CRR_MARK.FALSE.LITERALS 
RED=CRR_MARK.ALL.SUBJECT.LITERALS 
RED=CRR_MARK.OPERATING 
RED=CRR_MARK.OBJECT.LITERALS 
RED=CRR_MARK.UNIT.RESOLUTION 
RED=CRR_MARK.S.RESOLUTION 
RED=CRR_MARK.OBJECT.FACTORING 
RED=CRR_MARKED.NOT.REMOVED 
RED=CRR_GENERALIZING.CONDITION 
RED=CRR_GENERALIZING.TO.LITERALS 
RED=CRR_GENERALIZING.TO.UNIFIER 
RED=CRR_REPLACE.LITERAL 
RED=CRR_SIMPLE.CONDITION 
RED=CRR_EXISTS.PERMUTATION.OF.DOUBLE.LITERALS 
RED=CRR_PROTOCOL.RECONSTRUCT 
RED=CRR_PROTOCOL.DOUBLE.LITERAL.PATH 
;;; Reading source file "prog/red/red-crr.lisp"
;;; Writing binary file "prog/red/red-crr.sbin"
;;; Loading binary file "prog/red/red-crr.sbin"
;;; Loading source file "prog/red/narrow.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
NAR*TERM*ALIST 
NAR*CLAUSES 
NAR-NARROW 
NAR=INSERT.TREE.EQ 
NAR=CREATE.TREE.EQ 
NAR=INSERT.TREE 
NAR=CREATE.TREE 
NAR-NARROW.INFO 
NAR-NARROW.INFO.PUT 
NAR-PR.NARROW 
NAR=DERIV.LIST.EQ 
NAR=DERIV.LIST 
NAR=PR.OPERATION 
NAR=REWRITE 
N*NUMBER 
NAR=N.NAME 
NAR=TRANSLATE.TERM.TO 
NAR=MAKE.RULES 
NAR=TRANSLATE.RULE.TO 
NAR=TRANSLATE.CLAUSE.TO 
NAR=TRANSLATE.LIT.TO 
NAR=TRANSLATE.SUBST.FROM 
NAR=TRANSLATE.TERM.FROM 
NAR-RESET 
;;; Reading source file "prog/red/narrow.lisp"
;;; Writing binary file "prog/red/narrow.sbin"
;;; Warning: The following functions are not known to be defined:
;;;          NAR-SOLUTIONS was referenced by NAR=INSERT.TREE.EQ,
;;;             NAR=INSERT.TREE
;;;          NAR-CREATE-NARROW.PROBLEM was referenced by
;;;             NAR=CREATE.TREE.EQ, NAR=CREATE.TREE
;;;          NAR-NSTEP-REST.CLAUSE was referenced by NAR-PR.NARROW,
;;;             NAR=DERIV.LIST
;;;          NAR-NSTEP-DERIV was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=PR.OPERATION
;;;          DS-DERIV-FATHER was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=PR.OPERATION
;;;          DS-DERIV-MOTHER was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          NAR-NSTEP-SIGMA was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=PR.OPERATION
;;;          DS-DERIV-REDUCTION-LIST was referenced by
;;;             NAR=DERIV.LIST.EQ, NAR=DERIV.LIST
;;;          DS-DERIV-POSITION was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          DS-TERM-SUBTERMS was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST, NAR=REWRITE, NAR=TRANSLATE.TERM.FROM
;;;          NAR-NSTEP-EQ was referenced by NAR=DERIV.LIST.EQ,
;;;             NAR=DERIV.LIST
;;;          DS-CLAUSE-LITERALS was referenced by NAR=DERIV.LIST
;;;          DS-TERM-EQ-SYMBOL was referenced by NAR=TRANSLATE.TERM.TO,
;;;             NAR=TRANSLATE.LIT.TO
;;;          DS-MAKE-TERM was referenced by NAR=TRANSLATE.TERM.TO,
;;;             NAR=TRANSLATE.LIT.TO
;;;          DS-MAKE-VARIABLE was referenced by NAR=TRANSLATE.TERM.TO
;;;          DS-RULES-INIT was referenced by NAR=MAKE.RULES
;;;          DS-RULES-EXTEND was referenced by NAR=MAKE.RULES
;;;          DS-MAKE-RULE was referenced by NAR=TRANSLATE.RULE.TO
;;;          DS-MAKE-CLAUSE was referenced by NAR=TRANSLATE.CLAUSE.TO
;;;          DS-TRUE was referenced by NAR=TRANSLATE.LIT.TO
;;;          DS-FALSE was referenced by NAR=TRANSLATE.LIT.TO
;;;          OUT-FORMAT was referenced by NAR=TRANSLATE.LIT.TO
;;;          DS-TERM-SYMBOL was referenced by NAR=TRANSLATE.TERM.FROM
;;;          DS-VARIABLEP was referenced by NAR=TRANSLATE.TERM.FROM
;;; Loading binary file "prog/red/narrow.sbin"
;;; Loading source file "prog/red/red-linkcondition.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED.LC-CLAUSE.TAUTOLOGY 
RED.LC-LINK.TAUTOLOGY 
RED.LC=TAUT_MARK.OTHERS 
RED.LC=TAUT_MARK.RESET 
RED.LC=TAUT_MARK.INTERSECTION 
RED.LC=TAUT_INSTANCE 
RED.LC=TAUT_INSTANCE.C.C.C 
RED.LC=TAUT_INSTANCE.C.C.C.RENAME 
RED.LC=TAUT_INSTANCE.CIW.C.C 
RED.LC=TAUT_INSTANCE.CIW.C.CIW 
RED.LC=TAUT_INSTANCE.C.CIW.C 
RED.LC=TAUT_INSTANCE.CIW.CIW.C 
RED.LC=TAUT_INSTANCE.CIW.CIW.CIW 
RED.LC=TAUT_INSTANCE.TEST 
RED.LC=TAUT_UNIFIERS.RENAME 
RED.LC=TAUT_UNIFIERS.RENAME.SWITCH 
RED.LC=TAUT_UNIFIERS.STANDARD 
RED.LC=TAUT_UNIFIERS.SWITCH 
RED.LC=TAUT_VARIABLES 
RED.LC-CLAUSE.SUBSUMPTION 
RED.LC-LINK.SUBSUMPTION 
RED.LC=SUBS_INTERNAL 
RED.LC=SUBS_INTERNAL.MARK.OTHERS 
RED.LC=SUBS_INTERNAL.MARK.INTERSECTION 
RED.LC=SUBS_INTERNAL.LINK.BLOCKS 
RED.LC=SUBS_INTERNAL.INSTANCE 
RED.LC=SUBS_INTERNAL.INSTANCE.CI.CI.OR.C 
RED.LC=SUBS_INTERNAL.INSTANCE.CIW.CIW 
RED.LC=SUBS_INTERNAL.INSTANCE.CIW.C 
RED.LC=SUBS_EXTERNAL 
RED.LC=SUBS_EXTERNAL.MARK.OTHERS 
RED.LC=SUBS_EXTERNAL.MARK.INTERSECTION 
RED.LC=SUBS_EXTERNAL.LINK.BLOCKS 
RED.LC=SUBS_EXTERNAL.INSTANCE 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.C 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.C.RENAME 
RED.LC=SUBS_EXTERNAL.INSTANCE.CIW.C 
RED.LC=SUBS_EXTERNAL.INSTANCE.C.CIW 
RED.LC=SUBS_EXTERNAL.INSTANCE.CI.C 
RED.LC=SUBS_INSTANCE.TEST 
RED.LC=SUBS_UNIFIERS.STANDARD 
RED.LC=SUBS_UNIFIERS.SWITCH 
RED.LC=SUBS_UNIFIERS.RENAME 
RED.LC=SUBS_UNIFIERS.RENAME.BINDING 
;;; Reading source file "prog/red/red-linkcondition.lisp"
;;; Writing binary file "prog/red/red-linkcondition.sbin"
;;; Loading binary file "prog/red/red-linkcondition.sbin"
;;; Loading source file "prog/red/reduction.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
RED*FORWARD 
RED*GRAPH.ISOLATION 
RED-REDUCE.DEDUCED.GRAPH.PARTIAL 
RED-REDUCE.DEDUCED.GRAPH 
RED=LINKS 
RED-REDUCE.GRAPH 
RED-REDUCE.INITIAL.GRAPH.PARTIAL 
RED-REDUCE.RESORTED.GRAPH 
RED-REDUCE.INITIAL.GRAPH 
RED-REDUCE.RULE.GRAPH 
RED-CLAUSE.SUBSUMPTION 
RED-REMOVE.CLAUSE 
RED-CLAUSE.TAUTOLOGY.IS 
RED-RESET 
RED-SAVE 
RED-SAVE.RESET 
RED-END 
RED=RESET 
RED=RESET_PUT 
RED=RESET_OPTIONS 
RED*AGENDA 
RED*TEST 
RED*CHECK 
RED=CTL_REDUCE 
RED=CTL_APPLY.RULES 
RED*STATE 
RED=CTL_INIT 
RED=CTL_AGENDA.INSERT.CLAUSE 
RED=CTL_AGENDA.INSERT.LINK 
RED=CTL_AGENDA.INSERT.RECHECK 
RED=CTL_AGENDA.POP.RULE.AND.CLAUSE 
RED=CTL_AGENDA.POP.RULE.AND.LINK 
RED=CTL_AGENDA.POP.RULE.AND.RECHECK 
RED=CTL_AGENDA.UPDATE 
RED=CTL_AGENDAS.INSERT.LINKS 
RED=CTL_APPLY.RULE.TO.RECHECK 
RED=CTL_APPLY.RULE.TO.CLAUSE 
RED=CTL_APPLY.RULE.TO.LINK 
RED=CTL_REMOVE.CLAUSE 
RED=CTL_REMOVE.LITERAL 
RED=CTL_RECONSTRUCT 
RED=CTL_REPLACE.LITERAL 
RED=CTL_REMOVE.LINK 
RED=CTL_REMOVE.UNIFIER 
RED=CTL_UPDATE.RECHECK.INFO 
RED=INFO_REC.P.LINK.LITERALS 
RED=INFO_REC.P.LINK.LIST 
RED-INFO_P.LINK.RULES 
RED-INFO_P.LINK.UNFAIL.RULES 
RED=INFO_RENAME.RULE 
RED*INFO_LINKS.CHANGED 
RED=INFO_LIT.DELETE 
RED=INFO_LIT.UNIFY 
RED=INFO_LIT.DELETE1 
RED=INFO_LINK.RESULT.REPLACE 
RED=INFO_LINK.RESULT.PUT 
RED=INFO_REMOVE 
RED=INFO_INSERT.RESULT 
RED=INFO_UPDATE 
RED=INFO_REDUCE.CC 
RED=APPLY_GRAPH.ISOLATION.TO.GRAPH 
RED=GI_MARK.OBTAINABLE.CLAUSES 
RED=APPLY_CLAUSE.MULTIPLE.LITERALS.TO.CLAUSE 
RED=APPLY_CLAUSE.MULTIPLE.LITERALS.TO.LINK 
RED=CML_TO.DETECTION.LINK 
RED=APPLY_CLAUSE.PURITY.TO.CLAUSE 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.CLAUSE 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.LINK 
RED=APPLY_CLAUSE.TAUTOLOGY.TO.RECHECK 
RED=CT_ATTEMPT.TO.REMOVE 
RED=CT_CANDIDATE.LINKS 
RED=CT_UPDATE.RECHECK.INFO 
RED=APPLY_CLAUSE.REPL.FACTORING.TO.CLAUSE 
RED=APPLY_CLAUSE.REPL.FACTORING.TO.LINK 
RED=CRF_TO.UNIFIER 
RED=CRF_TO.CLAUSE 
RED=CRF_ATTEMPT.TO.FACTORIZE 
RED=CRF_INSERT.ANCESTORS 
RED=CRF_PROTOCOL.RECONSTRUCT 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.SUBSUMPTION.OBJECT.TO.CLAUSE 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.LINK 
RED=APPLY_CLAUSE.SUBSUMPTION.SUBJECT.TO.RECHECK 
RED=CS_TO.SUBSUMPTION.LINK 
RED=CS_TO.LINK.CONDITION.LINK 
RED=CS_ATTEMPT.TO.SUBSUME 
RED=CS_SUBSUME.TRUE.LITERAL 
RED=CS_INSERT.ANCESTORS 
RED=CS_UPDATE.RECHECK.INFO 
RED=CS_CANDIDATES.TO.BE.SUBSUMING 
RED=CS_CANDIDATES.TO.BE.SUBSUMED 
RED=CS_RELATION.MATCH 
RED=CS_RELATION.INJECTIVE 
RED=APPLY_LINK.INCOMPATIBILITY.TO.LINK 
RED=APPLY_LINK.INCOMPATIBILITY.TO.CLAUSE 
RED=LI_PARTITION.LITERALS 
RED=LI_TO.OP.LINK 
RED=LI_TO.INSERTED.LINK 
RED=LI_COMPATIBLE.LITERAL 
RED=LI_UNI.CHANGE 
RED=LI_MERGE 
RED=APPLY_LINK.TAUTOLOGY.TO.LINK 
RED=APPLY_LINK.TAUTOLOGY.TO.CLAUSE 
RED=APPLY_LINK.TAUTOLOGY.TO.RECHECK 
RED=LT_TO.OP.LINK 
RED=LT_RECHECK.INSERT.CONDITION.LINK 
RED=LT_RECHECK.INSERT.DETECTION.LINK 
RED=LT_ATTEMPT.TO.REMOVE 
RED=LT_CANDIDATE.LINKS 
RED=LT_UPDATE.RECHECK.INFO 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.CLAUSE 
RED=APPLY_LINK.SUBSUMPTION.OBJECT.TO.CLAUSE 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.LINK 
RED=APPLY_LINK.SUBSUMPTION.OBJECT.TO.LINK 
RED=APPLY_LINK.SUBSUMPTION.SUBJECT.TO.RECHECK 
RED=LS_ATTEMPT.TO.SUBSUME 
RED=LS_P.LINK.NEW 
RED=LS_SUBSUME.P.LINK 
RED=LS_ALL.INSTANCES.TRUE 
RED=LS_TO.EXT.LINK 
RED=LS_TO.INT.LINK 
RED=LS_TO.SUBSUMPTION.LINK 
RED=LS_RECHECK.INSERT.CONDITION.LINK 
RED=LS_UPDATE.RECHECK.INFO 
RED=LS_SUBSUME.TRUE.LITERAL 
RED=LS_OWN.PARENT.TO.CLAUSE 
RED=LS_OWN.PARENT.TO.LITERAL 
RED=LS_OWN.PARENT.TO.SUBSUMER.SUBSUMENT 
RED=LS_OWN.PARENT.TO.LINK 
RED=LS_OWN.PARENT.TO.UNIFIER 
RED=LS_CANDIDATES.TO.BE.SUBSUMING 
RED=LS_CANDIDATES.TO.BE.SUBSUMED 
RED=LS_CANDIDATES.TO.BE.SUBSUMED.SPEC.PARENT 
RED=LS_CANDIDATES.INSERT.RELATION 
RED=LS_RELATION.EXECUTE 
RED=LS_RELATION.INJECTIVE 
RED=LS_RELATION.MARK 
RED=LS_RELATION.S.LINK 
RED=LS_RELATION.CHECK 
RED=LS_RELATION.MATCH 
;;; Reading source file "prog/red/reduction.lisp"
;;; GC: 365230 words [1460920 bytes] of dynamic storage in use.
;;; 306512 words [1226048 bytes] of free storage available before a GC.
;;; 978254 words [3913016 bytes] of free storage available if GC is disabled.
;;; Writing binary file "prog/red/reduction.sbin"
;;; Loading binary file "prog/red/reduction.sbin"
;;; Loading source file "prog/op/construct.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CONS*CLAUSES 
CONS*CLAUSECOUNTER 
CONS*LINK.COLOURS 
CONS*EQ.OCCURRENCES.NEG 
CONS*EQ.OCCURRENCES.POS 
CONS*RW.CLAUSES 
CONS*RW_EQ.OCCURRENCES.NEG 
CONS*RW_EQ.OCCURRENCES.POS 
CONS*NO.LINK.CLAUSES 
CONS=SORT 
CONS-CONSTRUCT.ATTRIBUTE.CLAUSES 
CONS-CONSTRUCT.LINKS 
CONS-RESET 
CONS-VIRTUAL.GRAPH 
CONS-RECONSTRUCT.LINKS 
CONS=CONSTRUCT.LINKS 
CONS-CONSTRUCT.PLINKS 
CONS=CREATE.PLINKS 
CONS=PLINKS.TO.LITERAL 
CONS=PLINKS.TO.TERM 
CONS=PLINKS.TO.TOPLEVEL.OF.TERM 
CONS=PLINKS.BETWEEN.TERM.AND.EQUALITY 
CONS=PIW.COMPLETION.TERM 
CONS=PIW.COMPLETION.FCT 
CONS=PIW.COMPLETION 
CONS=PLINKS.TO.SAME.TERM 
CONS=PLINK.INSERT 
CONS=RW_CONSTRUCT.LINKS 
CONS=RECREATE.PLINKS 
CONS=RW_PLINKS.TO.SAME.TERM 
CONS=EQ.OCCURRENCES 
CONS=PREDICATE.OCCURRENCES 
CONS=PRED.OCCURRENCES.IN.CLAUSES 
CONS=EQ.OCCURRENCES.IN.CLAUSES 
CONS=EXISTING.GRAPH.CLAUSES 
;;; Reading source file "prog/op/construct.lisp"
;;; Writing binary file "prog/op/construct.sbin"
;;; Loading binary file "prog/op/construct.sbin"
;;; Loading source file "prog/ctl/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP-INITIAL.GRAPH 
PREP-PROBLEM.SPECIFICATION 
PREP-INIT 
PREP-END 
PREP-OPEN.PROTOCOL 
PREP-CLOSE.PROTOCOL 
PREP-VIRTUAL.PARTIAL.GRAPH 
PREP-VIRTUAL.INITIAL.GRAPH 
PREP-CREATE.EMPTY.GRAPH 
PREP-EXTEND.GRAPH 
PREP-REDUCE.INITIAL 
PREP-SUBSUMPTION.TEST 
PREP=INIT 
PREP=END 
PREP=READ.PROBLEM.FILE 
PREP=CREATE.AXIOMGRAPH 
PREP=CREATE.INITIAL.GRAPHS 
PREP=ADD.THEOREM 
PREP=CREATE.SPLITGRAPHS 
PREP=REDUCE.INITIAL 
PREP=GET.INSERTED 
PREP=ADD.CLAUSE 
PREP=CREATE.UNIT.FACTORS 
PREP=REDUCE.PARTIAL 
PREP=THEOREMS.CLAUSE.LISTS 
PREP=NEGATION.OF.CONJUNCTION 
PREP=REMOVE.COMMENTS 
PREP=ELIMINATE.EQUALITY 
PREP=PREDICATE.OCCURS.IN 
PREP=CREATE.EMPTY.GRAPH 
PREP=CREATE.EMPTY.PARTIAL.GRAPH 
PREP=VIRTUAL.PARTIAL.GRAPH 
PREP=VIRTUAL.INITIAL.GRAPH 
PREP=CREATE.CLAUSES 
PREP=PR_OPEN 
PREP=PR_CLOSE 
PREP=PR_INFIX.FORM 
PREP=PR_PREFIX.FORM 
PREP=PR_OPTIONS 
PREP=PR_AXIOMS.START 
PREP=PR_AXIOMS.END 
PREP=PR_THEOREMS.START 
PREP=PR_THEOREMS.END 
PREP=PR_PREPROCESSED.PREFIX.FORMULA 
PREP=PR_PARTIAL.GRAPH 
PREP=PR_INITIAL.GRAPH 
PREP=PR_CHANGES 
PREP=PR_GRAPH.DUMP 
PREP=PR_STATISTICS 
PREP=PR_PRINT.MESSAGE 
PREP=PR_PRINT.MESSAGE.FULL.LINE 
PREP=PR_PRETTY.LIST.EXPRESSION 
PREP=PR_PRETTY.EXPRESSION 
PREP=PR_PREFIX.EXPRESSION 
PREP*AXIOM.GRAPH.FILE 
PREP*AXIOM.GRAPH.FILE.## 
PREP*PROBLEM.FILE 
PREP*GRAPH.FILE 
PREP*SEVERAL.SPLITPARTS 
PREP*STEPNUMBER 
PREP*NUMBER.OF.AXIOM.CLAUSES 
PREP*AXIOMS.INFIX 
PREP*AXIOMS.PREFIX 
PREP*THEOREMS.INFIX 
PREP*THEOREMS.PREFIX 
PREP*COMMENT 
PREP*TRACE.OUTPUTSTREAM 
PREP*TRACE.OUTPUTSTREAM.LINELENGTH 
;;; Reading source file "prog/ctl/preparation.lisp"
;;; While compiling PREP-SUBSUMPTION.TEST
;;; Warning: DS-CLAUSE.IS is a macro; (FUNCTION DS-CLAUSE.IS) is probably incorrect
;;; Writing binary file "prog/ctl/preparation.sbin"
;;; Warning: The following function is not known to be defined:
;;;          TWO-DUMP was referenced by PREP=PR_GRAPH.DUMP
;;; Loading binary file "prog/ctl/preparation.sbin"
;;; Loading source file "prog/c/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP.C-INITIAL.GRAPH 
PREP.C=INIT 
PREP.C=END 
PREP.C=CREATE.AXIOMGRAPH 
PREP.C=CREATE.INITIAL.GRAPHS 
PREP*SPS 
PREP.C=PRINT.SPLITPARTS.OBJECTS 
PREP.C=PRINT.SPLITPARTS 
PREP.C=CREATE.SPLITGRAPHS 
PREP.C=PRINT.CLAUSELIST 
PREP.C=PRINT.LITLIST 
PREP.C=PRINT.CLAUSE 
PREP.C=PRINT.TERMLIST 
PREP.C=PRINT.TERM 
PREP.C=PRINT.CLAUSE.OBJECTS 
PREP.C=PRINT.TERM.OBJECTS 
PREP.C=PRINT.FUN.LIST 
;;; Reading source file "prog/c/preparation.lisp"
;;; While compiling PREP.C=INIT
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; While compiling PREP.C=CREATE.SPLITGRAPHS
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; While compiling PREP.C=PRINT.TERM.OBJECTS
;;; Warning: Free variable PREP*FUNS assumed to be special
;;; Writing binary file "prog/c/preparation.sbin"
;;; Loading binary file "prog/c/preparation.sbin"
;;; Loading source file "prog/e/preparation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
PREP*OBJECTS 
PREP.ER-INITIAL.GRAPH 
PREP.ER=INIT 
PREP.ER=END 
PREP.ER=CREATE.AXIOMGRAPH 
PREP.ER=CREATE.INITIAL.GRAPHS 
PREP.ER=CREATE.SPLITGRAPHS 
PREP.ER=PRINT.CLAUSE 
PREP.ER=PRINT.TERM 
;;; Reading source file "prog/e/preparation.lisp"
;;; Writing binary file "prog/e/preparation.sbin"
;;; Loading binary file "prog/e/preparation.sbin"
;;; Loading source file "prog/term/mergeinst.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
MI*INFORMATION 
MI*FULL.UNIFICATION 
MI-CREATE.EMPTY.TERMSTRUCTURE 
MI-INSERT.TERMLIST.INTO.TERMSTRUCTURE 
MI-INSERT.SUBSTITUTION.INTO.TERMSTRUCTURE 
MI-MERGE.TERMSTRUCTURES 
MI=TERMLIST.IS.NOT.TOO.DEEP 
MI-MERGE 
MI-TERMLIST.INSTANCE 
MI-SUBSTITUTION.INSTANCE 
MI-TERMLIST.STANDARD 
MI-TERMLIST.STANDARD.FULL 
MI-TERMLIST.PROPERTY 
MI-TERMLIST.AUXILIARY 
MI-TERMLIST.PUT.AUXILIARY 
MI-TERMSTRUCTURE.TERMLISTS 
MI=TERMSTRUCTURE_INSERT.TERMLIST.1 
MI=TERMSTRUCTURE_INSERT.TERMLIST.2 
MI=SUBTERMSTRUCTURE_INSERT.TERM 
MI=SUBTERMSTRUCTURE_INSTANCETEST 
MI=OCCURRENCE.TREE 
MI*DUMMY.BUFFER 
MI=TERMS.ARE.RENAMED 
MI=RENAMING.FAILURE 
MI=SUBTERMSTRUCTURE_CREATE.TLINKS 
MI=FUNCTIONLIST_RESET.AUXILIARY 
MI=TYPE 
MI=UNIFIER.IS.VARIABLE.RENAMING 
MI=SUBSTITUTION.TO.TERMLIST 
MI-DUMP 
MI=DUMP.SUBTERMSTRUCTURE 
MI=INTERSECT.POSITIONLISTS 
MI=CUT.TARGETPATTERN 
MI=INSTANCE.TEST 
MI=MERGE.DISJOINT.TERMSTRUCTURES 
MI=MERGE.DISJOINT 
MI=TERMLIST.VARIABLES 
MI=CREATE.TLINKS 
MI=MERGE.CLEAR.AUXILIARY 
MI=SUBSET 
MI=INTERSECT 
MI=TERMSTRUCTURE_INITIALIZE 
MI=TERMSTRUCTURE_ADD.EXPRESSION 
MI=TERMSTRUCTURE_POSITIONLIST 
MI=TERMSTRUCTURE_PATTERN 
MI=TERMSTRUCTURE_EXPRESSIONS 
MI=TERMSTRUCTURE_PATTERN.LENGTH 
MI=TERMSTRUCTURE_T.LENGTH 
MI=TERMSTRUCTURE_VARIABLE.PATTERN 
MI=TERMSTRUCTURE_ARITY 
MI=SINGLETERMS_INITIALIZE 
MI=SINGLETERMS_CONSTANTS 
MI=SINGLETERMS_VARIABLES 
MI=SINGLETERMS_ABBREVIATIONS 
MI=SINGLETERMS_THEORYTERMS 
MI=SINGLETERMS_COMPOSEDTERMS 
MI=SINGLETERMS_ADD.EXPRESSION 
MI=SUBTERMSTRUCTURE_CREATE.EMPTY.FUNCTIONLIST 
MI=SUBTERMSTRUCTURE_ADD.FUNCTIONLIST 
MI=SUBTERMSTRUCTURE_ADD.EXPRESSION 
MI=SUBTERMSTRUCTURE_EXPRESSIONS 
MI=SUBTERMSTRUCTURE_FUNCTIONLIST 
MI=EXPRESSION_INITIALIZE 
MI=EXPRESSION_PROPERTY 
MI=EXPRESSION_PUT.PROPERTY 
MI=EXPRESSION_FUNCTION 
MI=EXPRESSION_STANDARDTERM 
MI=EXPRESSION_AUXILIARY 
MI=EXPRESSION_PUT.AUXILIARY 
MI=EXPRESSION_INCREMENT.AUXILIARY 
MI=EXPRESSION_RESET.AUXILIARY 
MI=EXPRESSION_INSERT.TLINK 
MI=EXPRESSION_TLINKS 
MI=EXPRESSION_SUBTERMS 
MI=EXPRESSION_PUT.SUBTERMS 
MI=EXPRESSION_SUPERTERMS 
MI=EXPRESSION_ADD.SUPERTERM 
MI=EXPRESSION_INCREMENT.SUPERTERMS 
MI=EXPRESSION_CREATE.EMPTY.SINGLETERMS 
;;; Reading source file "prog/term/mergeinst.lisp"
;;; While compiling MI=TERMSTRUCTURE_INITIALIZE
;;; Warning: Variable ELEMENT is bound but not referenced
;;; Writing binary file "prog/term/mergeinst.sbin"
;;; Loading binary file "prog/term/mergeinst.sbin"
;;; Loading source file "prog/term/terminator.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
TERM-TERMINATOR 
TERM-1_TERMINATOR 
TERM-2_TERMINATOR 
TERM-3_TERMINATOR 
TERM-DUMP 
TERM=CLEAR 
TERM=INITIALIZATION 
TERM=TOPOLOGICALLY.RELEVANT.CLAUSES 
TERM=CREATE.INITIAL.UNITS 
TERM=TRIVIAL.PROOF 
TERM=CREATE.MARKS 
TERM=SORT.NOTUNITCLAUSES 
TERM=SORT 
TERM=CREATE.PATTERNS 
TERM=UNINODES.FROM.SILINKS 
TERM=ITERATIONS 
TERM=CREATE.UNITS 
TERM=CREATE.NEW.HINTS 
TERM=SET.UNINODE 
TERM=EXAMINE.CLAUSE 
TERM=DEDUCE.UNITS 
TERM=COMPATIBILITY.TEST.FULL 
TERM=CREATE.INITIAL.TULISTS 
TERM=PREPARE.CLAUSE 
TERM=MERGE.LIST.OF.TULISTS 
TERM=NOT.OLD.WITH.OLD 
TERM=TARGETPATTERN 
TERM=QUOTIENT 
TERM=GET.TULISTS 
TERM=SORT.TULISTS 
TERM=SORT.EXPAND 
TERM=SORT.REPLACE 
TERM=CUT.TULISTS 
TERM=LINEARIZE.UNITS 
TERM=LINEARIZATION 
TERM=LINEARIZATION.LITNO 
TERM=SUBSET.NODES 
TERM=BIND 
TERM=UNBIND 
TERM=MERGE 
TERM=CYCLE 
TERM=CREATE.INITIAL.TRUNIFIERS 
TERM=TRACE.UNIFIER.UNINODES 
TERM=UNIFIER.NORMALIZE 
TERM=IS.TAUTOLOGY 
TERM=1_ITERATIONS 
TERM=1_EXAMINE.CLAUSE 
TERM=1_CREATE.SLTU 
TERM=1_LINEARIZE 
TERM=1_COMPATIBILITY.TEST.PARTIAL 
TERM=2_ITERATIONS 
TERM=3_INITIALIZATION 
TERM=3_CREATE.INITIAL.UNITS 
TERM=3_CREATE.MARKS 
TERM=3_ITERATIONS 
TERM=GENERATOR.LITERALS 
TERM=NESTING.COUNTER 
TERM=UNIT.ADD.NEW.PREDICATELIST 
TERM=UNIT.PREDICATELIST.SIGNLIST 
TERM=UNIT.PREDICATELIST.TRANSFORMATIONS 
TERM=UNIT.CREATE.PARTIAL 
TERM=UNIT.MAKE.TERMLIST 
TERM=UNIT.SET.AUXILIARY 
TERM=UNIT.AUXILIARY 
TERM=UNIT.UNIFIER 
TERM=UNIT.CLAUSE 
TERM=UNIT.NODES 
TERM=UNIT.COUNTER 
TERM=UNIT.SET.COUNTER 
TERM=UNIT.DELETE.NODES 
TERM=CREATE.PSEUDOUNIT 
TERM=HINT.CREATE 
TERM=HINT.UNITS 
TERM=HINT.LINK 
TERM=HINT.IS.ACTIVE 
TERM=HINT.ACTIVATE 
TERM=UNINODE.CREATE 
TERM=UNINODE.UNIFIER 
TERM=UNINODE.LINK 
TERM=UNINODE.UNIT 
TERM=UNINODE.PUT.UNIT 
TERM=UNINODE.IS.NEW 
TERM=UNINODE.MARK.OLD 
TERM=TULIST.CREATE 
TERM=TULIST.LITNOS 
TERM=TULIST.TRACE.UNIFIERS 
TERM=TULIST.IS 
TERM=SLTU.LINK.SUBSTITUTION 
TERM=SLTU.TUNIFIER 
TERM=SLTU.UNINODES 
TERM=SLTU.PUT.TUNIFIER 
TERM=SLTU.PUT.UNINODES 
TERM=STANDARD.UNIFIER 
TERM=APPLY.UNIFIER 
TERM=CLAUSE.LIT.ADDPROP 
TERM=NORMALIZE.SIGN 
TERM=NORMALIZE.PREDICATE 
TERM=NORMALIZE.UNIT 
TERM=NO.NORMALIZING.UNITS 
TERM*UNITS 
TERM*SOLUTION 
TERM*NEW.VARIABLES 
TERM*NOTUNITCLAUSES 
TERM*UNITCOUNTER 
TERM*UNITCOUNTER.PARTIAL 
TERM*UNITCOUNTER.TOTAL 
TERM*UNIFIERCOUNTER.PARTIAL 
TERM*UNIFIERCOUNTER.TOTAL 
TERM*FILE 
TERM*TERMINAL 
TERM*PRINT.UNITS 
TERM*INSTANCETEST 
TERM*GENERATOR.LIMIT 
TERM*NORMALIZING.LITERALS 
TERM*3_PSEUDOCONSTANTS 
TERM*3_VARIABLES.REGARDED.AS.CONSTANTS 
TERM*3_RENAMING 
IND.SIMPL.UNIT 
DIRECT.SIMPL 
IND.SIMPL 
TERM*SIMPLIFICATION 
TERM=SIMPLIFY.UNIT 
TERM=ACCESS.FCT 
TERM=EXTRACT.ACCESS.FCT 
TERM=RECOGNIZE.SIMPLIFIER 
TERM=INDIRECT.SIMPLIFIER.UNIT 
TERM=DIRECT.SIMPLIFY.TERM 
TERM=DIRECT.SIMPLIFY.UNIT 
TERM=INDIRECT.SIMPLIFY.UNIT 
TERM=SIMP.UNIT.IS.NOT.SUBSUMED 
TERM=RENAME 
TERM=TEST.UNIT 
TERM*SIMPLIFICATION.PRINT 
TERM*SIMPLIFICATION.STREAM 
TERM=SIMPLIFICATION.PRINT 
;;; Reading source file "prog/term/terminator.lisp"
;;; While compiling TERM=TOPOLOGICALLY.RELEVANT.CLAUSES
;;; Warning: Variable X is bound but not referenced
;;; While compiling TERM=1_LINEARIZE
;;; Warning: TERM=SLTU.TUNIFIER is a macro; (FUNCTION TERM=SLTU.TUNIFIER) is probably incorrect
;;; While compiling TERM=1_COMPATIBILITY.TEST.PARTIAL
;;; Warning: TERM=SLTU.TUNIFIER is a macro; (FUNCTION TERM=SLTU.TUNIFIER) is probably incorrect
;;; While compiling TERM=NORMALIZE.UNIT
;;; Warning: Variable X is bound but not referenced
;;; Writing binary file "prog/term/terminator.sbin"
;;; Loading binary file "prog/term/terminator.sbin"
;;; Loading source file "prog/sel/selection.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=MANUAL 
SEL=FACTORIZE 
SEL=REDUCTIONS 
SEL=ELIMINATE 
SEL=MERGING 
SEL=INDUCTION 
SEL=TERMINATOR 
SEL=TERMINATOR.UNITS 
SEL=STRATEGIES 
SEL=CHAIN 
SEL*OPERATION.STACK 
SEL*ACTUAL.OPERATION 
SEL*REDUCE.DEDUCE 
SEL*INITIAL.FLAG 
SEL*FINAL.ACTIONS 
SEL*OPERATIONS 
SEL*LINK.CLASSES 
SEL*CLAUSE.CLASSES 
SEL*CLAUSELISTS 
SEL*LINKLISTS 
SEL*TERMINATOR.NEW.CLAUSES 
SEL*REDUCTION.FLAG 
SEL-INITIALIZE 
SEL-END 
SEL-UPDATE.REDUCE 
SEL-UPDATE.DEDUCE 
SEL-MARKED.CLAUSES 
SEL-DEDUCTION.CODE.LINK 
SEL-DEDUCTION.CODE.UNIFIER 
SEL-REDUCTION.CODE.CLAUSES.TO.BE.REDUCED 
SEL-REDUCTION.CODE.CLAUSES.TO.BE.REMOVED 
SEL-REDUCTION.CODE.UNIFIERS.TO.BE.REMOVED 
SEL-REDUCTION.CODE.LITERALS.TO.BE.REMOVED 
SEL-REFUTATION.RESULT 
SEL-REDUCTION.FLAG 
SEL=ELIMINATE 
SEL=ELIMINATE.ACTIVATE? 
SEL=ELIMINATE.UPDATE 
SEL=ELIMINATE.IS.ELIMINATING.LINK 
SEL=IS.ELIMINATING.EQUALITY 
SEL=INDUCTION.ACTIVATE? 
SEL=SHORTEN.TREE 
SEL=SIMPLIFY.TREE 
SEL=ACTIVATE.LITNO 
SEL=IND.ELIMINATE 
SEL=IND.REDUCTION 
SEL=GET.NEXT.EVAL.CLAUSE 
SEL=GET.NEXT.EVAL.LINKS 
SEL=GET.APPLICABLE.LINKS 
SEL=GET.OPTIMIZED.LINKS 
SEL=SELECT.EVAL.LINK 
SEL=GET.ALL.RELEVANT.LINK.CHAINS 
SEL=GET.EVAL.CHAIN 
SEL=FORMAT.EVAL.CHAIN 
SEL=GET.EVAL.LINK 
SEL=GET.PARALLEL.LINK 
SEL=INDUCTION.UPDATE 
SEL=INHERIT.LINKS.AND.LITERALS 
SEL=INHERIT.LITERALS 
SEL=MERGE.LITERALS 
SEL=REMOVE.LINK.FROM.EVAL 
SEL=INSERT.ALL.EVAL.LINKS 
SEL=INSERT.EVAL.PLINKS 
SEL=INSERT.EVAL.RLINKS 
SEL=PUT.MATCH.CHAIN 
SEL=INDUCTION 
SEL=PREPARE.EVAL.CHAINS 
SEL=GET.REFUTATION.CHAIN 
SEL=GET.REFUTATION 
SEL=IS.COMPLETE.REFUTATION 
SEL=GET.CILS.LIST 
SEL=IS.EQUALITY 
SEL=IS.INDUCTION.HYPOTHESIS 
SEL=IS.PART.OF.EQUIVALENCE 
SEL=IS.TERMINAL.RULE 
SEL=SORT.EQUIVALENCES 
SEL=SORT.EQUALITIES 
SEL=CONNECT.EQUIVALENCES 
SEL=COMPUTE.ALL.NEW.IF.CLAUSES 
SEL=COMPUTE.NEW.IF.CLAUSES 
SEL=INSERT.NEW.IF.CLAUSE 
SEL=GET.EQUIVALENT.LITERALS 
SEL=LITERALS.ARE.EQUIVALENT 
SEL=SUBST.LITLIST 
SEL=PERMUTE.LITLIST 
SEL=GET.VARIABLE.RENAMING 
SEL=GET.MERGING.LITERALS 
SEL=IF.CLAUSE.GET 
SEL=IF.CLAUSE.PUT 
SEL=SUBNODE.GET 
SEL=SUBNODE.PUT 
SEL=IND.GET.OPTION 
SEL=IND.PUT.OPTION 
SEL=RESET.TREE 
SEL=NEXT.NODE 
SEL=NEXT.SUBNODE 
SEL=ACTUAL.NODE 
SEL=ACTUAL.SUBNODE 
SEL=GET.SUBNODE 
SEL=SUBTREE.OF 
SEL=REPLACE.NODE 
SEL=REMOVE.SUBTREE 
SEL=RENUMBER.TREE 
SEL*ACTUAL.CLAUSES 
SEL*STEPCOUNTER 
SEL*STEPS 
SEL*TREE.POINTER.1 
SEL*TREE.POINTER.2 
SEL*IND.CASE.COUNTER 
SEL*IND.CHAIN 
SEL*IND.ACTUAL.ENTRY 
SEL*IND.SINGLE.LINK 
SEL*END.OF.INDUCTION 
SEL*IND.OLD.CLAUSES 
SEL*IND.NEW.CLAUSES 
SEL*IND.OLD.LINKS 
SEL*IND.OPTIONS 
SEL=CLASSIFY.CLAUSES 
SEL=WEIGTH_SET.FOREIGN 
SEL=WEIGTH_SYMBOL.WEIGHT 
SEL-WEIGHT 
SEL=WEIGHT_EVAL 
SEL=STRAT_VALUE 
SEL=STRAT_BASIC.VALUE 
SEL=STRAT_TOTAL.VALUE 
SEL=STRAT_ACTIVE.PLINK 
SEL=STRAT_ACTIVE.RLINK 
SEL=STRATEGIES 
SEL=LINK.VARIABLES 
SEL=STRATEGIES.ACTIVATE? 
SEL=STRATEGIES.ACTIVATE?.EXEC 
SEL=STRATEGIES.UPDATE 
SEL=STRATEGIES.UPDATE.EXEC 
SEL=STR.LABEL 
SEL=STR.DEFINE.STRATEGY 
SEL=HORN.RENAMABLE.TEST 
SEL=STR.SET.LINEAR.TOP.CLAUSE 
SEL=STR.LINEAR.CONNECTED.TO.TOP.CLAUSE 
SEL*STR_RESOLUTION.STRATEGY 
SEL*STR_PARAMODULATION.STRATEGY 
SEL*STR_LINEAR.TOP.CLAUSE 
SEL*LINKS_RPASSIVE 
SEL*LINKS_PACTIVE 
SEL*LINKS_PPASSIVE 
SEL*LINKS_RINHIBITED 
SEL*LINKS_PINHIBITED 
SEL=REDUCTIONS 
SEL=REDUCTIONS.ACTIVATE? 
SEL=REDUCTIONS.UPDATE 
SEL=REDUCTIONS.BOTH.PARENTS.PURE 
SEL=REDUCTIONS.RESOLVENT.REPLACES.PARENT 
SEL=MERGING 
SEL=MERGING.ACTIVATE? 
SEL=MERGING.UPDATE 
SEL=FACTORIZE 
SEL=FACTORIZE.ACTIVATE? 
SEL=FACTORIZE.UPDATE 
SEL=TERMINATOR 
SEL=TERMINATOR.ACTIVATE? 
SEL=TERMINATOR.UPDATE 
SEL=TERMINATOR.UNITS 
SEL=TERMINATOR.UNITS.ACTIVATE? 
SEL=TERMINATOR.UNITS.UPDATE 
SEL*TERMINATOR.PROVED.FLAG 
SEL*TERMINATOR.LOOK 
SEL=LINK.NOLIT 
SEL=LINK.NOLIT.UNIFY.P 
SEL=LINK.NOLIT.MERGES 
SEL=LINK.NOLIT.AFFECTED.MERGE 
SEL=MAKE.DEDUCTION.CODE 
SEL=MAKE.REDUCTION.CODE 
SEL=CLEAR.LINK.CLASSES 
SEL*LINKS_RACTIVE 
SEL*LINKS_PIWACTIVE 
SEL*LINKS.COLOUR.FLAG_ACTIVE 
SEL*LINKS.COLOUR.FLAG_PASSIVE 
SEL*LINKS.COLOUR.FLAG_INHIBITED 
SEL*LINKS_REDUCTIONS 
SEL*LINKS.COLOUR.FLAG_REDUCTIONS 
SEL=CLEAR.CLAUSE.CLASSES 
SEL*CLAUSES_SUPPORTED 
SEL*CLAUSES_INDUCTION 
SEL*CLAUSES_EQUIVALENCE 
SEL*CLAUSES_EQUALITY 
SEL*CLAUSES_IMPLICATION 
SEL*CLAUSES_DEDUCTION-RULES 
SEL*CLAUSES_ELIMINATINGEQUATIONS 
SEL*TERMINATOR.LOOK.NEW.CLAUSES 
SEL=UPDATE.CLAUSELISTS 
SEL=UPDATE.LINKLISTS 
SEL=LINKS 
SEL=CLAUSES 
SEL=INSERT.LINK 
SEL=INSERT.CLAUSE 
SEL=REMOVE.LINK 
SEL=REMOVE.CLAUSE 
SEL=PASSIVATE 
SEL=INHIBIT 
SEL=CHAIN 
SEL*CHAIN 
SEL*CHAIN.DELETE.INTERMEDIATE.RESULTS 
SEL*CHAIN.UNITS 
SEL*CHAIN.LINKS 
SEL*CHAIN.TAIL 
SEL*ACTUAL.DEDUCTION.CODE 
SEL*ACTUAL.REDUCTION.CODE 
SEL*DUMMY 
SEL=PASS.CONTROL 
SEL=NEXT.OPERATION 
SEL=RETURN 
SEL=UPDATE 
SEL=LINK.&.TERM.DEPTH.TREATMENT 
SEL=NO.REFUTATION.POSSIBLE? 
SEL=REFUTATION.FOUND 
SEL-SAVE.RESET 
SEL-SAVE 
;;; Reading source file "prog/sel/selection.lisp"
;;; GC: 290542 words [1162168 bytes] of dynamic storage in use.
;;; 381200 words [1524800 bytes] of free storage available before a GC.
;;; 1052942 words [4211768 bytes] of free storage available if GC is disabled.
;;; While compiling SEL=INDUCTION.ACTIVATE?
;;; Warning: Variable X is bound but not referenced
;;; While compiling SEL=SIMPLIFY.TREE
;;; Warning: Variable NODE is bound but not referenced
;;; While compiling SEL=GET.NEXT.EVAL.CLAUSE
;;; Warning: Variable LITLIST is bound but not referenced
;;; While compiling SEL=CHAIN
;;; Warning: DS-LINK.IS is a macro; (FUNCTION DS-LINK.IS) is probably incorrect
;;; Writing binary file "prog/sel/selection.sbin"
;;; Warning: The following function is not known to be defined:
;;;          SEL=SAVE.RESET was referenced by SEL-SAVE
;;; Loading binary file "prog/sel/selection.sbin"
;;; Loading source file "prog/sel/sel-mark.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=STR.INIT.MARK.RLINKS.SOS 
SEL=STR.INIT.MARK.RLINKS 
SEL=STR.MARK.RLINKS.SOS 
SEL=STR.MARK.SILINKS 
SEL=STR.MARK.RLINKS 
SEL=STR.INIT.MARK.PLINKS 
SEL=STR.MARK.PLINKS 
SEL=STR.MARK.PLINK.Z.K 
SEL=STR.MARK.SILINK.Z.K 
SEL=CLAUSE.LITERAL 
SEL=STR.MARK.PLINK.B.G.SPLIT 
SEL=STR.MARK.PLINK.B.G.SPLIT.SIBLING 
SEL=STR.MARK.PLINK.B.G.SIBLING 
SEL=STR.MARK.PLINK.B.G.STRICT.MAX.P 
SEL=STR.MARK.PLINK.B.G.MAX.P 
SEL=STR.MARK.PLINK.B.G.REDUCTIVE 
SEL=STR.MARK.PLINK.B.G.STRICT.P 
SEL=STR.MARK.PLINK.B.G.MERGE.P 
SEL=STR.MARK.SILINK.B.G 
SEL=STR.MARK.RLINK.B.G.IS 
SEL=STR.MARK.RLINK.B.G 
SEL=STR.MARK.PLINK.B.G.IS 
SEL=STR.MARK.PLINK.B.G 
SEL=STR.MARK.PLINK.H.C 
SEL=STR.MARK.PLINK.S.L.IS 
SEL=STR.MARK.PLINK.S.L 
SEL=STR.MARK.PLINK.D.IS 
SEL=STR.MARK.PLINK.D 
SEL=STR.MARK.PLINK 
SEL=MARK.UPDATE.S.L 
SEL=MARK.UPDATE.D 
SEL=MARK.UPDATE.B.G 
SEL=MARK.UPDATE.Z.K 
SEL=MARK.UPDATE.H.C 
;;; Reading source file "prog/sel/sel-mark.lisp"
;;; Writing binary file "prog/sel/sel-mark.sbin"
;;; Loading binary file "prog/sel/sel-mark.sbin"
;;; Loading source file "prog/sel/sel-manual.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
SEL=MANUAL 
SEL=MANUAL.EXEC 
SEL=MANUAL.ACTIVATE? 
SEL=PRINT.TO.STRING 
SEL=MANUAL.LIST.ITEMS 
SEL=MANUAL.MENU 
SEL=MANUAL.UPDATE 
;;; Reading source file "prog/sel/sel-manual.lisp"
;;; Writing binary file "prog/sel/sel-manual.sbin"
;;; Loading binary file "prog/sel/sel-manual.sbin"
;;; Loading source file "prog/ctl/control.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
CTL-REFUTE.GRAPHS.ON.FILE 
CTL-REFUTE.GRAPHS.ON.FILE1 
CTL-REFUTE.GRAPH.ON.FILE 
CTL-REFUTE.GRAPH 
CTL-INITIAL.GRAPH 
CTL*SPLITPARTS.REMAINING.FILES 
CTL*SPLITPARTS.INPUTSTREAM 
CTL*SPLITPARTS.INPUTSTREAM.COUNTER 
CTL*SPLITPARTS.RESULTS 
CTL*SPLITPART.FLAG 
CTL*CURRENT.SPLITPART.IDENTIFIER 
CTL*CURRENT.SPLITPART.INITIAL.REDUCTION.FLAG 
CTL*CURRENT.SPLITPART.INITIAL.SELECTION.FLAG 
CTL*CURRENT.SPLITPART.RESULT 
CTL*STEPCOUNTER 
CTL*PROOFTIME 
CTL*ABORT.FLAG 
CTL*ABORT.MACRO 
CTL=OPEN.AND.ADVANCE.FILE 
CTL=START 
CTL=END 
CTL=REFUTE.SPLITPARTS 
CTL=REFUTE.SPLITPARTS1 
CTL=REFUTE 
CTL=REDUCE.INITIAL 
CTL=INFERENCE.LOOP 
CTL=INFERENCE.STEP 
CTL=DEDUCE 
CTL=DEDUCE.UNITFACTORS 
CTL=REDUCE.PARTIAL 
CTL=REDUCE 
CTL=SAVE 
CTL=SAVE.FILENAME 
CTL*TRACE.OPEN.FLAG 
CTL*TRACE.OUTPUTSTREAM 
CTL*TRACE.OUTPUTSTREAM.LINELENGTH 
CTL=PR_OPEN 
CTL=PR_CLOSE 
CTL=PR_OPTIONS 
CTL=PR_REFUTATION.START 
CTL=PR_REFUTATION.END 
CTL=PR_CURRENT.GRAPH 
CTL=PR_CHANGES 
CTL=PR_GRAPH.DUMP 
CTL=PR_STATISTICS 
CTL=PR_MESSAGE 
CTL=PR_MESSAGE.FULL.LINE 
;;; Reading source file "prog/ctl/control.lisp"
;;; Writing binary file "prog/ctl/control.sbin"
;;; Warning: The following function is not known to be defined:
;;;          UPP-EPSILON.LITERALS.INSERT was referenced by CTL=START
;;; Loading binary file "prog/ctl/control.sbin"
;;; Loading source file "prog/os/os-explanation.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
OS.E-GET.EXPLANATION 
OS.E=HELP 
OS.E=COMMON.ERROR.MESSAGE_COMMAND.IGNORED 
OS.E=@ATP_SESSION.LANGUAGE 
OS.E=@ATP_INFO.AND.REPAIR.FILE 
OS.E=@ATP_EXPLAIN.HELP 
OS.E=READ&EXECUTE.ATP.COMMAND_START.EDIT 
OS.E=READ&EXECUTE.ATP.COMMAND_ERROR=ILLEGAL.COMMAND 
OS.E=VDT_ERROR=ILLEGAL.ARGUMENT 
OS.E=HARDCOPY_ERROR=ILLEGAL.ARGUMENT 
OS.E=HELP_V 
OS.E=HELP_VP 
OS.E=HELP_HP 
OS.E=HELP_HC 
OS.E=HELP_HELP 
OS.E=HELP_EXIT 
OS.E=HELP_LOGOFF 
OS.E=HELP_LISP 
OS.E=HELP_OPTIONS 
OS.E=HELP_INDUCTION 
OS.E=HELP_CONSTRUCT 
OS.E=HELP_CONSTRUCT.REFUTE 
OS.E=HELP_CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_EDIT 
OS.E=HELP_EDIT.CONSTRUCT 
OS.E=HELP_EDIT.CONSTRUCT.REFUTE 
OS.E=HELP_EDIT.CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_FORMULA 
OS.E=HELP_FORMULA.CONSTRUCT 
OS.E=HELP_FORMULA.CONSTRUCT.REFUTE 
OS.E=HELP_FORMULA.CONSTRUCT.REFUTE.PROTOCOL 
OS.E=HELP_REFUTE 
OS.E=HELP_REFUTE.PROTOCOL 
OS.E=HELP_PROTOCOL 
OS.E=HELP_COMMAND.NOT.IMPLEMENTED 
OS.E=HELP_DEFINE.DIRECTORY 
OS.E=HELP_DEFINE.EXAMPLE.NAME 
OS.E=HELP_SELECT.EXAMPLE 
OS.E=HELP.EXPLANATION_EXPLAIN.HELP 
OS.E=INDUCTION_ENTER.THEORY 
OS.E=ERROR.ILLEGAL.FILE 
OS.E=ERROR.NO.FILE.EXISTS 
OS.E=ERROR.ILLEGAL.ATP.VERSION 
OS.E=CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=CONSTRUCT.PROC_PROOF.COMMENT 
OS.E=CONSTRUCT.PROC_START.MESSAGE 
OS.E=CONSTRUCT.PROC_THEOREM.PROVED 
OS.E=CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=NO.PROBLEM.FILE.EXISTS 
OS.E=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=EDIT.PROC_PROOF.COMMENT 
OS.E=EDIT.PROC_ERROR=NOTHING.TO.PROVE 
OS.E=EDIT.PROC_START.EDIT.AXIOMS 
OS.E=EDIT.PROC_START.EDIT.THEOREMS 
OS.E=EDIT.PROC_WARNING=NO.AXIOMS 
OS.E=EDIT.PROC_WARNING=NO.THEOREMS 
OS.E=FORMULA.CONSTRUCT.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.INPUT.CONTROL_ERROR=MISSING.INPUT 
OS.E=FORMULA.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=FORMULA.PROC_PROOF.COMMENT 
OS.E=PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=PROTOCOL.PROC_LIST.FILE.MESSAGE 
OS.E=REFUTE.INPUT.CONTROL_ERROR=ILLEGAL.SPLITPART.ID 
OS.E=REFUTE.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=REFUTE.PROC_THEOREM.NOT.PROVED 
OS.E=REFUTE.PROC_THEOREM.PROVED 
OS.E=REFUTE.PROC_START.MESSAGE 
OS.E=FULL.LINE 
OS.E=FULL.LINES 
OS.E=REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=ILLEGAL.SPLITPART.ID 
OS.E=REFUTE.PROTOCOL.INPUT.CONTROL_ERROR=TOO.MANY.ARGS 
OS.E=OPTION_ENTER.MODULE 
OS.E=OPTION_ILLEGAL.OPTION.VALUE 
OS.E=OPTION_GET.HELP 
OS.E=OPT.PRINT_GET.HELP 
OS.E=OPT.READ_FILENAME? 
OS.E=OPT.READ_OPTIONS.SET 
OS.E=OPT.READ_INCONSISTENT.OPTIONS 
OS.E=OPT.WRITE_FILENAME? 
OS.E=OPT.PRETTYPRINT_FILENAME? 
OS.E=OPT.PRETTYPRINT_HEADLINE 
OS.E=OPT.PRETTYPRINT_DEFAULTVAL 
OS.E=OPT_ERROR=ILLEGAL.FILENAME 
OS.E=OPT_OUTPUT.END 
OS.E=OPT.HELP_HELP 
OS.E=OPT.HELP_PRINT 
OS.E=OPT.HELP_PPRINT 
OS.E=OPT.HELP_READ 
OS.E=OPT.HELP_WRITE 
OS.E=OPT.HELP_LISP 
OS.E=OPT.HELP_OK 
OS.E=OPT.HELP_V 
OS.E=OPT.HELP_AREA.ABBREVIATION 
OS.E=OPT.HELP_ALL.COMMANDS 
OS.E=OTHERWISE 
;;; Reading source file "prog/os/os-explanation.lisp"
;;; Writing binary file "prog/os/os-explanation.sbin"
;;; Loading binary file "prog/os/os-explanation.sbin"
;;; Loading source file "prog/os/operatingsystem.lisp"

#<Package "MARKGRAF-KARL" 160370E> 
T 
MKRP 
OS=INIT 
OS*READTABLE 
OS=READ&EXECUTE.ATP.COMMAND 
OS=NORMALIZE.ALLOWED.COMMAND 
@ 
OS*OPENED.P 
OS=VDT 
OS=HARDCOPY 
OS=HELP 
OS=HELP.EXPLANATION 
OS=OPEN.INPUT.FILE 
OS=OUTPUT.FILE.NAME.CHECK 
OS=INDUCTION 
OS=CONSTRUCT.AND.REFUTE 
OS=CONSTRUCT 
OS=CONSTRUCT.INPUT.CONTROL 
OS=CONSTRUCT.REFUTE 
OS=CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=CONSTRUCT.REFUTE.PROTOCOL 
OS=CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=CONSTRUCT.PROC 
OS=DEFINE.DIRECTORY 
OS=DEFINE.EXAMPLE.NAME 
OS=SELECT.EXAMPLE 
OS=CLIMB.DIRECTORY 
OS=EDIT 
OS=EDIT.INPUT.CONTROL 
OS=EDIT.CONSTRUCT 
OS=EDIT.CONSTRUCT.INPUT.CONTROL 
OS=EDIT.CONSTRUCT.REFUTE 
OS=EDIT.CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=EDIT.CONSTRUCT.REFUTE.PROTOCOL 
OS=EDIT.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=EDIT.PROC 
OS=FORMULA 
OS=FORMULA.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT 
OS=FORMULA.CONSTRUCT.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT.REFUTE 
OS=FORMULA.CONSTRUCT.REFUTE.INPUT.CONTROL 
OS=FORMULA.CONSTRUCT.REFUTE.PROTOCOL 
OS=FORMULA.CONSTRUCT.REFUTE.PROTOCOL.INPUT.CONTROL 
OS=FORMULA.PROC 
OS=PROTOCOL 
OS=PROTOCOL.INPUT.CONTROL 
OS=PROTOCOL.PROC 
OS=REFUTE 
OS=REFUTE.INPUT.CONTROL 
OS=REFUTE.PROTOCOL 
OS=REFUTE.PROTOCOL.INPUT.CONTROL 
OS=REFUTE.PROC 
OS=REFUTE.PROC.CR 
OS=SYSTEM.IS.READY.FOR 
OS=OPEN.CODE.FILE 
OS=CLOSE.CODE.FILE 
OS=OPEN.LIST.FILE 
OS=CLOSE.LIST.FILE 
OS=OPEN.PROBLEM.FILE 
OS=CLOSE.PROBLEM.FILE 
OS=OPEN.GRAPH.FILE 
OS=CLOSE.GRAPH.FILE 
OS=WRITE.PROBLEM.FILE 
OS=OPTION 
OS=OPT.PRINT 
OS=PRINT.OPTION.AREA 
OS=OPT.READ 
OS=OPT.WRITE 
OS=OPT.PRETTYPRINT 
OS=OPT.WRITE.AT.POS 
OS=OPT.HELP 
OS=WRITE.TEXT 
OS*COMMAND.SPELLINGS 
OS*RESET.FLG 
NIL 
OS*ACTUAL.PROBLEM.FILE 
OS*ACTUAL.CODE.FILE 
OS*ACTUAL.GRAPH.FILE 
OS*ACTUAL.LIST.FILE 
;;; Reading source file "prog/os/operatingsystem.lisp"
;;; Writing binary file "prog/os/operatingsystem.sbin"
;;; Loading binary file "prog/os/operatingsystem.sbin"
----- Memory: Initialization with size 10000.
#P"/home1/mkrp/sys/boot.lisp"
USER: (quit)
;;; Dribble file "compilerlisting.text" finished
;;; Dribble file "compilerlisting.text" finished
;;; Dribble file "compilerlisting.text" finished
;;; Dribble file "compilerlisting.text" finished
