\chapter{The Output Facilities}
\label{TheOutputFacilities}

When the user sets the options for a proof, he can determine the output by 
specifying various parameters in the trace and protocol option areas. 

\section{Protocol}

A protocol listing\index{protocol}\index{protocol listing}
normally includes the following informations: 
\begin{itemize} 
\item	the user's input: axioms, theorems, options 
\item	preliminary transformation: axioms and theorems in clausal
normal form and the system table of all symbols used 

\item proof steps: parent clause(s), type of operation, resulting clause, 
unifier 
\end{itemize} 

A listing can be generated by calling the PROTOCOL-subsystem with a
code file as parameter.  The information in the code file depends on
the adjustment of the protocol options.


\subsubsection{PR\_PROTOCOL}
\index{{\sc pr\_protocol}}
\index{protocol} \index{option protocol} \index{protocol option protocol}

This option controls the generation of a code file (see page 
\pageref{codefile}).

\PO
\oline{$^*$T/Y/YES}{	Raw data for the protocol are written to a file in the standard {\sc Mkrp}-representation.}
\oline{POST/P}{Data is written in the language POST.}
  \oline{NIL/N/NO}{	No raw data for the protocol are written to a file.}

\subsubsection{PR\_INFIX.FORM}
\index{{\sc pr\_infix.form}}
\index{infix form} \index{option infix form} \index{protocol option infix form}
	
Determines whether the infix form of the input formulae is written
into the protocol.

\PO 
\oline{$^*$T/Y/YES}{	Switched on.}
  \oline{NIL/N/NO}{	Switched off.}

\subsubsection{PR\_PREFIX.FORM}
\index{{\sc pr\_prefix.form}}
\index{prefix form} \index{option prefix form} \index{protocol option prefix form}

Prefix form of input formulae in protocol.

\PO
  \oline{T/Y/YES}{	Switched on.}
\oline{$^*$NIL/N/NO}{	Switched off.}

\subsubsection{PR\_OPTIONS}
\index{{\sc pr\_options}}
\index{options} \index{option options} \index{protocol option options}

Values of proof options in protocol.

\PO
  \oline{T/Y/YES}{	Switched on.}
\oline{$^*$NIL/N/NO}{	Switched off.}

\subsubsection{PR\_SYMBOLS}
\index{{\sc pr\_symbols}}
\index{symbols} \index{option symbols} \index{protocol option symbols}

Symbol Table in Protocol.

\PO
\oline{$^*$T/Y/YES}{	Switched on.}
  \oline{NIL/N/NO}{	Switched off.}

\subsubsection{PR\_NEW.PNAMES}
\index{{\sc pr\_new.pnames}}
\index{new pnames} \index{option new pnames} \index{protocol option new pnames}

The value of this option controls the generation of new print names for clauses 
in the protocol.

\PO
\oline{$^*$T/Y/YES}{	New print names for clauses in the protocol are generated.}
  \oline{NIL/N/NO}{	The same clause names as in proof will be used. In the proof 			identical names may be used for logically different clauses.}

\subsubsection{PR\_DIFFERENT.VARIABLES}
\index{{\sc pr\_different.variables}}
\index{different variables} \index{option different variables} \index{protocol option different variables}

The value of this option controls the generation of names for the variables 
in protocol.

\PO
  \oline{T/Y/YES}{	Different names for variables in the protocol.}
\oline{$^*$NIL/N/NO}{	Different clauses may contain the same variables.}

\subsubsection{PR\_DIRECT.PROOF}
\index{{\sc pr\_direct.proof}}
\index{direct proof} \index{option direct proof} \index{protocol option direct proof}
The value of this option influences which deduction steps are written to 
the protocol file. 

\PO
\oline{$^*$T/Y/YES}{Only deduction steps necessary for the proof are written to 
			the protocol.}
  \oline{NIL/N/NO}{All steps including unnecessary ones appear in the 
protocol.}


\subsubsection{PR\_LEFT.MARGIN}
\index{{\sc pr\_left.margin}}
\index{left margin} \index{option left margin} \index{protocol option left margin}

First position to be printed in each line.

\PO
\olineeins{Integers between 0 and 50 inclusive.}
\oline{$^*$Default Value}{0}

\subsubsection{PR\_RIGHT.MARGIN}
\index{{\sc pr\_right.margin}}
\index{right margin} \index{option right margin} \index{protocol option right margin}

Last position to be printed in each line.

\PO
\olineeins{Integers between 50 and 255 inclusive.}
\oline{$^*$Default Value}{117}

\subsubsection{PR\_LINELENGTH}
\index{{\sc pr\_linelength}}
\index{linelength} \index{option linelength} \index{protocol option linelength}

Number of characters per line.

\PO
\olineeins{Integers between 32 and 256 inclusive.}
\oline{$^*$Default Value}{117}

\subsubsection{PR\_LATEX}
\index{{\sc pr\_latex}}
\index{latex} \index{option latex} \index{protocol option latex}

Determines whether the output is directly readable for users or
can serve as input to \LaTeX.

\PO
  \oline{T/Y/YES}{\LaTeX.}
\oline{$^*$NIL/N/NO}{Pretty printed.}


\subsubsection{PR\_LITERALS}
\index{{\sc pr\_literals}}
\index{literals} \index{option literals} \index{protocol option literals}
Protocol assignments of literals to occurrences in the input
formulae. This assignment is necessary if the protocol file is used as
input to the Gentzen proof transformation system (see \cite{Lingenfelder90}).

\PO
\oline{$^*$T/Y/YES}{Switched on.}
  \oline{NIL/N/NO}{Switched off.}



\section{Trace}

For debugging purposes, the {\sc Mkrp}-system has special trace functions, 
tracing the preprocessing or the deduction steps for instance. These 
functions can be invoked by setting trace options. 


\subsection{Options}

\subsubsection{TR\_PREPROCESSING}
\index{{\sc tr\_preprocessing}}
\index{preprocessing} \index{option preprocessing} \index{trace option preprocessing}

Trace of the intermediate results of the preprocessors.

\PO
\oline{  T/Y/YES}{	Switched on.}
\oline{$^*$NIL/N/NO}{	Switched off.}

\subsubsection{TR\_STEP.MODE}
\index{{\sc tr\_step.mode}}
\index{step mode} \index{option step mode} \index{trace option step mode}

Trace of each deduction step.

\PO
  \oline{NIL/N/NO}{	No trace is done.}
  \oline{I/IMP}{Detailed implementational protocol of all changes (clauses 
and 			links).}
  \oline{L/LOG}{Protocol of all changes in a more logical form (clauses).}
\oline{$^*$LR}{Same as under L, additionally variables are renamed. }

\subsubsection{TR\_DUMP}
\index{{\sc tr\_dump}}
\index{dump} \index{option dump} \index{trace option dump}

Dump of the current graph after certain intervals.

\PO
\oline{$^*$NIL/N/NO}{	No dump is done.}
  \oline{positive integer}{Number of deduction-steps between two subsequent dumps.}


\subsubsection{TR\_CLAUSE.MODE}
\index{{\sc tr\_clause.mode}}
\index{clause mode} \index{option clause mode} \index{trace option clause mode}

Format of the output of clauses if TR\_DUMP is set.

\PO
\oline{$^*$NIL/N/NO}{	No output at all.}
  \oline{I/IMPL}{	Output is implementational.}
  \oline{L/LOG}{Logical output.}
  \oline{LR}{Same as under L, additionally variables are renamed.}

\subsubsection{TR\_LINK.MODE}
\index{{\sc tr\_link.mode}}
\index{link mode} \index{option link mode} \index{trace option link mode}

Format of the output of links if TR\_DUMP is set.

\PO
  \oline{NIL/N/NO}{	No output at all.}
\oline{$^*$I/IMPL}{    Output is implementational.}

\subsubsection{TR\_TRACE.FILE}
\index{{\sc tr\_trace.file}}
\index{trace file} \index{option trace file} \index{trace option trace file}

Output file for traces and dumps.

\PO
\oline{$^*$NIL/N/NO}{	No output at all.}
  \oline{T/TERMINAL}{  Output on terminal.}
  \oline{$<$FILE$>$}{     	Output on $<$File$>$.}

\subsubsection{TR\_TERMINAL}
\index{{\sc tr\_terminal}}
\index{terminal} \index{option terminal} \index{trace option terminal}

Brief information about the proof displayed on terminal (in addition to the 
displayed statistics).

\PO
\oline{NIL/N/NO}{	Switched off.}
  \oline{$^*$T/Y/YES}{	Switched on.}

\paragraph{Remark}
It is advisable to switch on the terminal trace because the theorem prover
never behaves as the user expects and this is the first step towards getting
an intuition what happens.


\subsection{Dump Function}
Sometimes one likes to have an output of the current state of the
graph. This can be achieved by suspending the proof and entering a
call to the Lisp function {\tt cg-dump}, which is specified as
follows.

{\tt (cg-dump} {\em cg.file} {\em cg.commands}{\tt )}

The actual graph is printed according to the commands given as a list
in {\em cg.commands}. There are the commands:

{\tt (message} $s_1 \dots s_n${\tt )}: The $s_i$ are 
printed into one line separated by blanks.
             
{\tt (separator)}: If this command occurs, the dump is enclosed
between a heading and a footing line.
             
{\tt (clauses} {\em c format}{\tt )}: {\em c} is either one of the
atoms {\tt all}, {\tt inserted}, {\tt removed}, {\tt changed}, or
a list of clauses. {\em format} is in \{{\tt I}, {\tt L},
{\tt LR}, {\tt N}, {\tt A}\} meaning the formats implementational,
logical, logical with variable renaming, print names, or addresses.
If {\em c} is one of the given atoms, the
corresponding clauses of the actual graph are computed.
The resulting clauses are printed in the given
format.

{\tt (links} {\em l colours format}{\tt )}: {\em l} is either one of
the atoms {\tt all}, {\tt inserted}, {\tt removed}, {\tt changed}, or
a list of links. {\em colours} is a list of
link colours. {\em colours} = {\tt nil} means all colours.  {\em
format} is in \{{\tt i}, {\tt a}\}, meaning the formats
implementational or address list. If
{\em l} is one of the given atoms, the corresponding links of the actual
graph are computed. The resulting
links are printed clustered by the given colours in the given format.


\Ex

{\tt (cg-dump t ((clauses all lr)))} prints all clauses in the actual
graph on the screen, using the same format as the TR\_TERMINAL parameter.
